Марина Полубенцева
Ñàíêò-Ïåòåðáóðã
«ÁÕÂ-Ïåòåðáóðã»
2008
УДК 681.3.068+800.92С/С++
ББК 32.973.26-018.1
П53
Полубенцева М. И.
П53 С/С++. Процедурное программирование. — СПб.: БХВ-Петербург, 2008. —
448 с.: ил. — (Внесерийная)
ISBN 978-5-9775-0145-3
Подробно рассмотрены процедурные возможности языков программирова-
ния C/C++. Изложены основные принципы строения программы на языке С/С++:
раздельная компиляция, функциональная декомпозиция, блоки кода. Описаны
синтаксические конструкции языка и показана специфика их использования.
Подробно излагаются понятия, связанные с представлением данных: виды
данных, их представление в тексте программы, размещение в памяти, время су-
ществования и области видимости. Описано назначение и принцип работы пре-
процессора. Детально рассмотрены указатели и массивы, а также их взаимосвязь
в языке С/С++. Приведена сравнительная характеристика ссылок С++ и указате-
лей. Обсуждаются сложные программные элементы. Рассмотрены агрегатные
пользовательские типы данных языка С: структуры, объединения.
Для программистов и разработчиков встраиваемых систем
УДК 681.3.068+800.92С/С++
ББК 32.973.26-018.1
Группа подготовки издания:
Главный редактор Екатерина Кондукова
Зам. главного редактора Игорь Шишигин
Зав. редакцией Григорий Добин
Редактор Римма Смоляк
Компьютерная верстка Натальи Караваевой
Корректор Виктория Пиотровская
Дизайн серии Инны Тачиной
Оформление обложки Елены Беляевой
Зав. производством Николай Тверских
Ëèöåíçèÿ ÈÄ ¹ 02429 îò 24.07.00. Ïîäïèñàíî â ïå÷àòü 30.11.07.
Ôîðìàò 70×1001/16. Ïå÷àòü îôñåòíàÿ. Óñë. ïå÷. ë. 36,12.
Òèðàæ 2000 ýêç. Çàêàç ¹
"ÁÕÂ-Ïåòåðáóðã", 194354, Ñàíêò-Ïåòåðáóðã, óë. Åñåíèíà, 5Á.
Ñàíèòàðíî-ýïèäåìèîëîãè÷åñêîå çàêëþ÷åíèå íà ïðîäóêöèþ
¹ 77.99.02.953.Ä.006421.11.04 îò 11.11.2004 ã. âûäàíî Ôåäåðàëüíîé ñëóæáîé
ïî íàäçîðó â ñôåðå çàùèòû ïðàâ ïîòðåáèòåëåé è áëàãîïîëó÷èÿ ÷åëîâåêà.
Îòïå÷àòàíî ñ ãîòîâûõ äèàïîçèòèâîâ
â ÃÓÏ "Òèïîãðàôèÿ "Íàóêà"
199034, Ñàíêò-Ïåòåðáóðã, 9 ëèíèÿ, 12
ISBN 978-5-9775-0145-3 © Полубенцева М. И., 2008
© Оформление, издательство "БХВ-Петербург", 2008
Îãëàâëåíèå
Введение..................................................................................................................1
Предисловие ............................................................................................................2
Особенности изложения .........................................................................................3
Благодарности .........................................................................................................5
Глава 1. Общие принципы процедурного программирования....................7
1.1. О современном программировании в целом .................................................7
1.1.1. Историческая справка ...............................................................................7
1.1.2. Этапы создания программного продукта................................................8
1.1.3. Памятка программисту .............................................................................9
1.1.4. Критерии хорошего программного продукта .......................................11
1.2. Структура программы....................................................................................11
1.2.1. Разбиение на файлы (модульность) и связанные
с этим понятия С/С++...................................................................................13
1.2.2. Функциональная декомпозиция и связанные с ней понятия...............18
1.2.3. Блоки кода ................................................................................................24
1.2.4. Оформление текста программы. Комментарии и отступы..................26
Глава 2. Базовые понятия С/С++.....................................................................29
2.1. Ключевые слова..............................................................................................29
2.2. Идентификаторы (имена) ..............................................................................29
2.3. Понятия lvalue и rvalue ..................................................................................30
2.4. Операторы.......................................................................................................31
2.4.1. Арифметические операторы...................................................................36
2.4.2. Операторы присваивания........................................................................38
2.4.3. Побитовые операторы.............................................................................39
2.4.4. Логические операторы и операторы отношения ..................................43
2.4.5. Тернарный оператор ?: ...........................................................................45
2.4.6. Оператор ","..............................................................................................47
IV Îãëàâëåíèå
Глава 3. Данные...................................................................................................49
3.1. Виды данных ..................................................................................................49
3.2. Константы (литералы) ...................................................................................51
3.2.1. Целые литералы.......................................................................................52
3.2.2. Литералы с плавающей точкой ..............................................................54
3.2.3. Символьные литералы ............................................................................55
3.2.4. Строковые литералы ...............................................................................61
3.3. Перечисление enum........................................................................................62
3.4. Переменные ....................................................................................................65
3.4.1. Что такое тип переменной ......................................................................66
3.4.2. Фундаментальные (базовые, встроенные) типы С/С++.......................67
3.4.3. Оператор sizeof и размеры переменных ................................................69
3.4.4. Знаковость переменной...........................................................................71
3.4.5. Приведение типов....................................................................................73
3.4.6. Тип wchar_t ..............................................................................................81
3.4.7. Тип bool и BOOL......................................................................................81
3.5. Понятия объявления и определения.............................................................82
3.5.1. Объявление переменной .........................................................................83
3.6. Способы использования переменных и типы компоновки........................86
3.6.1. Безопасная сборка проекта (type-safe linkage) ......................................88
3.7. Размещение и время существования переменных ......................................89
3.7.1. Ключевое слово static..............................................................................91
3.8. Область видимости переменной (scope) ......................................................94
3.8.1. Скрытие (замещение) имени переменной.............................................95
3.8.2. Пространства имен — namespace ..........................................................97
3.9. Инициализация переменных .......................................................................108
3.9.1. Явная инициализация переменных (программистом) .......................108
3.9.2. Неявная инициализация переменных (компилятором)......................108
3.10. Модификаторы const и volatile .................................................................109
3.10.1. Ключевое слово const ..........................................................................109
3.10.2. Ключевое слово volatile ......................................................................110
Глава 4. Инструкции (statements) С/С++.......................................................113
4.1. Общая информация об инструкциях ..........................................................113
4.2. Инструкции выбора (условия) ....................................................................115
4.2.1. Инструкции if, if…else ...........................................................................115
4.2.2. Переключатель — switch ......................................................................118
4.3. Инструкции цикла ........................................................................................122
4.3.1. Инструкция while ...................................................................................123
4.3.2. Инструкция do...while ............................................................................127
4.3.3. Инструкция for .......................................................................................129
4.4. Инструкции безусловного перехода: break, continue, return, goto ..........134
Îãëàâëåíèå V
Глава 5. Препроцессор. Заголовочные файлы ............................................137
5.1. Директивы препроцессора ..........................................................................137
5.2. Директива #define.........................................................................................138
5.2.1. Использование директивы #define .......................................................139
5.2.2. Предопределенные макросы ................................................................143
5.2.3. Диагностический макрос assert............................................................144
5.2.4. Рекомендации.........................................................................................145
5.3. Директива #undef..........................................................................................145
5.4. Директивы #ifdef, #ifndef, #else и #endif .....................................................147
5.5. Директивы #if, #elif, #else, #endif. Оператор препроцессора defined ......149
5.6. Директива #include. Заголовочные файлы.................................................152
5.6.1. Концепция разделения на интерфейс и реализацию. Механизм
подключения заголовочных файлов ..............................................................153
5.6.2. Формы директивы #include...................................................................156
5.6.3. Вложенные включения заголовочных файлов
(стратегии включения) ...........................................................................157
5.6.4. Предкомпиляция заголовочных файлов..............................................159
5.6.5. Заголовочные файлы стандартной библиотеки..................................162
5.6.6. Защита от повторных включений заголовочных файлов ..................166
5.6.7. Что может быть в заголовочных файлах
и чего там быть не должно ...................................................................167
5.7. Директива #pragma ......................................................................................170
5.8. Директива #error ..........................................................................................171
Глава 6. Указатели и массивы .......................................................................173
6.1. Указатели ......................................................................................................173
6.1.1. Объявление и определение переменной-указателя............................175
6.1.2. Инициализация указателя и оператор получения адреса
объекта — &...........................................................................................177
6.1.3. Получение значения объекта посредством указателя: оператор
разыменования — *...............................................................................179
6.1.4. Арифметика указателей ........................................................................180
6.1.5. Указатель типа void* .............................................................................182
6.1.6. Нулевой указатель (NULL-pointer).......................................................184
6.1.7. Указатель на указатель..........................................................................186
6.1.8. Указатель и ключевые слова const и volatile.......................................187
6.1.9. Явное преобразование типа указателя.................................................192
6.2. Массивы ........................................................................................................196
6.2.1. Объявление массива ..............................................................................196
6.2.2. Обращение к элементу массива — оператор [] ..................................198
6.2.3. Инициализация массива........................................................................200
6.2.4. Массивы и оператор sizeof....................................................................206
VI Îãëàâëåíèå
6.3. Связь массивов и указателей.......................................................................207
6.3.1. Одномерные массивы............................................................................207
6.3.2. Двухмерные массивы более подробно ................................................210
6.3.3. Многомерные массивы .........................................................................214
6.3.4. Массивы указателей ..............................................................................216
6.4. Динамические массивы ...............................................................................218
6.4.1. Управление памятью. Низкоуровневые функции языка Си..............219
6.4.2. Управление памятью. Операторы С++ new и delete...........................222
6.4.3. Сборщик мусора (garbage collector) ....................................................225
6.4.4. Операторы new[] и delete[ ] и массивы ...............................................225
6.4.5. Инициализация динамических массивов ............................................234
Глава 7. Ссылки ................................................................................................235
7.1. Понятие ссылки............................................................................................235
7.2. Сравнение ссылок и указателей..................................................................236
Глава 8. Функции..............................................................................................241
8.1. Понятия, связанные с функциями...............................................................241
8.1.1. Объявление (прототип) функции .........................................................244
8.1.2. Определение функции (реализация)....................................................246
8.1.3. Вызов функции ......................................................................................248
8.1.4. Вызов inline-функции............................................................................252
8.1.5. Соглашения о вызове функции ............................................................254
8.2. Способы передачи параметров в функцию ...............................................259
8.2.1. Передача параметров по значению (Call-By-Value) ...........................259
8.2.2. Передача параметров по адресу ...........................................................260
8.2.3. Специфика передачи параметров.........................................................264
8.2.4. Переменное число параметров.............................................................272
8.3. Возвращаемое значение...............................................................................287
8.3.1. Виды возвращаемых значений и механизмы их формирования.......287
8.3.2. Проблемы при возвращении ссылки или указателя...........................290
8.4. Ключевое слово const и функции ...............................................................292
8.4.1. Передача функции константных параметров .....................................293
8.4.2. Возвращение функцией константных значений.................................294
8.5. Перегрузка имен функций...........................................................................295
8.5.1. Возможные конфликты при использовании параметров
по умолчанию........................................................................................298
8.6. Рекурсивные функции .................................................................................298
8.7. Указатель на функцию.................................................................................301
8.7.1. Определение указателя на функцию....................................................301
8.7.2. Инициализация указателя на функцию ...............................................302
Îãëàâëåíèå VII
8.7.3. Вызов функции посредством указателя ..............................................302
8.7.4. Использование указателей на функции в качестве параметров........303
8.7.5. Использование указателя на функцию в качестве
возвращаемого значения.......................................................................305
8.7.6. Массивы указателей на функции .........................................................306
8.8. Ключевое слово typedef и сложные указатели ..........................................308
8.8.1. Ключевое слово typedef и указатели на функции ...............................308
8.8.2. Функции, возвращающие сложные указатели....................................308
Глава 9. Структуры ..........................................................................................313
9.1. Зачем нужны структуры ..............................................................................313
9.2. Объявление структуры ................................................................................314
9.3. Создание экземпляров структуры и присваивание значений
полям структуры .........................................................................................316
9.4. Ключевое слово typedef и структуры .........................................................318
9.5. Совмещение объявления и определения. Анонимные структуры ..........319
9.6. Инициализация структурных переменных ................................................320
9.7. Действия со структурами ............................................................................321
9.8. Поля структуры пользовательского типа...................................................322
9.9. Вложенные (nested) структуры ...................................................................323
9.10. Указатели и структуры ..............................................................................324
9.11. Упаковка полей структуры компилятором. Оператор sizeof
применительно к структурам ....................................................................326
9.12. Cтруктуры и функции................................................................................329
9.12.1. Передача структуры в функцию в качестве параметра ...................329
9.12.2. Возврат структуры по значению ........................................................332
9.13. Что можно использовать в качестве поля структуры .............................333
9.14. Поля битов ..................................................................................................334
Глава 10. Объединения (union).......................................................................345
10.1. Понятие объединения ................................................................................345
10.2. Использование объединений.....................................................................346
10.3. Размер объединения...................................................................................349
10.4. Инициализация объединений....................................................................350
10.5. Анонимные объединения (специфика Microsoft) ...................................351
П Р И Л О Ж Е Н И Я .........................................................................................353
Приложение 1. Представление данных.........................................................355
П1.1. О системах счисления и изображении количеств ..................................355
П1.2. Перевод чисел из одной системы счисления в другую .........................357
VIII Îãëàâëåíèå
П1.3. Использование различных систем счисления при технической
реализации средств цифровой вычислительной техники .....................361
П1.4. Особенности выполнения арифметических операций
в ограниченной разрядной сетке..............................................................362
П1.5. Изображение знакопеременных величин................................................363
П1.6. Выявление переполнений при выполнении сложения и вычитания....367
П1.7. Смена знака целого знакопеременного числа ........................................370
П1.8. Действия с повышенной разрядностью ..................................................370
П1.9. Особенности умножения и деления целых двоичных чисел ................371
П1.10. Приведение типов данных......................................................................372
П1.11. Числа с плавающей точкой ....................................................................375
П1.11.1. Неоднозначность представления и нормализованная форма.......376
П1.11.2. Форматы представления чисел ПТ двоичным кодом ...................380
П1.11.3. Стандарт на числа ПТ ANSI/IEEE 754-1985 ..................................381
П1.12. О понятии старшинства арифметических типов данных ....................384
П1.13. Битовые поля и операции над ними ......................................................385
П1.13.1. Подробнее об операциях сдвига......................................................390
Приложение 2. Язык Си и низкоуровневое программирование .............392
П2.1. Низкоуровневая (регистровая) модель вычислительного ядра ............398
П2.1.1. Оптимизация фрагмента кода по скорости ......................................399
П2.1.2. Определение положения программы в пространстве адресов.......401
П2.1.3. Использование средств уровня языка Ассемблера
в программах на Си ............................................................................401
П2.1.4. Работа с регистрами периферийных устройств...............................404
П2.1.5. Синхронизация программы с внешним событием ..........................406
П2.2. Программирование обработчиков прерываний......................................408
П2.2.1. Запрет/разрешение прерываний процессору ...................................409
П2.2.2. Приоритеты и управление ими..........................................................410
П2.3. Программирование без операционной системы.....................................412
Предметный указатель ....................................................................................415
Введение
— Сынок, будешь хорошо учиться — купим
тебе компьютер.
— А если буду плохо учиться?
— Тогда купим пианино.
Я хочу стать программистом, когда вырасту
большим, потому что это классная работа и
простая. Поэтому в наше время столько про-
граммистов и все время становится больше.
Программистам не нужно ходить в школу, им
нужно учиться читать на компьютерном языке,
что бы они могли с компьютером разговаривать.
Думаю, что они должны уметь читать тоже, что-
бы знать в чем дело, когда все напереполох.
Программисты должны быть смелыми, чтобы
не пугаться, когда все перепуталось так, что
никто не разберет, или если придется разгова-
ривать на английском языке по-иностранному,
чтобы знать, что надо делать.
Еще мне нравится зарплата, которую про-
граммисты получают. Они получают столько
денег, что не успевают их все тратить. Это
происходит потому, что все считают работу
программиста трудной, кроме программи-
стов, которые знают, как это просто.
Нет ничего такого, что бы мне не понрави-
лось, кроме того, что девчонкам нравятся
программисты и все хотят выйти за них за-
муж, и поэтому женщин надо гнать, чтобы не
мешали работать.
Надеюсь, что у меня нет аллергии на офис-
ную пыль, потому что на нашу собаку у меня
аллергия. Eсли у меня будет аллергия на
офисную пыль, программиста из меня не по-
лучится и придется искать настоящую работу.
Cочинение 7-летнего Тараса по теме: "Кем
я хочу стать, когда я буду большим"
2 Введение
Предисловие
Вряд ли можно сказать что-либо новое о программировании на С/С++, тем
более страшно подумать, сколько книг написано на эту тему, и какими авто-
рами! В свое оправдание могу сказать лишь следующее: писать книги вооб-
ще (и эту в частности) мне бы никогда не пришло в голову, если бы мои сту-
денты постоянно не упрекали меня в том, что они успевают одно из двух: или
понимать, или конспектировать. Механическую часть работы я решила взять
на себя, поэтому однажды летом, находясь в отпуске (эта ремарка для моего
начальства), я села за компьютер…
Ну, а если серьезно, то хочу сказать, что материал этой книги является как
обобщением накопленного личного практического опыта программирования
на С++, так и результатом моей преподавательской деятельности.
Далеко не сразу мне удалось сформулировать причины, по которым, несмот-
ря на огромное количество блестящих книг по этой теме, я все-таки рискнула
написать еще одну.
За многие годы программирования на С/С++ я сама сталкивалась с много-
численными проблемами, на понимание и разрешение которых уходила уйма
времени. Не хочется, чтобы это время пропало даром.
Концепция преподавания одного и того же предмета у каждого преподава-
теля своя. Я лично всегда пыталась понять и объяснить, в первую очередь,
себе самой: как и почему. В книге постаралась структурировать ответы на
эти вопросы. В частности, для понимания того, как некоторые свойства
языка реализуются компилятором, иногда приходится разбираться с низко-
уровневым кодом, в который компилятор превращает текст программы на
С/С++, или анализировать, каким образом компилятор располагает данные
в памяти. Без подобного понимания, конечно же, можно обойтись, но тогда
остается просто заучивать правила. Однажды получила забавный отзыв на
свой курс: "Три года программировал на Си, только теперь начал понимать,
что делаю".
Большинство современных авторов книг, посвященных С++, довольно под-
робно описывают объектно-ориентированные возможности языка, уделяя
минимум внимания базовым понятиям языка С/С++. Возможно, начинаю-
щий программист найдет в данном пособии структурированный материал
по этой теме, а программист, уже имеющий опыт программирования на
С/С++, откроет для себя возможности языка, которыми он до сих пор не
пользовался (или пользовался неосознанно). Надеюсь, эта книга будет по-
лезна разработчикам программного обеспечения для встраиваемых приме-
Введение 3
нений (в настоящее время программы для микроконтроллеров пишут в ос-
новном на языке Си).
Я попыталась написать книгу, в которой рассматриваются не только сами по
себе основные понятия процедурного программирования на С/С++, но и
взаимосвязи между этими понятиями. В программировании (как и в любой
другой области) количество взаимосвязей между элементами существенно
превышает количество самих элементов, а изложение, увы, линейно. Невоз-
можно придумать способ, с помощью которого все можно было бы объяс-
нить последовательно. Поэтому в книге много ссылок как вперед, так и назад.
Это может даже несколько раздражать читателя, однако именно наличие та-
ких ссылок позволяет быстрее преодолеть трудность начального этапа, когда
изучающему еще почти ничего не известно, и поэтому мало что понятно.
И, наоборот, бывает очень полезно вернуться по ссылке назад к тому мате-
риалу, который был не понят или пропущен. В результате в голове у учаще-
гося формируется грубая (приближенная) модель внутренней структуры изу-
чаемого предмета, а после этого существенно облегчается восприятие
последующего материала, поскольку начинает активно работать ассоциатив-
ная память.
При чтении лекций я стараюсь пояснять материал разнообразнейшими ри-
сунками, т. к. мне кажется, что таким образом материал воспринимается
и запоминается лучше. Этот принцип изложения попыталась реализовать
и в книге.
Особенности изложения
Данная книга содержит описание процедурных возможностей языков про-
граммирования Си и С++. Язык Си является чисто процедурным, а язык С++
был создан на базе Си, поэтому он совмещает традиционный процедурный
подход с подходом объектно-ориентированным (в книге рассматриваются
процедурные возможности одновременно для обоих языков).
При создании этих языков разработчики преследовали, прежде всего, цель
повышения эффективности. Оба языка обладают низкоуровневыми возмож-
ностями, присущими языкам Ассемблера, и требуют от программиста боль-
шей ответственности (по сравнению с программированием на других языках
высокого уровня).
В языке С++ появились понятия, которых не было в языке Си. Так как эти
понятия (ссылки, перегрузка имен функций и т. д.) расширяют, в частности,
4 Введение
процедурные возможности С++, то они рассмотрены в данной книге наравне
с другими базовыми понятиями. Также согласно стандарту языка С++
ISO/IEC 14882 "Standard for the C++ Programming Language" рассмотрены но-
вые операторы явного приведения типа (static_cast, reinterpret_cast,
const_cast) и пространства имен (namespace).
Языки С/С++ похожи, в первую очередь, тем, что являются синтаксически
сложными, поэтому одна из целей данной книги — адаптация к нетривиаль-
ному (в отличие от других высокоуровневых языков) синтаксису, опреде-
ляющему широкие возможности рассматриваемых языков.
Хочется обратить внимание читателя на некоторые моменты, прежде чем он
перейдет к основным главам:
􀂈 большинство рассматриваемых в книге понятий справедливы как для язы-
ка Си, так и для языка С++. В тех случаях, когда существуют отличия, яв-
но указывается, для какого языка эти понятия реализованы;
􀂈 термин "объект" используется в данной книге для обозначения любого
низкоуровневого понятия С/С++ и не имеет отношения к объектно-
ориентированному программированию;
􀂈 примеры низкоуровневого кода для пояснения действий компилятора
приводятся для VC.net 2005;
􀂈 чтобы привлечь внимание читающего, некоторые существенные элементы
в листингах подчеркнуты;
􀂈 по ходу изложения материала читателю предлагаются задания, над кото-
рыми он должен подумать самостоятельно, они сопровождаются пикто-
граммой ;
􀂈 помимо основных 10 глав в книге имеются два приложения, в которых
рассмотрены механизмы низкоуровневой реализации в цифровых процес-
сорах многих элементов и конструкций языка Си. Знание этих механизмов
необходимо при написании низкоуровневых драйверов аппаратных уст-
ройств, а также при оптимизации кода с целью повышения его эффектив-
ности (по быстродействию или объему требуемой памяти).
Введение 5
Благодарности
Не могу не выразить свою признательность:
􀂈 своему мужу, Новицкому Александру Петровичу, за написанные для дан-
ной книги приложения;
􀂈 еще раз своему мужу за роль самого строгого технического редактора и
мужество меня критиковать (наш брак не распался, а книга, несомненно,
стала лучше);
􀂈 своей дочери за поиски программистских "приколов" в Интернете для
эпиграфов к главам и за время, потраченное на прочтение моего труда;
􀂈 студентам, которые обучались и обучаются у меня языку С++ и постоянно
"подкидывают" все новые программистские головоломки;
􀂈 своей собаке, которая отрывала меня от компьютера и выводила погулять.
Глава 1
Общие принципы процедурного
программирования
Вчера написал программу. Работает
нормально и не глючит… Может быть,
я что-то не так делаю?
1.1. О современном программировании
в целом
Время диктует новые требования к создаваемому программному продукту.
А если программист не учитывает изменение условий, то созданный им про-
дукт становится неконкурентоспособным.
1.1.1. Историческая справка
Чтобы убедить начинающего программиста в том, что современные условия
требуют от него знаний и умений, далеко выходящих за рамки освоения лю-
бого языка программирования, в табл. 1.1 приведена сравнительная характе-
ристика той ситуации, что была на заре программирования и имеется в на-
стоящее время.
Таблица 1.1. Эволюция отношения программиста к создаваемой программе
Давным-давно Сейчас
Компьютер был предметом роскоши
(являлся редкостью и стоил очень доро-
го), поэтому его ресурсы ценились го-
раздо дороже труда программиста
Компьютер занял место в ряду бытовых
приборов, а оплата труда программиста
составляет большую часть стоимости
программного продукта
Возможности компьютера были скром-
ными, программы — относительно не-
большими, узкоспециализированными
Возможности компьютера сказочно вы-
росли (и продолжают расти), программы
стали универсальнее
8 Глава 1
Таблица 1.1 (окончание)
Давным-давно Сейчас
С программой работал в большинстве
случаев только сам автор, поэтому он
текст программы писал для себя, как
правило, воздерживаясь от документи-
рования и игнорируя структуру про-
граммы.
А в результате модифицировать старую
программу было сложнее, чем написать
новую, работа же над проектом в ко-
манде была практически невозможна
Сформированы правила хорошего стиля
создания программных продуктов.
Проекты становятся большими и слож-
ными, поэтому необходимыми требова-
ниями являются структурирование тек-
ста и документирование.
Все меньше требуется одноразовых
программ, поэтому писать их прихо-
дится с учетом будущих модификаций
и возможности постороннего сопровож-
дения.
Прошли времена программистов-
одиночек, обычным требованием
при приеме на работу является
умение корректно и эффективно
взаимодействовать с другими участ-
никами проекта
Пользователь к работе с программой не
допускался (заказчик приносил исход-
ные данные и забирал результат), по-
этому на интерфейс программист вре-
мени не тратил
Главным действующим лицом при рабо-
те с большинством программ стал поль-
зователь, поэтому появился преслову-
тый термин "интуитивно понятный
пользовательский интерфейс"
1.1.2. Этапы создания
программного продукта
Может быть, сегодня и существуют еще программисты, которые, получив
задачу, сразу же приступают к кодированию, но на работу в серьезной фирме
они вряд ли могут рассчитывать. Разработка хорошей программы происходит
в соответствии с жизненным циклом программного обеспечения. Поэтому
даже начинающему программисту неплохо бы представлять себе, что его
ожидает, и сразу же привыкать к правилам хорошего тона, потому что, толь-
ко освоив все понятия, связанные с разработкой программного обеспечения,
можно перейти с уровня простого кодировщика на уровень системного ана-
литика или менеджера проекта. Приведенная иллюстрация (рис. 1.1) не учи-
тывает итеративности процесса, но содержит все основные рекомендуемые
этапы разработки программного продукта.
Общие принципы процедурного программирования 9
Рис. 1.1
1.1.3. Памятка программисту
Причины, по которым стоит уделять особое внимание структуре текста про-
граммы:
􀂈 каким бы образом ни велась разработка (по правилам или вопреки оным),
результатом является программный продукт, стоимость которого склады-
вается из стоимости ресурсов компьютера и оплаты труда программиста
(рис. 1.2);
СЛ Е ДСТ ВИЕ
Чем хуже организованы этапы разработки и чем хуже структурирован текст,
тем больше времени затрачивает программист, увеличивая стоимость про-
граммы;
10 Глава 1
Рис. 1.2
􀂈 в условиях конкуренции программист должен как можно быстрее полу-
чить конечный продукт (всегда есть вероятность того, что пока вы будете
создавать нечто сверхэффективное, другой программист предложит ва-
шему заказчику не такую супер, но довольно сносно решающую задачу
программу);
СЛ Е ДСТ ВИЕ
Чтобы минимизировать общее время разработки, программист должен хорошо
структурировать текст программы и документировать каждый этап разработки.
􀂈 если текст будет хорошо структурирован, разработанные фрагменты
можно легко использовать при решении других аналогичных задач;
􀂈 не стоит ожидать от заказчика грамотно сформулированного технического
задания на программный продукт (таких заказчиков не бывает). Обычно
заказчик лишь смутно представляет себе, чего он хочет, поэтому, скорее
всего, вам придется не раз менять структуру вашей программы, пока, на-
конец, сами не сформируете себе техническое задание на программный
продукт и не объясните вашему заказчику, чего он хочет;
􀂈 даже когда вы получите деньги за свою работу, не обольщайтесь тем, что
удалось создать нечто вечное (чудес не бывает). Скорее всего, вам еще
долго придется это произведение сопровождать (т. е. доделывать и пере-
делывать). Чем лучше структурирована и документирована программа,
тем меньше усилий потребует от вас этот этап;
􀂈 очень плохо действует на заказчика синий экран, возникающий во время
демонстрации вашей программы, поэтому в структуру программы сразу
же следует заложить обработку нештатных ситуаций.
Кроме того, необходимо учитывать интересы заказчика, который обычно
считает себя профессионалом и предполагает, что для управления программой
достаточно одной кнопки, при нажатии на которую программа сама выпол-
Общие принципы процедурного программирования 11
нит все требуемые действия. Если же вам удается убедить его в том, что од-
ной кнопкой никак не обойтись, то в ваших же интересах создать для взаи-
модействия пользователя с программой предельно интуитивно понятный ин-
терфейс.
1.1.4. Критерии хорошего программного продукта
Подводя итог, можно сформулировать критерии хорошего современного
программного продукта (рис. 1.3). Как и прежде, существенную роль играют
минимизация времени выполнения и рациональное использование памяти
(особенно при программировании для встроенных применений). Современ-
ные компиляторы самостоятельно умеют оптимизировать многие языковые
конструкции, в то время как исправлять структуру вашей программы они не
могут, вот поэтому требования к структурному построению текста програм-
мы в большинстве случаев становятся определяющими.
Рис. 1.3
1.2. Структура программы
Если мне еще не удалось убедить вас в важности создания хорошо структу-
рированного текста программы, то приведу цитату гуру программирования
Б. Страуструпа: "Вы можете написать небольшую программу (скажем, 1000 строк),
12 Глава 1
используя грубую силу и нарушая все правила хорошего стиля. Для про-
граммы большего размера вы не сможете этого сделать. Если структура про-
граммы, состоящей из 100 000 строк, плоха, вы обнаружите, что новые
ошибки появляются с той же скоростью, с которой исправляются старые.
Язык программирования С++ разрабатывался таким образом, чтобы предос-
тавить возможность рационально структурировать большие программы, и чтобы
один человек мог работать с большим объемом кода".
Под структурным программированием понимается метод программирования,
обеспечивающий создание текста программы, структура которого:
􀂈 отражает структуру решаемой задачи (логическую структуру);
􀂈 хорошо читаема не только его создателем, но также и другими програм-
мистами.
Так как структурный подход охватывает все стадии разработки проекта, пред-
полагается, что квалифицированный программист, прежде чем приступать соб-
ственно к написанию текста программы, продумывает логическую структуру
решаемой задачи (сверху вниз). Для этого применяется подход (интуитивно
понятный), при котором исходная задача делится на несколько крупных подза-
дач, каждая из которых, в свою очередь, может быть тоже разделена на подза-
дачи и т. д. (рис. 1.4). Такая процедура называется декомпозицией задачи.
Рис. 1.4
Общие принципы процедурного программирования 13
Следовательно, разрабатывая программу, следует придерживаться опреде-
ленных правил. Очевидно, что некоторые правила являются общими и не за-
висят от языка реализации, а некоторые определяются возможностями кон-
кретного языка программирования.
1.2.1. Разбиение на файлы (модульность)
и связанные с этим понятия С/С++
В принципе, весь текст программы на Си всегда можно поместить в один
файл, однако при написании хоть сколько-нибудь значительных по размеру
программ оказывается полезным сгруппировать логически связанные между
собой понятия (код и данные, соответствующие подзадачам) и хранить такие
совокупности в отдельных файлах.
Разбиение программы на файлы помогает:
􀂈 улучшить структуру (программисту удобнее ориентироваться в собствен-
ной или чужой программе при внесении изменений);
􀂈 уменьшить общее время получения нового загрузочного модуля при вне-
сении изменений только в один из исходных файлов.
Следует отметить, что само физическое разбиение программы на модули
реализуется довольно просто, а серьезная проблема при этом состоит в том,
что между модулями неизбежно возникают зависимости (пример внешних
зависимостей см. на рис 1.6), поэтому следует обеспечить безопасное, удоб-
ное и эффективное взаимодействие этих модулей.
Для обеспечения модульности С/С++ (впрочем, как и большинство совре-
менных средств разработки) предоставляет возможность компиляции каждого
файла по отдельности с последующей стыковкой полученных частей в еди-
ный загрузочный (исполняемый) модуль.
Этапы получения загрузочного модуля
Рассмотрим этапы получения загрузочного (исполняемого) файла (рис. 1.5):
1. Программист с помощью текстового редактора формирует исходный файл
на С/С++ (обычно такие файлы имеют расширение *.c или *.cpp). При этом
в современной интегрированной среде разработки (Integrated Development
Environment IDE) программисту помогает система подсказок — IntelliSense.
При разбиении программы на отдельные файлы в тексте каждого файла
разработчик должен объяснить компилятору, каким образом тот должен об-
ращаться с теми внешними понятиями (данными или функциями), которые
определены в других файлах, а используются в данном файле.
14 Глава 1
Рис. 1.5
2. Далее производится предварительная обработка текста исходного файла
программой-препроцессором (см. главу 5). Препроцессор всегда запуска-
ется автоматически перед компиляцией файла. Результат обработки пре-
процессором исходного файла называется единицей компиляции (это
окончательно сформированный текст, с которым уже может работать
компилятор).
3. Затем происходит компиляция, когда в результате синтаксического, затем
лексического анализа, а потом и собственно трансляции получается про-
межуточный формат файла, называемый объектным форматом (обычно он
имеет расширение *.obj). Для того чтобы создать его, компилятору доста-
точно знать только свойства внешних понятий (таких, как тип переменной
или прототип функции). Если программист предоставил такую информа-
цию компилятору, последний уже может сгенерировать код (последова-
тельность процессорных команд), но не может сформировать адреса
внешних (по отношению к данному файлу) переменных или адреса внеш-
них функций. При создании объектного файла компилятор "откладывает
на потом" разрешение внешних для данного исходного файла зависимостей.
4. И, наконец, производится компоновка (синонимы: редактирование связей,
линковка, сборка). Это соединение всех ранее откомпилированных частей
Общие принципы процедурного программирования 15
(не только ваших, но и кода статических библиотек *.lib) в единый испол-
няемый модуль (для Windows и DOS — обычно файл с расширением *.exe
или *.dll). На этом этапе все объектные модули необходимо обрабатывать
совместно, чтобы произвести окончательное распределение памяти и сфор-
мировать для всех команд адресные части.
5. Кроме того, компилятор и компоновщик по требованию программиста
могут в исполняемом файле добавить к коду дополнительную отладочную
информацию (такую, например, как соответствие символических имен пе-
ременных их машинным адресам). Эта информация используется про-
граммой-отладчиком и позволяет производить отладку на уровне исходно-
го текста программы.
Соответственно перечисленным этапам программисты получают:
􀂈 на этапе компиляции — синтаксические ошибки и ошибки неописанных
внешних объектов;
􀂈 на этапе компоновки — ошибки неразрешенных или неуникальных внеш-
них зависимостей.
ЗАМЕ ЧАНИЕ
С логическими ошибками программист должен бороться самостоятельно (ни
компилятор, ни компоновщик не помогут!).
Раздельная компиляция
Для того чтобы стало возможным разбиение исходного текста на отдельные
файлы, в С/С++ реализован механизм раздельной компиляции (каждый ис-
ходный файл обрабатывается компилятором независимо от других).
Но на практике обычно в каждом файле используются понятия, определен-
ные в других файлах — внешние зависимости. Например:
􀂈 код функции может находиться в одном файле, а вызов функции — со-
всем в другом;
􀂈 переменная определена в одном файле, а использовать ее нужно в другом.
Простейший пример возникновения внешних зависимостей приведен на рис. 1.6.
В примере показано, как одно и то же выражение на языке высокого уровня
в зависимости от свойств понятий, внешних по отношению к данному файлу
(в примере имеются в ввиду переменные X, Y и Z), компилятор превращает
в совершенно разные последовательности низкоуровневых команд. Очевидно,
что прежде чем использовать внешние понятия, программист должен объяс-
нить компилятору, каким образом следует с ними обращаться (описать свой-
ства X, Y и Z, чтобы он (компилятор) мог сгенерировать соответствующую
16 Глава 1
последовательность низкоуровневых команд), а компоновщик сформирует
адреса внешних переменных.
client.cpp
Описание свойств X, Y, Z
Z=X+Y; //одно и то же выражение на языке высокого уровня в
зависимости от свойств X и Y компилятор может превращать в
совершенно разные последовательности низкоуровневых команд
//если X и Y целые, компилятор должен сгенерировать
низкоуровневую команду сложения целых – add
//если X и Y плавающие, компилятор должен сгенерировать
низкоуровневую команду сложения плавающих – fadd
//если X и Y строки символов, то результатом должна быть
конкатенация строк
…
server.cpp
int X,Y,Z;
//или double X,Y,Z;
// или…
Что такое внешние зависимости (на примере внешних данных)
X, Y и Z
используются внешние
переменные
определены переменные X, Y и Z,
которые предназначены для
использования в других модулях
Рис. 1.6
Рассмотрим обязанности по разрешению внешних зависимостей:
􀂈 программист должен в тексте программы, во-первых, описать свойства всех
внешних для данного файла понятий, а во-вторых — обеспечить уникаль-
ность каждого описания (интерфейса). Если сравнивать программу с аппа-
ратной системой, то каждый файл похож на блок, подключаемый к другому
блоку с помощью разъема (правильно спроектированные разъемы на двух
стыкуемых частях должны обеспечить уникальность соединения, чтобы их
невозможно было перепутать, и вся система в целом не сгорела);
􀂈 компилятор по описанию внешних зависимостей генерирует в объектном
модуле (рис. 1.7) последовательность низкоуровневых (процессорных)
команд, а также таблицу описания входов/выходов (где указано, куда
нужно подставить адрес каждого внешнего объекта, плюс описание
свойств самого объекта, чей адрес нужно подставить). Если продолжить
аналогию с аппаратурой, то можно сказать, что компилятор формирует
отдельный блок плюс разъем для подключения данного блока к другим;
ЗАМЕ ЧАНИЕ
Сам по себе каждый отдельный блок работать не будет, их нужно стыковать;
Общие принципы процедурного программирования 17
Рис. 1.7
􀂈 компоновщик анализирует таблицы, созданные компилятором (рис. 1.7),
и ищет для каждого входа соответствующий выход (уникальный). Нашел —
"соединяет проводами" (подставляет адрес внешнего объекта), не нашел —
выдает ошибку.
ЗАМЕ ЧАНИЕ 1
На самом деле каждый файл может быть одновременно и клиентом, и серве-
ром, поэтому обычно в объектном модуле формируются две таблицы: одна для
импортируемых понятий, другая — для экспортируемых.
18 Глава 1
ЗАМЕ ЧАНИЕ 2
Термины экспорт/импорт в данном контексте не имеют никакого отношения
к динамически подключаемым библиотекам (*.dll).
Понятие проекта
Программисты называют проектом совокупность файлов с исходными тек-
стами и служебных файлов, в которых содержится дополнительная инфор-
мация для средств трансляции.
Процесс компиляции каждого исходного файла может иметь свои особенно-
сти. Это означает, что в параметрах командной строки при компиляции каж-
дого файла как компилятору, так и препроцессору можно указать разные оп-
ции (ключи).
В параметрах командной строки компоновщику нужно указать, из каких объ-
ектных модулей и объектных библиотек собирать исполняемый файл, а так-
же можно перечислить особенности сборки исполняемого файла.
Если бы мы работали из командной строки, то все эти особенности пришлось
бы указывать в опциях командной строки вручную или писать командные
(*.bat) файлы. Но в настоящее время большую часть такого рода работы вы-
полняет интегрированная среда разработки (IDE). Все перечисленные (и мно-
гие другие) параметры, задающие свойства исполняемого модуля, объединя-
ются в опциях проекта и сохраняются в служебных файлах. А встроенные
в некоторые IDE средства автоматизации (т. н. Wizard) облегчают програм-
мисту работу с интегрированной средой тем, что предоставляют разработчи-
ку заготовку (template) программы требуемого типа. При этом большая часть
опций (а может быть, даже и все) генерируется автоматически.
1.2.2. Функциональная декомпозиция
и связанные с ней понятия
Функция С/С++ представляет собой фрагмент кода, на который можно пере-
дать управление (вызвать) из любого места программы. По окончании функ-
ции выполнение будет продолжено за точкой вызова (см. подробнее главу 8).
Функции позволяют использовать один и тот же код для работы с разными
наборами данных (с этой точки зрения можно рассматривать функции как
нижний уровень абстракции программирования). Они являются краеуголь-
ным камнем процедурного программирования. Функциональная декомпози-
ция — это представление программы в виде иерархии вложенных вызовов
функций. Посредством использования функций решаются две задачи:
􀂈 улучшается структура текста программы;
􀂈 программисту предоставляется средство, позволяющее не дублировать код.
Общие принципы процедурного программирования 19
Продолжая разбиение программы на все более мелкие части (см. рис. 1.4),
мы стремимся к тому, чтобы каждая такая часть содержала какое-либо за-
конченное действие. Физически это выражается в разбиении исходных фай-
лов на более мелкие единицы — функции. При процедурном подходе про-
грамму можно представить в виде вложенных (иногда рекурсивных) вызовов
функций (рис. 1.8).
Рис. 1.8
Обычно программист помещает несколько функций в один файл, объединяя
их по какому-то логическому принципу, при этом код вызываемой функции
может находиться в одном файле, а вызов — в другом (рис. 1.9). В этом слу-
чае программисту необходимо объяснить компилятору, каким образом тот
должен формировать вызов внешней по отношению к данному модулю
функции, оставив компоновщику обязанность подставить адрес точки вызова
(куда передать управление).
20 Глава 1
Рис. 1.9
Функции С/С++ вообще
Функция С/С++ — это фрагмент кода, оформленный определенным образом
(в частности, ограниченный фигурными скобками) и выполняющий некото-
рое законченное действие. На рис. 1.10 с помощью псевдокода показано, как
следует оформлять функцию на С/С++ и что может быть в теле функции.
тип_возвращаемого_значения имя_функции(параметры)
{
1) локальные для этой функции данные
2) инструкции (код), возможно задающие действия над:
а) переданными в функцию параметрами,
б) локальными для данной функции данными,
в) внешними для данной функции данными
3) вызовы других функций
}
Начало
Тело функции
Конец
Что
может
быть в
теле
функции
Этот псевдокод показывает, как выглядит функция С/С++
Заголовок (описание свойств)
Рис. 1.10
ВА Ж Н О!
Программист посредством фигурных скобок дает синтаксическое указание компи-
лятору о начале и завершении функции. Компилятор же подставляет вместо откры-
вающей и закрывающей фигурных скобок низкоуровневые команды, обеспечиваю-
щие корректный вызов функции и возврат управления вызывающему коду.
Общие принципы процедурного программирования 21
После того как функция написана (и отлажена), программист может забыть
о том, как она устроена внутри, а посторонний пользователь и вовсе не дол-
жен задумываться о внутренней начинке, ему надо знать только назначение и
интерфейс вызова этой функции (имя функции, типы параметров). Такую
функцию можно рассматривать как новую мощную команду, выполняющую
действия над заданными программистом значениями.
Функция main в частности
Начало специальной функции с предопределенным именем main() является
точкой входа для программ на С/С++. Хотя наличие этой функции обяза-
тельно, она не генерируется компилятором автоматически — программист
должен обеспечить ее наличие в тексте программы явно!
Минимальной программой на С/С++ является:
int main() {}
Так как начало функции main() является точкой входа программы, то у нее
есть особенности:
􀂈 каждая программа на С/С++ обязательно должна содержать функцию с име-
нем main;
Подумайте, кто выдаст ошибку, если программист забыл определить
функцию с таким именем?
􀂈 имя main может быть только у единственной функции в вашей программе;
Подумайте, кто выдаст ошибку, если программист определил несколько
функций с таким именем?
􀂈 открывающая скобка функции main() является началом вашей программы,
закрывающая — выходом (во всяком случае, корректным);
􀂈 функция main() на самом деле является не абсолютной, а относительной
точкой входа, т. к. перед вызовом этой функции (в отличие от всех других)
компилятор генерирует невидимый программисту стартовый блок кода
(пролог), а после завершения — эпилог всей программы (рис. 1.11);
􀂈 компилятор понимает несколько форм функции main():
• int main() //не принимает параметров
• int main(int argc[, char *argv[ ] ] [, char *envp[ ] ])
//см. разд. 8.2.3
• int wmain() //поддержка UNICODE, специфика Microsoft
• int wmain(int argc[, wchar_t *argv[ ] ] [, wchar_t *envp[ ] ])
22 Глава 1
Рис. 1.11
􀂈 хорошим стилем является возврат функцией main() системе кода завер-
шения (нулевое значение обозначает нормальное завершение программы).
Альтернативный (нерекомендуемый) путь — определить функцию с клю-
чевым словом void (см. разд. 8.1.1):
void main() {...}
􀂈 несколько ограничений, относящихся к функции main() (но не касающие-
ся всех остальных функций):
• не должна быть перегружена программистом, т. е. можно использовать
только приведенные ранее формы, а свои придумывать нельзя
(см. разд. 8.5);
• не может быть объявлена с ключевым словом inline (см. разд. 8.1.4);
• не может быть объявлена с ключевым словом static (см. разд. 3.7.1);
• нельзя (без дополнительных ухищрений) рекурсивно вызвать эту
функцию.
Завершение программы
Если точка входа только одна, то возможностей завершения программы
в С/С++ (рис. 1.12) имеется несколько:
􀂈 по закрывающей скобке функции main();
􀂈 выполнение инструкции return из функции main();
􀂈 вызов библиотечной функции exit() в любом месте программы;
􀂈 вызов библиотечной функции abort() в любом месте программы.
Общие принципы процедурного программирования 23
Рис. 1.12
Первые три способа позволяют завершить программу корректно. Функция
abort() завершает программу аварийно.
ЗАМЕ ЧАНИЕ 1
Несмотря на то, что способов корректного завершения несколько, вы, тем не
менее, можете предусмотреть и какие-то конкретные действия, которые гаран-
тированно будут выполняться при корректном завершении программы. Для это-
го следует оформить эти действия как самостоятельную функцию и с помощью
библиотечной функции atexit() задать ее вызов (в случае корректного за-
вершения программы) в эпилоге, предоставляемом стандартной библиотекой.
ЗАМЕ ЧАНИЕ 2
Вы можете предусмотреть не одно, а несколько последовательно выполняе-
мых завершающих действий, создав стек вызываемых функций посредством
нескольких вызовов библиотечной функции atexit() (листинг 1.1). Эти функ-
ции будут вызываться при корректном завершении программы в обратном по-
рядке (последняя указанная будет вызвана первой).
24 Глава 1
Листинг 1.1. Дополнительные действия при корректном завершении программы
#include <cstdlib>
void fn1( void );
void fn2( void );
int main( void ) {
atexit( fn1 );
...
atexit( fn2 );
} //в эпилоге будут вызваны функция fn2, а затем fn1
Аварийность выхода по abort() заключается в том, что функция abort() вы-
зывает немедленное прекращение выполнения программы с кодом заверше-
ния 3, при этом:
􀂈 не закрываются открытые или временные файлы;
􀂈 не очищаются буферы потоков ввода/вывода;
􀂈 не вызываются деструкторы для глобальных и статических объектов;
􀂈 не выполняются дополнительные специализированные действия, преду-
смотренные программистом посредством atexit().
ЗАМЕ ЧАНИЕ
Если функция abort() вызывается в консольном Win32-приложении, в Debug-
версии проекта появляется окно сообщений (Message Box) с диагностикой об
аварийном завершении приложения. Программисту предоставляются три воз-
можности отреагировать на ситуацию: прервать, повторить, пропустить.
1.2.3. Блоки кода
Продолжим рассмотрение процесса декомпозиции задачи (см. рис. 1.4).
В каждой функции, в свою очередь, можно выделить логически обособлен-
ные фрагменты (блоки) кода. Такой фрагмент, заключенный в фигурные
скобки, называется составной инструкцией.
На рис. 1.13 с помощью псевдокода показано, как следует оформлять блок
кода на С/С++ и что может быть в теле составной инструкции. Приведенный
в качестве примера блок кода может выполняться только при определенном
условии. Для того чтобы сообщить об этом компилятору, программист дол-
жен заключить такую последовательность в фигурные скобки.
Внутри каждого такого блока могут быть определены элементы данных, ло-
кальные для этого блока (используемые только в пределах текущего блока)
Общие принципы процедурного программирования 25
(см. разд. 3.7 и 3.8), и инструкции, выполняющие действия над локальными
данными и, возможно, над данными, внешними для текущего блока.
Рис. 1.13
ЗАМЕ ЧАНИЕ 1
Вложенность блоков достаточно велика и определяется свойствами компиля-
тора.
Для того чтобы улучшить визуальное восприятие текста программы, реко-
мендуется смещать текст каждого вложенного блока на несколько позиций
вправо. Именно так поступает текстовый редактор в современных интегри-
рованных средах разработки (если только вы ему в этом не препятствуете):
{ // начало блока
…
{ // вложенный блок
…
{ // еще вложенный блок, хорошо видно, где начало
…
} // и где окончание каждого блока
…
}
…
}
26 Глава 1
Таким образом, с помощью оформления относительно независимых частей
программы в виде функций и выделения логических блоков внутри функций,
создается хорошо читаемая иерархическая структура программы.
1.2.4. Оформление текста программы.
Комментарии и отступы
Давным-давно стиль оформления текста программы зависел исключительно
от желания и аккуратности программиста. Сейчас оформление кода (code
style) является одним из основных требований и в большинстве организаций
является обязательным. В частности, удачно подобранный и грамотно напи-
санный набор комментариев является существенной частью хорошей про-
граммы.
ЗАМЕ ЧАНИЕ 1
Написание правильных комментариев может оказаться не менее сложной и тру-
доемкой задачей, чем написание самой программы. Полезно начинать писать
программу с комментариев, где вы естественным языком описываете, что
должна делать комментируемая часть кода.
ЗАМЕ ЧАНИЕ 2
Комментарии пишутся для программиста, компилятору они не нужны, поэтому
препроцессор исключает комментарии из того окончательно сформированного
текста, с которым работает компилятор.
ЗАМЕ ЧАНИЕ 3
В современных интегрированных средах разработки текстовый редактор выде-
ляет закомментированные участки текста другим цветом.
В С/С++ имеются два вида комментариев:
􀂈 // — это комментарий первого вида (в стиле С++). Препроцессор исклю-
чит весь текст, следующий за // до конца строки;
􀂈 /* */ — а это комментарий второго вида (в стиле стандартного Си). Пре-
процессор исключит весь текст, находящийся между /* … */.
ЗАМЕ ЧАНИЕ
Комментарии второго вида не могут быть вложенными, но в них можно вложить
комментарий первого вида!
Общие принципы процедурного программирования 27
Пример 1.
/*
/* эта открывающая скобка будет проигнорирована
*/ первая встреченная закрывающая скобка будет означать
конец комментария второго вида
*/а этот фрагмент уже будет отправлен компилятору и вызовет
ошибку
Пример 2.
/*
// OK! Здесь никаких ошибок не произойдет!
*/
Несколько рекомендаций:
􀂈 комментарии должны быть! — это часть документирования программы;
􀂈 плохой комментарий хуже, чем его отсутствие! (Б. Страуструп);
􀂈 не стоит комментировать то, что и так очевидно;
􀂈 обязательно комментировать понятия, которые используются разными
единицами трансляции (тем более, если ими может воспользоваться дру-
гой программист);
􀂈 всегда полезно комментировать непереносимый или неочевидный код
(хотя такового быть не должно!);
􀂈 хорошим тоном считается начинать с комментария каждый исходный
файл и определение каждой функции;
􀂈 использование комментариев позволяет на время исключать (закрывать от
компилятора) отдельные части исходного текста программы, и этим весь-
ма широко пользуются при отладке.
ЗАМЕ ЧАНИЕ
Комментарии к фрагментам, приводимые в данной книге, не всегда являются
хорошим примером того, как следует комментировать рабочую программу, по-
скольку они всего лишь преследуют цель обучения и предназначены для начи-
нающих изучение программирования на С/С++.
Глава 2
Базовые понятия С/С++
2.1. Ключевые слова
Ключевые слова — это слова, зарезервированные для использования только
компилятором С/С++. Программист не может использовать ключевые слова
языка для именования своих объектов1 (использовать их позволено только
по прямому назначению).
Примеры ключевых слов:
if, int, static…
ЗАМЕ ЧАНИЕ
В современных интегрированных средах разработки редактор текста помогает
программисту отличать ключевые слова, выделяя их другим цветом.
2.2. Идентификаторы (имена)
Обычно программист присваивает объектам своей программы имена (иден-
тификаторы).
Специфика:
􀂈 идентификатор С++ состоит из последовательности букв и цифр;
􀂈 первым символом должна быть буква;
􀂈 символ подчеркивания "_" приравнивается к букве. Но имена, начинаю-
щиеся с символа "_", обычно зарезервированы для специфических нужд
1 Здесь и далее термин объект используется для обозначения любого низкоуровнево-
го понятия С/С++ и не имеет отношения к объектно-ориентированному программи-
рованию.
30 Глава 2
среды или используются стандартной библиотекой, поэтому такие имена
не стоит использовать в прикладных программах;
􀂈 компилятор С/С++ различает символы в верхнем и нижнем регистре, по-
этому идентификаторы foo и Foo оказываются для компилятора двумя со-
вершенно разными именами.
РЕ К О МЕ Н Д А Ц И Я
Не слишком разумно выбирать имена, отличающиеся только регистром. Это
может привести к трудно выявляемым ошибкам;
􀂈 для некоторых компиляторов С++ есть ограничение на количество симво-
лов в имени (в языке Си компилятор учитывает только 31 символ);
􀂈 в качестве имен нельзя использовать ключевые слова языка С/С++;
􀂈 чем шире область использования, тем осмысленнее должны быть имена;
􀂈 согласно Венгерской нотации рекомендуется в имени переменной указы-
вать ее тип.
Примеры правильных имен:
Hello var1 this_is_a_very_long_name _u_name
Примеры последовательностей символов, которые нельзя использовать в ка-
честве идентификаторов:
123 a fool your.func .func int
2.3. Понятия lvalue и rvalue
Термин lvalue (от left value) имеет следующий смысл: "нечто, что может
быть использовано слева от знака равенства".
В простейшем случае:
x=1; //переменная x является lvalue
А в общем случае lvalue может быть любым выражением, результат которо-
го ассоциируется компилятором с выделенной областью памяти.
Lvalue бывают двух типов:
􀂈 модифицируемые (которым можно присвоить значение сколько угодно раз);
􀂈 немодифицируемые (значение присваивается один раз при инициализации).
Что может выступать в качестве lvalue:
􀂈 в большинстве случаев слева от знака равенства находится имя (иденти-
фикатор) переменной:
x=выражение; //OK
x=7; //OK
Базовые понятия С/С++ 31
//но!
x+y = выражение; //ошибка: слева не lvalue
7=выражение; //ошибка: слева не lvalue
􀂈 иногда слева от знака равенства используются довольно сложные конст-
рукции типа:
*p[x+y] = выражение; //если результату выражения слева от знака
равенства соответствует выделенная
компилятором память, то выражение слева
является lvalue
ЗАМЕ ЧАНИЕ
Таким образом, сложная конструкция всего лишь объясняет компилятору, как
ему следует вычислять адрес в памяти, куда должен быть записан вычислен-
ный результат;
􀂈 результат выражения справа от знака равенства, в свою очередь, тоже мо-
жет быть lvalue для следующего выражения, например:
x=y=выражение
ЗАМЕ ЧАНИЕ
Термин rvalue был введен для того, чтобы как-то назвать все то, что, в свою
очередь, может находиться справа от знака равенства. При этом любое
lvalue всегда может находиться справа от знака равенства, обратное спра-
ведливо далеко не всегда!
2.4. Операторы
В русскоязычных переводах используются разные названия для обозначения
одних и тех же понятий. В данной книге русское "оператор" соответствует
английскому "operator", а русскому "инструкция" соответствует английское
"statement".
С операторами связаны следующие понятия:
􀂈 количество операндов. Оператор может совершать действие над:
• одним операндом (унарный оператор);
• двумя операндами (бинарный оператор);
• тремя операндами (тернарный оператор);
􀂈 приоритет операторов (или, как говорили в школе, порядок действий).
Если в выражении участвуют несколько операторов, компилятор должен
точно знать, в каком порядке требуется выполнять (вычислять) отдельные
32 Глава 2
части выражения. Такой предопределенный порядок называется приори-
тетом операторов:
a+b+c — эквивалентно (a+b)+c;
a+b*c — эквивалентно a+(b*c).
Для изменения порядка вычисления можно использовать скобки:
a+b*c — эквивалентно: a+(b*c);
(a+b)*c — явно изменили порядок вычислений;
􀂈 ассоциативность операторов. Если в выражении содержатся операторы
с одинаковым приоритетом (без использования скобок), вычисление произво-
дится согласно правилам ассоциативности справа налево или слева направо.
ПР А В И Л О
Унарные операторы и операторы присваивания правоассоциативны (т. е. ком-
пилятор организует порядок выполнения действий по правилу "справа налево"),
а все остальные левоассоциативны. Это означает:
a=b=c — эквивалентно: a=(b=c)
a+b+c — эквивалентно: (a+b)+c
Для изменения порядка вычисления также можно использовать скобки:
a=b=c — эквивалентно: a=(b=c);
(a=b)=c — явно изменили порядок вычислений;
􀂈 порядок синтаксического разбора выражения компилятором. Это прави-
ла, по которым действует компилятор при синтаксическом разборе выра-
жений, где возможна неоднозначная трактовка выражения (см. пример 4
разд. 2.4.1).
В табл. 2.1 приведены операторы С++ (большинство операторов также име-
ют место в языке Си). В каждом блоке таблицы (блоки разделены двойной
горизонтальной линией и расположены по убыванию приоритета) представ-
лены операторы с одинаковым приоритетом.
Таблица 2.1. Операторы С++
Оператор Название Синтаксис использования Ассоциа-
тивность
:: Разрешение облас-
ти видимости
::имя – глобально
имя_пространства::имя –
посредством имени
пространства имен
имя_класса::имя_члена_
класса – посредством
имени класса
Нет
Базовые понятия С/С++ 33
Таблица 2.1 (продолжение)
Оператор Название Синтаксис использования Ассоциа-
тивность
[ ] Доступ к элементу
массива по индексу
Идентификатор[выражение]
или
выражение[идентификатор]
( ) Вызов функции Имя_функции(список_
параметров)
( ) Конструирование
значения
Тип(список_параметров)
Слева
направо
. Обращение к члену
структуры или клас-
са посредством
объекта или ссылки
Объект.член_класса
Ссылка_на_объект.
Член_класса
–> Обращение к члену
структуры или клас-
са посредством ука-
зателя на объект
Указатель-> член_класса
Слева
направо
++ Постфиксный ин-
кремент
lvalue++
–– Постфиксный дек-
ремент
lvalue--
Нет
new Динамическое соз-
дание объекта
new type — создать в куче
объект типа type
delete Уничтожить объект
(освободить память)
delete указатель_на_объект
delete[ ] Уничтожить массив
объектов
delete[] указатель_
на_массив_объектов
++ Префиксный
инкремент
++lvalue
–– Префиксный
декремент
--lvalue
* Разыменование * выражение
& Получение адреса
объекта
&lvalue
+ Унарный плюс + выражение
– Унарный минус
(арифметическое
отрицание)
- выражение
Нет
34 Глава 2
Таблица 2.1 (продолжение)
Оператор Название Синтаксис использования Ассоциа-
тивность
! Логическое отрица-
ние (not)
! выражение
~ Поразрядная ин-
версия
~ выражение
sizeof Размер (в байтах) sizeof(объект) — размер
объекта
sizeof (type) — размер типа
typeid() Идентификация
типа
typeid (type) — идентифи-
кация типа времени выполне-
ния
Нет
(type) Приведение (преоб-
разование типа)
(type) выражение — приве-
дение типа выражения к типу,
указанному в скобках (старый
стиль)
Справа
налево
const_cast Константное преоб-
разование типа
const_cast <type>
(выражение)
dynamic_
cast
Преобразование
типа с проверкой во
время выполнения
dynamic_cast <type>
(выражение)
reinterpret_
cast
Преобразование
типа без проверки
во время компиляции
reinterpret_cast <type>
(выражение)
static_cast Преобразование
типа с проверкой во
время компиляции
static_cast <type>
(выражение)
Нет
.* Выбор члена класса
посредством объекта
объект.*указатель_на_
член_класса
–>* Выбор члена класса
посредством указа-
теля на объект
указатель_на_объект ->*
указатель_на_член_класса
Слева
направо
* Умножение выражение * выражение
/ Деление выражение / выражение
% Остаток от деления
(деление по модулю)
выражение % выражение
Слева
направо
+ Сложение выражение + выражение
– Вычитание выражение – выражение
Слева
направо
Базовые понятия С/С++ 35
Таблица 2.1 (окончание)
Оператор Название Синтаксис использования Ассоциа-
тивность
<< Сдвиг влево выражение << выражение
>> Сдвиг вправо выражение >> выражение
Слева
направо
< Меньше выражение < выражение
> Больше выражение > выражение
<= Меньше или равно выражение <= выражение
>= Больше или равно выражение >= выражение
Слева
направо
== Равно выражение == выражение
!= Не равно выражение != выражение
Слева
направо
& Побитовое И (and) выражение & выражение Слева
направо
^ Побитовое исклю-
чающее ИЛИ (or)
выражение ^ выражение Слева
направо
| Побитовое ИЛИ (or) выражение | выражение Слева
направо
&& Логическое И (and) выражение && выражение Слева
направо
|| Логическое ИЛИ (or) выражение || выражение Слева
направо
e1?e2:e3 Условное выражение ? выражение :
выражение
Справа
налево
= Простое
присваивание
lvalue = выражение
*=
/=
%=
+=
–=
<<=
>>=
&=
|=
^=
Совмещенное
присваивание
lvalue *= выражение
lvalue /= выражение
lvalue %= выражение
lvalue += выражение
lvalue -= выражение
lvalue <<= выражение
lvalue >>= выражение
lvalue &= выражение
lvalue |= выражение
lvalue ^= выражение
Справа
налево
throw Генерация исклю-
чения
throw выражение
, Запятая (последо-
вательность)
выражение , выражение Слева
направо
36 Глава 2
РЕ К О МЕ Н Д А Ц И Я
Если вы не уверены в порядке выполнения операторов, пользуйтесь скобками.
Обычно скобки лишними не бывают.
2.4.1. Арифметические операторы
Язык С/С++ включает стандартный набор арифметических операторов:
􀂈 сложение (+);
􀂈 вычитание (–);
􀂈 умножение (*);
􀂈 деление (/).
ЗАМЕ ЧАНИЕ
Некоторые особенности выполнения действий с целыми числами в ограничен-
ной разрядной сетке рассмотрены в приложении (см. разд. П1.4—П1.10).
Кроме того, в языке С/С++ имеются операторы:
􀂈 остаток от целочисленного деления (%),
􀂈 оператор увеличения на единицу (++);
􀂈 оператор уменьшения на единицу (--).
Остаток от целочисленного деления — оператор %
В примере демонстрируется разница выполнения операторов целочисленного
деления и получения остатка от деления нацело:
int x=5, y=2,z;
z = x / y; //частное от целочисленного деления (z=2)
z = x % y; //остаток от деления нацело (z=1)
Операторы инкремента ++ и декремента --
Оператор инкремента (++) увеличения переменной на 1 удобно использовать
в следующих случаях:
􀂈 вместо записей типа x=x+1 — запись типа x++;
􀂈 вместо записей типа x+=1 — запись типа ++x.
Аналогично выглядит использование оператора декремента (--).
Специфика операторов ++ и -- заключается в том, что они могут быть как
префиксными (инкремент или декремент происходит до вычисления выра-
жения), так и постфиксными (инкремент или декремент происходит после
Базовые понятия С/С++ 37
вычисления выражения). В предыдущем примере результат обоих выраже-
ний будет одинаковым, т. к. выражение очень простое.
Рассмотрим примеры использования инкремента в более сложных выра-
жениях.
Пример 1.
Постфиксный инкремент:
x=1;
y=x++; //сначала вычисляется выражение, т. е. переменной y
присваивается текущее значение переменной x.
В результате y=1, а после вычисления выражения
значение переменной x увеличивается на 1.
Таким образом, x=2;
Пример 2.
Префиксный инкремент:
x=1;
y=++x; //сначала модифицируется значение x (x=2), а потом
переменной y присваивается измененное значение x (y=2);
Пример 3.
Результатом префиксного инкремента (++x) является lvalue, а постфиксного
(x++) — не lvalue, поэтому:
x=1;
// (x++)++; //ошибка, т. к. выражение x++ не является lvalue
(++x)++; //правильно, т. к. результат ++x – lvalue
++x +=y; //тоже корректно с точки зрения компилятора, но писать
такое выражение вряд ли имеет смысл. Гораздо понятнее
выглядит x += y+1;
Пример 4.
Порядок синтаксического разбора выражения
z=x+++y; //программист мог иметь в виду (x++)+y или x+(++y), а у
компилятора существуют правила, согласно которым он
должен интерпретировать любое выражение однозначно.
ПР А В И Л О
Анализируя выражение, компилятор пытается выделить самое длинное кор-
ректное выражение.
38 Глава 2
В данном примере он будет поступать следующим образом:
x+ — корректно;
x++ — тоже корректно;
поэтому такое выражение будет интерпретироваться: z=(x++)+y.
Исходя из вышеприведенного правила, попробуйте проинтерпретировать
следующее выражение:
z=x+++++y.
РЕ К О МЕ Н Д А Ц И Я
Не используйте операторы инкремента/декремента в сложных выражениях, т. к.
разные компиляторы могут интерпретировать такие выражения по-разному
и даже один и тот же компилятор может в DEBUG- и RELEASE-версиях генери-
ровать для таких выражений разный код.
Например, два компилятора (VC.net и BorlandC 3.1) вычисляют приведенный
ниже пример по-разному:
􀂈 x=1; y= (++x) * (++x); // VC: y=9;
􀂈 x=1; y= (++x) * (++x); // BC: y=6;
2.4.2. Операторы присваивания
Простое присваивание
В простейшем случае для компилятора оператор присваивания означает, что
значение, полученное в результате вычисления выражения справа от знака
равенства, нужно скопировать в область памяти, на которую ссылается
lvalue слева от знака равенства:
x=выражение; //компилятор вычислит выражение и сгенерирует
mov [x],результат
При этом очевидно, что слева от знака равенства должно быть модифици-
руемое lvalue. Этот оператор только на первый взгляд кажется самым про-
стым (в языке Си он таковым и является), но на самом деле для С++ присваи-
вание — это дело серьезное и нетривиальное.
Сейчас рассмотрим только самые простые применения оператора присваива-
ния, когда смысл выполняемого действия предельно ясен:
a=b=c=d; //эквивалентно a=(b=(c=d)), т. к. оператор
присваивания правоассоциативен. Если хотим изменить
порядок вычислений, можно использовать скобки
Базовые понятия С/С++ 39
((a=b)=c)=d; //1. a=b
2. a=c
3. a=d
В каком порядке компилятор будет вычислять следующее выражение:
(a=b)=c=d;
Совмещенные операторы присваивания
Язык С/С++ предоставляет большое количество операторов, которые совме-
щают присваивание с другой операцией (см. табл. 2.1).
Рассмотрим некоторые примеры.
Пример 1.
x+=выражение эквивалентно x=x+выражение.
Следует иметь в виду, что такая сокращенная запись не даст выигрыша в эф-
фективности, т. к. большинство компиляторов просто сгенерируют в обоих
случаях одинаковый низкоуровневый код.
a=1;
a+=3; //эквивалентно a=a+3. В результате a=4
Пример 2.
Совмещенные операторы присваивания правоассоциативны и приоритет всех
совмещенных операторов присваивания одинаков:
a+=b+=c; //эквивалентно a+=(b+=c);
(a+=b)+=c; //для изменения порядка вычислений пользуйтесь скобками
В каком порядке компилятор будет вычислять следующее выражение:
a*=b+=c;
ЗАМЕ ЧАНИЕ
Оператор типа "+=" является отдельной лексемой (токеном) языка, поэтому ни-
какие разделители не допускаются, а выражение a+ =b; вызовет ошибку ком-
пилятора.
2.4.3. Побитовые операторы
Побитовые операторы (рис. 2.1) позволяют производить действия над от-
дельными разрядами многобитовых операндов (установка отдельных битов,
сброс отдельных битов или инвертирование отдельных битов), а также осу-
40 Глава 2
ществлять поразрядный сдвиг всего значения вправо или влево. Эта тема
обычно вызывает затруднения у программистов, имеющих слабое представ-
ление об архитектуре компьютера и о внутреннем представлении данных,
поэтому в приложении (см. разд. П1.12) приведено более подробное описа-
ние понятий, связанных с побитовыми операторами.
ЗАМЕ ЧАНИЕ
Компилятор С/С++ разрешает применять побитовые операторы только к це-
лым типам: char, short, int, long, long long, возможно с модификатором
unsigned (см. гл. 3). Результатом побитовых операций являются также целые
типы.
Рис. 2.1
Каждый из операторов "|"(ИЛИ), "&"(И), "^"(исключающее ИЛИ) независи-
мо выполняет действия над одноименными битами двух многоразрядных
двоичных слов:
􀂈 | — для установки битов;
􀂈 & — для сброса битов;
􀂈 ^ — для инверсии отдельных битов.
Правила истинности для четырех основных логических функций: конъюнк-
ции, дизъюнкции, исключающего ИЛИ, а также инверсии, которые обычно
реализованы в системах команд универсальных процессоров, приведены
в табл. 2.2.
ЗАМЕ ЧАНИЕ 1
Язык C/С++ предоставляет побитовые операторы, совмещенные с присваива-
нием:
x |= y;
Базовые понятия С/С++ 41
Таблица 2.2. Таблица истинности основных логических функций
Операнд1 Операнд2 Результат
AND (&) OR (|) XOR (^)
0 0 0 0 0
0 1 0 1 1
1 0 0 1 1
1 1 1 1 0
Операнд Результат
NOT(~)
0 1
1 0
ЗАМЕ ЧАНИЕ 2
Не путайте побитовые операторы: &, |, ~ с логическими: &&, ||, !. Последние
возвращают true (1) или false (0) и применяются в основном в инструкциях
if, while и for.
ЗАМЕ ЧАНИЕ 3
Побитовые операции (кроме сдвига вправо) не зависят от того, знаковый опе-
ранд или без знака. В приложении (см. разд. П1.12) приведены дополнитель-
ные сведения об особенностях команд сдвигов, реализованных в системах
команд процессоров.
Пример 1.
Побитовое отрицание:
char x = 5; x: 0000 0101
char y = ~x y: 1111 1010
Пример 2.
Побитовое сложение:
char x = 5; x: 0000 0101
char y = 12; y: 0000 1100
char z = x | y; z: 0000 1101
42 Глава 2
Пример 3.
Побитовое умножение:
char x = 5; x: 0000 0101
char y = 12; y: 0000 1100
char z = x & y; z: 0000 0100
Пример 4.
Побитовое исключающее ИЛИ (сложение по модулю 2):
char x = 5; x: 0000 0101
char y = 12; y: 0000 1100
char z = x ^ y; z: 0000 1001
Пример 5.
Сдвиги.
Первый операнд содержит значение, которое нужно сдвинуть, второй — ука-
зывает, на сколько разрядов нужно сдвинуть значение первого операнда.
􀂈 При сдвиге влево младшая часть всегда заполняется нулями, независимо
от знаковости операнда:
char x = 5; x: 0000 0101
char y = x << 2; y: 0001 0100
unsigned char x = 5; x: 0000 0101
unsigned char y = x << 2; y: 0001 0100
􀂈 При сдвиге вправо беззнаковых целых старшая часть всегда заполняется
нулями:
unsigned char x = 251; x: 1111 1011
unsigned char y = x >> 2; y: 0011 1110
􀂈 При сдвиге вправо знаковых целых старшая часть заполняется значением
старшего (знакового) разряда:
char x = -5; x: 1111 1011
char y = x >> 2; y: 1111 1110
char x = 5; x: 0000 0101
char y = x >> 2; y: 0000 0001
Базовые понятия С/С++ 43
Выполните задания, приведенные в табл. 2.3.
Таблица 2.3. Задания на побитовые операторы и операторы сдвига
Номер Задание
1 Дана целая переменная (int x;), которая может содержать любое значение.
Поменяйте в этой переменной местами значения старшего и младшего байтов
2 Дана целая переменная (int x;).
Проинвертируйте значения разрядов младшего байта
ЗАМЕ ЧАНИЕ 1
Сдвиг влево эквивалентен умножению на 2, сдвиг вправо эквивалентен деле-
нию на 2. Зачастую компилятор оптимизирует операции целочисленного деле-
ния и умножения на степень двойки, генерируя низкоуровневые команды сдвига.
ЗАМЕ ЧАНИЕ 2
Используя операторы сдвига, имейте в виду следующее: при выполнении низ-
коуровневой команды сдвига аппаратно может быть задействовано только ог-
раниченное число разрядов второго операнда, поэтому для процессоров X86
(где аппаратно задействованы только 5 младших разрядов второго операнда)
выражение (x<<32) не будет иметь никакого действия.
2.4.4. Логические операторы
и операторы отношения
Логические операторы (табл. 2.4) и операторы отношения используются при
формировании логических выражений, дающих в результате только два зна-
чения: true (1) и false (0). Наиболее часто такие выражения встречаются
в инструкциях управления потоком вычислений: циклах, условиях.
Таблица 2.4. Логические операторы !, &&, ||
Оператор Операнд 1 Операнд 2 Результат
логическое NOT (!) true false
false true
логическое AND (&&) true true true
все остальные комбинации false
логическое OR (||) false false false
все остальные комбинации true
44 Глава 2
Операторы отношения <, <=, >, >=, ==, != сравнивают значения выражений
слева и справа от оператора и формируют значения true или false в зависи-
мости от соотношения выражений.
ЗАМЕ ЧАНИЕ 1
Так как нулевое значение выражения соответствует false, а ненулевое соот-
ветствует true, то следующие выражения будут эквивалентны:
if(x!=0) эквивалентно if(x)
if(x==0) эквивалентно if(!x)
ЗАМЕ ЧАНИЕ 2
Если результат логического выражения используется в арифметическом выра-
жении, то вместо false компилятор подставит 0, а вместо true 1.
Например: int x=(y<100); //если y<100, то x=1, иначе x=0.
Пример.
Пусть требуется определить, находится ли значение переменной x в диапазо-
не [0,100]:
int x;
//сформировали значение x
//если пытаемся написать на С/С++ условие таким образом,
как писали в школе:
if(0<=x<=100)… //то получаем всегда true, т. к. компилятор будет
интерпретировать это выражение следующим образом:
сначала он сравнивает значение переменной x
с нулем и получает false (0) (если x<0),
и true (1) (если x>=0). Затем сравнивает
полученный результат с 100. Поскольку оба
значения всегда меньше 100, то такое выражение
всегда будет true.
//Как такое условие написать на С/С++ правильно:
if( (x>=0) && (x<=100) )…
ЗАМЕ ЧАНИЕ
Для повышения эффективности вычислений компилятор оптимизирует вычис-
ления выражений, в которых используется && или ||:
if(выражение1 && выражение2) — если результатом вычисления первого вы-
ражения является false, то второе уже не вычисляется;
if(выражение1 || выражение2) — если первое выражение дает true, то вы-
числять второе тоже не имеет смысла.
Выполните задания, приведенные в табл. 2.5.
Базовые понятия С/С++ 45
Таблица 2.5. Задания на логические операторы и операторы отношения
Номер Задание
1 Какой результат дадут два нижеприведенных выражения при исходном
значении a=0?
if(a==0)
if(a++>0)
if(++a>0)
2 Каким будет результат следующего выражения?
if(-1)
3 Сравните два выражения. Поясните разницу при вычислении обоих усло-
вий и предскажите результат:
if(x==5)
if(x=5)
Подсказка: это обычная ошибка использования оператора присваивания
(=) вместо оператора проверки на равенство (==).
Второе выражение в примере всегда будет истинно, т. к. результат отли-
чен от нуля
4 Каким будет результат выражения: 100 + (x <40)
• при x=0 ?
• при x=100 ?
5 Напишите условие: x >0 и нечетное
6 Чему будут равны значения y и z:
int x=-1;
int y = !x;
int z = -x;
7 Вспомните о приоритетах операторов и укажите порядок вычисления вы-
ражения:
x=0;
y=!++x;
2.4.5. Тернарный оператор ?:
По смыслу тернарный оператор идентичен конструкции if…else, но выгля-
дит компактнее, что вовсе не означает, что компилятор генерирует более эф-
фективный код.
Синтаксис:
условие ? true-выражение : false-выражение;
Сначала вычисляется условие.
Если условие принимает значение true, то вычисляется true-выражение, ина-
че вычисляется false-выражение.
46 Глава 2
Пример 1.
Последовательность команд:
if(a<=b) max = b;
else max=a;
можно переписать с помощью тернарного оператора:
max = (a<=b) ? b : a; //заключать условие в скобки необязательно,
но читается так лучше.
Пример 2.
Результатом тернарного оператора может быть lvalue. В таком случае по-
следовательность команд:
if(a<=b) b=max;
else a=max;
можно переписать с помощью тернарного оператора:
((a<=b) ? b : a) = max; //внешние скобки обязательны, иначе
компилятор решит, что присваивание
является частью false-выражения
Пример 3.
При целочисленном делении на ноль генерируется ошибка времени выпол-
нения. Посредством тернарного оператора можно предусмотреть защиту от
такой ситуации:
a = b ? 100/b : 0; //если b!=0 (т. е. условие принимает
значение true), то делить безопасно,
если же b=0, то деление производиться
не будет, а переменной a будет просто
присвоено нулевое значение
Пример 4.
Вывод на печать наибольшего из двух значений:
std::cout << ( i > j ? i : j ) <<" is greater" << std::endl;
//скобки являются существенными, т. к. без скобок
смысл выражения для компилятора будет совершенно
другим
Пример 5.
Тернарный оператор может быть вложенным.
Пусть требуется переменной y присвоить значение:
􀂈 1 — если x>0;
􀂈 -1 — если x<0;
􀂈 0 — если x=0.
Базовые понятия С/С++ 47
В таком случае можно записать:
y=(x<0) ? -1 : ( (x>0) ? 1:0); //в данном примере для внешнего
тернарного оператора true-выражение выполняется в
случае отрицательного значения x, а false-выражение
в свою очередь является вложенным тернарным
оператором и формирует оставшиеся два условия
Даны переменные x, y, z.
C помощью тернарного оператора найдите минимальное из трех значений.
ЗАМЕ ЧАНИЕ
Для оптимизации вычислений компилятор вычисляет только одно из выраже-
ний. Если условие принимает значение true, вычисляется только true-
выражение, если false, то только false-выражение. Например:
int x=1, y=2, z;
z=(x<y) ? x++ : y++; //сначала переменной z будет присвоено
значение x (z=1), а потом значение только этой
переменной будет инкрементировано(x=2).
2.4.6. Оператор ","
Оператор "," позволяет сгруппировать несколько выражений там, где компи-
лятор ожидает только одно. Не стоит злоупотреблять этим оператором, по-
скольку читабельность программы ухудшается.
Пример 1.
int a=1, b=2, c;
c=a,b; //c=1
c=(a,b); //c=2
c=a++,b++; //c=1, a=2, b=3
Пример 2.
int x;
if(std::cin>>x, x>0){…} //компилятор вычислит все выражения,
указанные через оператор (,) запятую, но формировать
условие будет по результату последнего выражения
Глава 3
Данные
3.1. Виды данных
С точки зрения программиста видов данных много: есть простые и очевид-
ные (целые и плавающие для представления чисел), часто используются дан-
ные для представления символов и строк, кроме того, для каждой конкретной
задачи программист может комбинировать простые данные, создавая таким
образом бесконечное число специфических пользовательских видов данных.
А с точки зрения процессора все объекты в памяти представляются совокуп-
ностью битов, содержащих 0 и 1 (двоичное представление данных). Но:
􀂈 разным объектам может соответствовать разное количество битов;
􀂈 даже если количество битов одинаково, эти 0 и 1 для каждого вида дан-
ных по замыслу программиста имеют совершенно разный смысл (напри-
мер, форматы хранения коротких плавающих float и целых int принци-
пиально разные!), поэтому действия процессора должны быть разными.
Возможности процессора по работе с данными разного типа ограничены.
Обычно в системе команд процессора имеются низкоуровневые команды для
работы с одно-, двух- и четырехбайтовыми целыми, а также специальные
низкоуровневые команды для работы с данными в плавающем формате и коман-
ды, которые позволяют обращаться к отдельным разрядам. Поэтому, естест-
венно, существуют правила, позволяющие устанавливать взаимосвязь между
двоичным представлением данных и их сущностью:
􀂈 для некоторых видов данных эти правила просты (например, для целых);
􀂈 для некоторых правила достаточно сложны, но всю работу по отображе-
нию берет на себя компилятор (например, для плавающих);
􀂈 для некоторых (пользовательских типов) соответствие должен установить
программист.
50 Глава 3
По большому счету элементы данных в программе можно разделить на две
разновидности:
􀂈 константы — программист при написании программы точно знает значе-
ния, которые будет использовать, не собирается изменять эти значения во
время выполнения программы и может заранее сообщить их компилятору;
􀂈 переменные — данные изменяются в процессе выполнения программы,
а программист может задать только начальные значения (проинициализи-
ровать элементы данных). Может быть и так, что начальные значения тоже
неизвестны заранее, а вычисляются в процессе выполнения программы.
И те, и другие (кроме переменных, содержащих адреса, т. е. указывающих
местоположение в памяти других программных элементов) могут быть сле-
дующего вида (рис. 3.1):
􀂈 числа: целые или с плавающей точкой (арифметические типы) — элемен-
ты данных, выражающие количества. Арифметические типы имеют раз-
личные форматы хранения и размеры. До написания программы програм-
мист должен оценить возможный диапазон изменения значений своих
данных и, исходя из этой оценки, выбрать подходящий тип для машинно-
го представления данных. С помощью правильного выбора в конкретной
ситуации конкретного типа данных программист может минимизировать
объем используемой памяти или время выполнения.
ЗАМЕ ЧАНИЕ1
Переменные целого типа могут быть беззнаковыми или знакопеременными.
В приложении рассмотрены более подробно способы представления чисел
двоичными кодами, их особенности и свойства.
ЗАМЕ ЧАНИЕ2
Элементы целочисленных данных после трансляции могут занимать в памяти
компьютера разное количество байтов. Элемент типа char занимает в памяти
один байт, элемент типа short — два байта, элемент типа long — 4 байта.
Еще один тип — int имеет размер, который зависит от особенностей процес-
сора, и обычно равен разрядности его регистров. Например, в процессорах се-
мейства х86 тип int имел длину два байта в младших 16-разрядных моделях,
а в современных процессорах тип int — четырехбайтовый. Подробную ин-
формацию о типах и разрядности элементов данных см. в разд. 3.4.2. В некото-
рых компиляторах используется нестандартный тип long long, длина которо-
го 8 байтов;
􀂈 символы — целочисленные элементы, предназначенные для хранения ко-
дов отдельных символов, и строки — совокупности символов;
􀂈 логические — для хранения результата логических операций — одного из
двух значений: true (истина) и false (ложь);
Данные 51
Рис. 3.1
􀂈 адреса — формируются компоновщиком и имеют смысл только во время
выполнения программы.
Для того чтобы компилятор мог генерировать низкоуровневый код, он дол-
жен знать тип каждого элемента данных.
Тип константы распознается компилятором по ее записи в тексте программы.
Тип переменной программист должен указать компилятору явно.
3.2. Константы (литералы)
Литералом называют текстовое представление значения константы (это тот
вид, в котором программисту в тексте программы привычно и удобно зада-
вать значения). Компилятор согласно своим правилам переводит это тексто-
вое представление в двоичный вид, с которым уже может работать процес-
сор. Константа может быть числовой, например:
3
-23.76
52 Глава 3
0.123e3
а также символьной или строковой, например:
'A'
"Hello World"
3.2.1. Целые литералы
В языке С/С++ можно использовать десятичные, шестнадцатеричные и вось-
меричные целые литералы.
ЗАМЕ ЧАНИЕ
В данном разделе упоминаются различные системы счисления, о них можно
более подробно прочитать в разд. П1 приложения.
Для того чтобы компилятор мог различать целые литералы по написанию
в тексте программы, приняты соглашения, представленные в табл. 3.1.
УТ О ЧНЕ НИ Е
Префиксы для шестнадцатеричных и восьмеричных литералов начинаются
с цифры 0 (а не с буквы О).
Таблица 3.1. Префиксы представления целых литералов
в разных системах счисления
Система счисления Префикс Примеры представления
десятичная без префикса 8 10 256
шестнадцатеричная 0x или 0X 0x8 или
0X8
0xA или
0Xa
0x100 или
0X100
восьмеричная 0 010 012 0400
Например:
x = 10; //эта константа (10) задана в десятичной системе
x = 010; //а эта (8) - в восьмеричной системе
x = 0x10; //константа (16) задана в шестнадцатеричной системе
ЗАМЕ ЧАНИЕ
Программист может задать в программе константу произвольной длины, но
в каждом компиляторе на количество цифр существуют ограничения.
По умолчанию (если программист не указал специальным образом) компиля-
тор сам определяет тип и размер целой константы, учитывает этот тип при
выполнении действий с константой и для хранения ее значения выделяет
Данные 53
в области кода (т. е. в той части памяти, где будут храниться машинные
команды) количество байтов согласно следующим простым правилам:
􀂈 если значение константы помещается в диапазон представления int — то
столько байтов, сколько занимает на данной платформе int (2 либо 4 байта);
􀂈 если значение выходит из диапазона представления int — то столько бай-
тов, сколько занимает long (4 байта);
􀂈 если значение находится за пределами диапазона long — то столько бай-
тов, сколько занимает long long (8 байтов);
􀂈 если значение выходит за диапазон long long, то компилятор его "обрезает"
до 8 байтов. При этом хороший компилятор должен выдавать предупреж-
дение о литералах, слишком длинных для внутреннего представления.
ПР ИМЕ ЧАНИЕ
Тип long long в настоящее время не является стандартным и поддерживается
не во всех компиляторах и не на всех платформах. В таком случае компилятор
ограничивает длину константы размером long (4 байта).
Посредством суффиксов (табл. 3.2) программист может предоставить компи-
лятору дополнительную информацию о том, как следует интерпретировать
указанное значение.
Таблица 3.2. Суффиксы для задания разрядности целых литералов
Суффикс Чему соответствует Пример
представления
Если суффикс отсутст-
вует
По приведенным выше правилам 3
L или l (от long) long (32-разрядное целое) 3L
ll или LL
i64 или I64
long long (64-разрядное целое) 3LL
3i64
В зависимости от суффиксов констант в следующих примерах получим раз-
ные результаты:
выражение (0xFFFFFFFF + 1) даст 0x00000000, т. к. при сложении двух
32-разрядных значений произойдет
переполнение разрядной сетки, и старший
разряд результата будет потерян
выражение (0xFFFFFFFFi64 + 1i64) даст 0x0000000100000000, поскольку
складываться будут 64-разрядные значения
и переполнения не произойдет
54 Глава 3
Также можно явно указать компилятору, каким образом он должен интерпре-
тировать константу — как знаковую или как беззнаковую (табл. 3.3). В зави-
симости от этого компилятор может генерировать разные низкоуровневые
команды при использовании такой константы в выражениях.
Таблица 3.3. Суффиксы для задания знакопеременности целых литералов
Суффикс Интерпретация значения Примеры представления
Без
суффикса
Компилятор интерпретирует кон-
станту как знаковую, если ее значе-
ние помещается в диапазон знако-
вого int, иначе как беззнаковую
-1 (0x0FFFFFFF) — знаковое
4294967295 (0xFFFFFFFF) —
беззнаковое
U или u
(от unsigned)
Компилятор интерпретирует кон-
станту как беззнаковую
255U
В зависимости от суффиксов констант в следующих примерах получим раз-
ные результаты.
Пример 1.
int n=31, m=3;
int res = ((1<<n)>>m); //res=0xf0000000, т. к. при сдвиге влево
в старшем знаковом разряде окажется единица, которая
при последующем сдвиге вправо знакового значения будет
распространена на три старших разряда
Пример 2.
int n=31, m=3;
int res = ((1u<<n)>>m); //res=0x10000000, т. к. при сдвиге вправо
беззнакового значения старшая часть заполняется нулями
ЗАМЕ ЧАНИЕ
Любой из суффиксов L, int64, LL можно комбинировать с суффиксом U, на-
пример: 12345678912345Ui64.
3.2.2. Литералы с плавающей точкой
Если в литеральной записи числа содержится точка (разделитель целой
и дробной части), то компилятор интерпретирует ее как константу с плаваю-
щей точкой. Стандартные форматы чисел с плавающей точкой рассмотрены
в разд. П1.11 приложения.
Данные 55
Примеры записи литералов с плавающей точкой:
1.25
0.25
.25
1.
Примеры записи чисел с плавающей точкой в инженерном (экспоненциаль-
ном) формате:
1.25E10 (мантиссаEпорядок)
1.25e-10
ЗАМЕ ЧАНИЕ 1
По умолчанию литералы с плавающей точкой являются константами типа double.
ЗАМЕ ЧАНИЕ 2
В записи литералов с плавающей точкой не должно быть пробелов! Например:
1. 25 e –10, скорее всего, будет воспринято компилятором как набор из четы-
рех различных литералов (что вызовет синтаксическую ошибку).
В языке С/С++ имеется несколько плавающих форматов. Посредством суффик-
сов программист может предоставить компилятору дополнительную информа-
цию о том, как интерпретировать значение и сколько памяти (в области кода)
компилятор должен задействовать для представления значения (табл. 3.4).
Таблица 3.4. Суффиксы для задания типа плавающего литерала
Суффикс Количество байтов
для представления значения
Пример
представления
Если суффикс отсутствует 8 0.25
F или f (от float) 4 0.25f или .25F
L или l (от long double) Пока 8, в дальнейшем возможно
больше
0.25l или .25L
3.2.3. Символьные литералы
Одним из самых распространенных видов данных является текстовая инфор-
мация: символы и строки. Символьным литералом (символьной константой)
называется последовательность, содержащая один или несколько символов
и заключенная в одинарные кавычки, например:
'A'
Компилятор, встретив в тексте программы символьный литерал, заменяет его
короткой двоичной кодовой комбинацией (кодом символа).
56 Глава 3
Использование символьных литералов вместо их числовых эквивалентов
(непосредственно кодов символов) обеспечивает:
􀂈 облегчение восприятия текста программы;
􀂈 возможность переносимости программ на другие процессоры (вычисли-
тельные системы).
Кодирование символов
Каждому символу, используемому в компьютерных программах, во внутрен-
нем представлении соответствует уникальное значение (двоичный код).
Сколько требуется отводить памяти под такой числовой эквивалент и какое
значение следует сопоставить символу, зависит от способа кодировки.
ЗАМЕ ЧАНИЕ
Кроме печатных знаков, необходимо еще некоторое количество кодовых ком-
бинаций, используемых для управляющих целей (переместиться в тексте на
новую строку или вернуться к началу строки и т. п.). Для того чтобы компилятор
мог вставить в двоичный код программы такую кодовую комбинацию, програм-
мист должен специальным образом ее изобразить в тексте программы (см.
разд. "Управляющие или escape-последовательности" данной главы).
Рассмотрим способы кодирования символов.
􀂈 В те далекие времена, когда большинство программ не поддерживали
диалогового режима с пользователем, программисту для представления
текстовой информации вполне хватало строчных и прописных букв ла-
тинского алфавита (даже в том случае, когда программист был не очень-то
и силен в английском языке), знаков препинания, знаков арифметических
действий, цифр и некоторых общеиспользуемых символов (таких, как @,
#, $ и т. д.). Для уникального представления всех перечисленных значений
достаточно 7 битов. Такой вид кодировки известен как ASCII (American
Standard Code for Information Interchange). При 7-битовой кодировке для
представления печатных символов отводится диапазон значений от 0x20
до 0x7F (от 32(10) до 127(10)). Кроме того, коды в диапазоне от 0x00 до 0x1F
используются для специфических (управляющих) целей: перевод строки, воз-
врат каретки и т. д. (см. разд. "Управляющие или escape-последовательности"
данной главы).
􀂈 Проблема проявилась позже, когда оказалось, что пользователь предпочи-
тает общаться с программой на своем родном языке. Решения для локали-
зации приложений (как заставить приложение воспринимать ввод/вывод
на разных языках) появлялись разные. Для символов нелатинских алфави-
тов стали использовать в рамках байтовой разрядной сетки диапазон
128—255 (например, кодировка КОИ8Р, в которой эти значения были
Данные 57
задействованы для кодов символов русского алфавита). Такой вид кодиров-
ки называют словосочетанием SBCS (Single Byte Character Set) — 8-битовая
кодировка.
􀂈 Посредством SBCS полностью проблему решить не удалось, т. к. сущест-
вуют языки (например, японский), в которых знаков гораздо больше, чем
можно закодировать однобайтовыми комбинациями. Поэтому появился
способ кодировки MBCS (MultiByte Character Set), при котором часть
символов кодируется одним байтом, а остальные — двумя. Очевидно, что
при таком способе кодировки должна быть возможность определения ко-
личества байтов, занимаемых кодом символа (значение первого байта со-
держит признак того, что символ кодируется двумя байтами). А для того
чтобы воспользоваться таким значением, необходимо программно анали-
зировать, сколько байтов занимает код символа. Кроме того, кодировка
MBCS предполагает применение разных кодовых страниц для разных
языков, а это означает, что в одной программе пользоваться одновременно
несколькими языками оказывается затруднительно.
􀂈 Для унификации кодирования текстовой информации в 90-х годах XX ве-
ка был разработан стандарт кодирования символов, известный под назва-
нием UNICODE, при котором любой символ кодируется двумя байтами.
Среди 65 536 возможных (при двухбайтовом кодировании) кодовых ком-
бинаций для каждого из языков был выделен свой диапазон (примеры
в табл. 3.5). При таком способе кодировки ничто не мешает использова-
нию в одной программе представления текстовой информации на несколь-
ких языках. Для совместимости со старыми программами, диапазон кодов
0x0000…0x007F был оставлен для традиционной кодовой таблицы ASCII.
Для символов кириллицы был выделен диапазон кодов 0x0400…0x4FF.
Таблица 3.5. Некоторые диапазоны представления символов для UNICODE
16-битный код Символы
0x0000 – 0x007f ASCII
… …
0x0370 – 0x03ff Греческий
0x0400 – 0x04ff Кириллица
0x0530 – 0x058f Армянский
Преимущества использования UNICODE по сравнению с MBCS:
􀂈 позволяет использовать в одном приложении сколько угодно разных язы-
ков (интернационализация приложений);
58 Глава 3
􀂈 увеличивает скорость выполнения прикладных программ, обрабатываю-
щих текстовую информацию, т. к. все символы кодируются единообразно
двумя байтами.
Недостаток:
􀂈 увеличивает расход памяти.
ЗАМЕ ЧАНИЕ
На сегодняшний день UNICODE является стандартом (полное описание приве-
дено в документе "The Unicode Standard: WorldWide Character Encoding" изда-
тельства Addison-Wesley). Операционные системы Windows семейства NT
сравнительно давно ориентированы на использование UNICODE, поэтому если
вы собираетесь разрабатывать Windows-приложения, то лучше сразу привы-
кать использовать этот тип кодировки.
Изображение символьных констант в С/С++-программе
Желая вставить в текст программы символьную константу (символьный ли-
терал), программист просто должен записать один или два символа, заклю-
чив их в одинарные кавычки, если он использует однобайтовое кодирование
(например, вот так: 's').
Если же предполагается использование UNICODE, то перед открывающей
кавычкой следует поставить префикс L (вот так: L's').
Встретив в тексте программы символьный литерал, компилятор должен за-
менить его соответствующим числовым эквивалентом. Этот числовой экви-
валент зависит от способа кодировки (табл. 3.6).
ЗАМЕ ЧАНИЕ
При любом способе кодировки диапазон 0—127 (ASCII) отводится под буквы
латинского алфавита, цифры и некоторые знаки @, #, $ и т. д.
Например:
std::cout<<'A'; //будет выведен символ A
std::wcout<<L'A'; //для расширенных символов используется
соответствующий поток вывода wcout
ЗАМЕ ЧАНИЕ 1
Синтаксис языка С/С++ позволяет задать в символьном литерале сразу два
символа следующим образом: 'ab'. При этом компилятор располагает коды
двух указанных символов в двух смежных байтах памяти: код первого символа —
по старшему адресу, код второго — по младшему: 0x6162. Рекомендуется из-
бегать такого задания символьных литералов — это ухудшает читабельность
текста программы.
Данные 59
Таблица 3.6. Использование символьных литералов
Способ кодировки
SBCS MBCS UNICODE
Escape –
последова-
тельность
Пример
изобра-
жения
'A' 'Ф'
'1' '*'
'a' '+' 'Б'
т. к. коды всех
букв русского
алфавита по-
мещаются
в диапазон
128—255, то
пример символа
кириллицы,
который будет
занимать 2 бай-
та, привести
затруднительно
L'A' L'Ф' '\a' '\n'
'\"' '\''
'\08'
'\0x10'
'\\'
L'\n' L'\\'
L'\08'
Сколько
занимает
памяти
1 байт 1 или 2 байта 2 байта Несмотря на
внешний вид,
это одиночный
символ, поэто-
му: без префик-
са L — 1 байт,
с префиксом —
2 байта
Что
делает
компи-
лятор,
встречая
в тексте
символь-
ный ли-
терал
Подставляет
вместо него
байт с число-
вым эквива-
лентом данно-
го символа из
набора SBCS
'a' – 0x61
'Ф' – 0xd4
Подставляет
вместо него
один или
два байта
из набора
MBCS:
'a' – 0x61
'Ф' – 0xd4
Подставляет
значение
из набора
UNICODE
L'Ф' – 0x424
Подставляет
значение
в соответствии
с табл. 3.7.
'\n' – 0x0A
(10)
L'\n' –
0x000A (10)
ЗАМЕ ЧАНИЕ 2
В некоторых языках коды, которые в ASCII соответствуют специальным симво-
лам (#, [, {, }, |…), заняты кодами букв, которых нет в английском алфавите
(Å. Æ…). Если в таком случае требуется вывести специальный символ, то ис-
пользуются триграфы. Например: если код символа '#' в данном языке занят,
то для вывода # можно использовать триграф '??='.
60 Глава 3
Управляющие или escape-последовательности
Есть несколько особых кодовых комбинаций:
􀂈 которым не соответствуют отображаемые символы (перевод строки, зву-
ковой сигнал…). Такой код является управляющим для устройства, т. е.
заставляет устройство выполнять некоторые специфические действия;
􀂈 изображение отсутствует на клавиатуре, а отображать хочется (♥, ☺, ♣…);
􀂈 отображаемый символ используется компилятором в своих целях (", \...).
Так как такие кодовые комбинации имеют специальное назначение, то они
в тексте программы записываются последовательностью символов, начи-
нающейся с символа обратной косой черты \. Несмотря на свой внешний вид,
каждая такая последовательность на самом деле соответствует одной кодо-
вой комбинации. Примеры часто используемых escape-последовательностей
приведены в табл. 3.7.
Таблица 3.7. Управляющие (escape) последовательности
Символьное
представление
Шестнадцатеричный
код
Что делает компилятор
'\a' 0x07 Звуковой сигнал
'\b' 0x08 Возврат на знакоместо назад
'\f' 0x0C Перевод страницы
'\n' 0x0A Перевод строки
'\r' 0x0D Возврат каретки
'\t' 0x09 Горизонтальная табуляция
'\v' 0x0B Вертикальная табуляция
'\\' 0x5C Символ обратной косой чер-
ты
'\'' 0x27 Символ апострофа
'\"' 0x22 Символ кавычки
'\?' 0x3F Символ вопросительного
знака
'\0101' (явное задание
кода символа в восьме-
ричной системе)
0x41 Код символа A
Эквивалентно 'A'
'\x42' (явное задание
кода символа в шестна-
дцатеричной системе)
0x42 Код символа B
Эквивалентно 'B'
'\0' 0x00 Нулевое значение байта
Данные 61
Примеры (эти фрагменты программы печатают на экране):
std::cout<<’\x41’<<’\\’<<’\n’; //будет напечатано: A\
и произойдет переход на новую строку
std::cout<<’\3’; //в MS_DOS или Win32 Console приложении будет
напечатан символ ♥.В других ОС ASCII-коду 3 может
соответствовать другое графическое изображение
или оно может вовсе отсутствовать.
ЗАМЕ ЧАНИЕ
За символом \ могут следовать только предусмотренные компилятором сим-
волы, иначе результат интерпретации такой escape-последовательности не оп-
ределен. Например, компилятором VC для такой непредусмотренной комбина-
ции будет выдано предупреждение, а символ \ будет просто проигнорирован.
3.2.4. Строковые литералы
Строковый литерал — это заключенная в двойные кавычки последователь-
ность символов:
"Пример строковой константы"
Специфика:
􀂈 строковый литерал — это массив (тип такого массива — char[ ]), в кото-
ром компилятор хранит коды указанных программистом символов;
􀂈 следует помнить, что компилятор при генерации такого массива автома-
тически добавляет завершающий нулевой байт, т. к. такое нулевое значе-
ние в С/С++ является признаком конца строки;
􀂈 компилятор отводит память для хранения такого массива в той же облас-
ти, в которой находится код программы, поэтому в защищенном режиме
(для процессоров семейства x86) эта область оказывается аппаратно за-
щищенной от записи. Во время выполнения программы попытка модифи-
кации такой области памяти вызовет срабатывание аппаратного механиз-
ма защиты и передачу управления операционной системе;
􀂈 строка может быть пустой ("") — эта запись означает, что строковый ли-
терал состоит из единственного нулевого байта;
􀂈 можно представить одну строку в виде совокупности строк (конкатенация
строковых литералов) следующим образом:
"12" "34" "56" эквивалентно "123456" //компилятор воспринимает
такую запись как один строковый литерал. В конце
массива добавляется один завершающий ноль;
62 Глава 3
􀂈 строка с префиксом L (например, L"My wide chars") является строкой сим-
волов, закодированных двухбайтовыми кодами UNICODE (ее тип: wchar_t[]):
std::wcout<<L"My wide chars"; //для вывода расширенного строкового
литерала используется соответствующий
поток расширенного вывода
􀂈 если строка оказывается слишком длинной, а программисту не хочется
прокручивать окно редактирования, то для переноса остатка строкового
литерала на следующую строку в тексте программы нужно использовать
обратный слеш \. Компилятор этот обратный слеш проигнорирует и вос-
примет такую запись как одну строку.
Что будет напечатано?
std::cout<<"ABC\
DFG";
􀂈 для того чтобы в строку вставить символ " (двойную кавычку) или \ (об-
ратный слеш) — эти символы являются служебными для компилятора,
нужно использовать escape-последовательности.
Что будет напечатано?
std::cout<<"A\"BC\\D";
3.3. Перечисление enum
В практике программирования встречаются случаи, когда выражение может
принимать значения только из заранее определенного конечного множества
значений. Для таких задач язык Си предоставляет программисту способ за-
дания именованных целочисленных констант: enum (перечисление).
Это средство облегчает жизнь программисту следующим образом: вместо
того, чтобы помнить и использовать в тексте программы числовые значения,
можно один раз сопоставить каждой константе имя и далее пользоваться
этими именами (которые запомнить гораздо легче), а компилятор сам в каж-
дом нужном месте просто подставит значение соответствующей константы.
Синтаксис:
enum [имя_пользовательского_типа] {список_именованных_констант};
Пример 1.
Допустим, что программист должен предоставить пользователю выбор из
трех вариантов действий, а программа, соответственно, должна в каждом
случае отреагировать по-разному.
Данные 63
Это можно было бы решить следующим образом: каждому варианту сопоставить
значение: 0, 1, 2. При этом программист должен помнить, какому варианту дей-
ствий программы соответствует каждое абсолютное значение (листинг 3.1).
Листинг 3.1. Использование абсолютных значений для обозначения констант
{
int n; //в этой переменной будет сформирован выбор пользователя
//Формирование значения переменной n
if(n == 0){…} //если значение переменной совпадает с нулем,
то пользователь может продолжить выполнение
программы (при этом программист должен помнить,
чему соответствует этот ноль)
}
Гораздо удобнее для этих же целей ввести именованные константы, а имя
подскажет, чего хочет пользователь (листинг 3.2).
Листинг 3.2. Использование enum для обозначения констант
{
enum{CONTINUE, CANCEL, RETRY}; //встретив такое объявление,
компилятор запомнит указанный в скобках список
имен и сопоставит каждому имени значение
по умолчанию: 0, 1, 2. Позже, встретив в тексте
программы CONTINUE, компилятор подставит 0,
вместо CANCEL подставит 1, вместо RETRY — 2
//или enum{CONTINUE=-1, CANCEL=0, RETRY=1}; //значения констант
определены программистом явно
//или enum{CONTINUE=-1, CANCEL, RETRY}; //значения констант
будут по умолчанию сформированы следующим образом:
CONTINUE соответствует -1, а дальше компилятор
формирует значение очередной константы, прибавляя
единицу, т. е. CANCEL=0, RETRY=1 (пока снова не
встретит явный инициализатор)
int n; //в этой переменной будет сформирован выбор пользователя
//Формирование значения переменной n
if(n == CONTINUE){…} //гораздо понятнее
}
64 Глава 3
ЗАМЕ ЧАНИЕ
Именованными константами, определенными внутри блока, можно пользовать-
ся до закрывающей скобки блока.
Пример 2.
С помощью перечисления можно ввести свой пользовательский тип и далее
создавать и использовать переменные такого типа (листинг 3.3).
ЗАМЕ ЧАНИЕ
Переменные типа enum аналогичны другим целочисленным переменным, с той
лишь разницей, что без принудительного приведения типа (см. разд. 3.4.5) ком-
пилятор позволит присваивать им значения только посредством именованных
констант, указанных программистом в списке инициализаторов.
Листинг 3.3. Использование переменных типа enum
{
enum REASON{ OK, CANCEL, RETRY}; //REASON является
пользовательским типом.
//в С++
REASON res; //объявление переменной типа REASON подсказывает
программисту и компилятору, как предполагается
использовать переменную res
//в языке Си обязательно требуется уточнить компилятору посредством
ключевого слова enum, что REASON является
перечислением
enum REASON res1;
res= CANCEL; //корректно — переменная res будет содержать 1
res = OK; //корректно, присвоили res значение 0
//OK = 4; //ошибка, т. к. OK – это константа
//res = 0; //ошибка, несмотря на то, что значение OK=0,
поскольку переменной такого типа можно присвоить
значение только посредством именованной константы.
Чтобы компилятор не выдавал ошибки, требуется явное
приведение типа (см.разд. 3.4.5)
}
Данные 65
ЗАМЕ ЧАНИЕ 1
При вычислении выражений вместо именованных констант компилятор под-
ставляет соответствующие целые значения.
Проинтерпретируйте результат приведенных выражений:
int sum = OK + CANCEL + RETRY;
int m = 10;
if(m> OK){…}
int n= OK;
ЗАМЕ ЧАНИЕ 2
В стандартном Си тип данных enum эквивалентен знаковому целому (signed
int). Стандарт языка С++ разрешает программисту самому указывать один из
целых типов, на базе которого компилятор создает перечисление: char, short,
int или long, а также можно уточнить знаковость перечисления посредством
signed или unsigned: enum REASON : unsigned char {OK, CANCEL,
RETRY};
ЗАМЕ ЧАНИЕ 3
В списке инициализации значения могут повторяться. Встретив очередной яв-
ный инициализатор, компилятор по умолчанию формирует значение следую-
щей именованной константы, прибавляя единицу:
enum{a=1, b, c, A=1, B, C}; //a=1, b=2, c=3, A=1, B=2, C=3
или
enum{a=1, b, c, A=a, B, C}; //результат будет таким же
3.4. Переменные
Если значения констант программист должен указать компилятору непосред-
ственно в тексте программы, то значения переменных вычисляются в про-
цессе выполнения программы, поэтому эти два вида данных имеют принци-
пиальные отличия (табл. 3.8).
Таблица 3.8. Сравнение констант и переменных
Константы Переменные
Тип константы распознается компилято-
ром по ее написанию в тексте програм-
мы: по умолчанию или по использован-
ным программистом префиксам и
суффиксам
Тип переменной программист должен
указать компилятору явно
66 Глава 3
Таблица 3.8 (окончание)
Константы Переменные
Встретив в тексте программы значение
константы, компилятор помещает ука-
занное значение непосредственно в
тело процессорной команды
Переменные — это поименованные про-
граммистом области памяти для хране-
ния значений. Встретив в тексте про-
граммы имя переменной, компилятор на
самом деле генерирует процессорную
команду, которая обращается к ассоции-
рованной с этим именем области памяти
Константы можно использовать в выра-
жениях только справа от знака равенст-
ва (модифицировать их просто невоз-
можно)
Переменные являются lvalue. Их мож-
но использовать как справа от знака
равенства, так и слева, за исключением
переменных, объявленных с ключевым
словом const (см. разд. 3.10.1)
3.4.1. Что такое тип переменной
Программист пишет текст программы, оперируя понятиями языка высокого
уровня. Для того чтобы программа могла выполняться, написанный текст
должен быть преобразован компилятором в двоичный код, с которым может
работать процессор. При этом один и тот же текст на языке высокого уровня
(одни и те же действия с данными разного типа) компилятор превращает
в разные последовательности низкоуровневых команд:
int x1=1, y1=2, z1;
z1 = x1 + y1; //компилятор сгенерирует низкоуровневую команду
целочисленного сложения — add
double x2=1.2, y2=2.33, z2;
z2 = x2 + y2; //компилятор сгенерирует низкоуровневую команду
плавающего сложения — fadd
На рис. 3.2 представлено разделение обязанностей между программистом
и компилятором для получения результирующего двоичного кода. Роль ком-
пилятора:
􀂈 выделить нужное количество памяти для хранения значения переменной;
􀂈 распознать, в каком виде использует данные программист, и перевести их
в двоичное представление, которое понимает процессор;
􀂈 при выполнении действий с переменными разного типа сгенерировать раз-
ные низкоуровневые команды.
ЗАМЕ ЧАНИЕ
Программисту удобнее в отдельных случаях по-разному задавать значения, ко-
торые в двоичном виде будут выглядеть одинаково.
Данные 67
Компилятор
Процессор
Программист
(текст на языке C/С++)
Разделение обязанностей для получения двоичного кода
объявляет
переменную
некоторого типа
использует эту
переменную в
выражениях
умеет оперировать с
областями памяти,
используя разные
способы адресации
(косвенные)
производит вычисления
эффективнее, если
данные находятся в
регистрах, а не в памяти
выделяет память
(разное количество
байтов в зависимости
от типа переменной!!!)
ассоциирует
выделенную память с
именем переменной
встречая имя переменной в
выражении, генерирует разные
низкоуровневые команды
процессору в зависимости от
типа переменной
Рис. 3.2
Следующие, разные с точки зрения программиста, представления данных для
процессора выглядят одинаково:
char c = 'A'; //посредством символьного литерала в памяти будет
храниться 0100 0001 - двоичный код символа A
c = 65; //или то же самое значение, заданное программистом
в десятичной системе счисления
c = 0x41; //то же самое – в шестнадцатеричной системе
c = 0101; //то же самое – в восьмеричной системе
3.4.2. Фундаментальные (базовые, встроенные)
типы С/С++
Основные потребности программиста отражены в фундаментальных типах
С/С++ (рис. 3.3). Эти типы поддерживаются большинством современных
компьютеров на аппаратном уровне (имеется в виду организация памяти
и набор машинных инструкций для операций над данными фундаментальных
68 Глава 3
типов). Если на аппаратном уровне поддержка не реализована, она осуществ-
ляется программно.
Рис. 3.3
ЗАМЕ ЧАНИЕ 1
Если в программе используются только встроенные типы данных, компилятор
без каких-либо дополнительных объяснений программиста сам знает, какие
низкоуровневые инструкции генерировать! На то они и встроенные!
ЗАМЕ ЧАНИЕ 2
Пунктиром на рис. 3.3 отмечены фундаментальные типы С++, которых в стан-
дарте нет, но многие компиляторы так или иначе такие типы поддерживают
(например, VC).
Данные 69
3.4.3. Оператор sizeof и размеры переменных
Для определения размера переменной служит оператор sizeof. Результатом
является количество байтов, занимаемых переменной (или выражением).
ЗАМЕ ЧАНИЕ 1
Результат оператора sizeof вычисляется на этапе трансляции компилято-
ром, а не во время выполнения программы.
ЗАМЕ ЧАНИЕ 2
Для обозначения типа результата, вычисляемого оператором sizeof, в заголо-
вочном файле <cstddef> (в нестандартизованных версиях — <stddef.h>) введен
специфический тип size_t, который на самом деле является синонимом unsigned
int.
Формы оператора sizeof (синтаксис):
size_t num = sizeof(выражение); //скобки могут быть опущены
size_t num = sizeof(тип); //скобки обязательны. Тип может
быть как базовым, так и пользовательским
Специфика:
sizeof (char) == 1 //по определению
sizeof (массива) == количество байтов, занимаемых массивом
sizeof (class, struct, или union) == количество байтов, занимаемых
объектом пользовательского типа, + затраты
на выравнивание см. разд. 9.11 и 10.1)
Например:
double d;
size_t n = sizeof( d ); //8
n = sizeof( int ); //2 или 4 в зависимости от типа процессора
n = sizeof( имя_массива ); //количество байтов, занимаемых
массивом, причем элементы массива
могут быть любого типа
Подумайте, чему будет равен размер переменной ld?
long double ld;
n= sizeof( ld );
ЗАМЕ ЧАНИЕ
В общем случае по поводу размеров фундаментальных типов гарантируются
только следующие соотношения (Б. Страуструп):
1==sizeof(char)<=sizeof(short)<=sizeof(int)<=sizeof(long)
sizeof(float)<=sizeof(double)<= sizeof(long double)
70 Глава 3
Свойства (размеры) базовых типов (numerical limits)
в зависимости от реализации
Иногда в программе требуется учитывать свойства фундаментальных типов,
которые зависят от реализации. Например, размер переменной типа int или
то, каким образом преобразуется длинный плавающий формат к целому
формату (округляется или обрезается) и т. д. Такие особенности лучше
учесть при написании программы, нежели потом искать возникающие нетри-
виальные ошибки во время выполнения.
Одним из способов борьбы с особенностями реализации является использо-
вание стандартной библиотеки, когда это возможно. Соответствующие сред-
ства стандартной библиотеки реализованы посредством шаблонов и сосредо-
точены в заголовочном файле <limits>. А т. к. речь о заголовочных файлах
(см. разд. 5.6) и шаблонах пойдет позже, просто приведем примеры, как эти-
ми средствами можно пользоваться.
Пример 1.
Пусть требуется определить, можно ли присвоить значение, хранящееся в пе-
ременной типа int, переменной меньшего размера char без потери значения.
Способ 1 — без использования средств стандартной библиотеки (листинг 3.4).
Листинг 3.4. Проверка диапазона значений char без использования средств
стандартной библиотеки
{
int n=значение; //это значение может лежать в пределах диапазона
изменения char, а может и выходить за пределы,
поэтому следует проверить: не потеряем ли мы
значение при присваивании
char c;
if( (n>=-128) && (n<=127)) c=n; //присваивание будет произведено
без потери значения
else… //иначе значение переменной n не может
храниться в c без потери значения
}
Способ 2 — с использованием средств стандартной библиотеки.
В стандартной библиотеке имеется пара функций, которые возвращают ми-
нимальное и максимальное значения типа char:
􀂈 numeric_limits<char>::min();
􀂈 numeric_limits<char>::max().
Данные 71
Листинг 3.5 демонстрирует способ их использования.
Листинг 3.5. Использование средств стандартной библиотеки для определения
диапазона значений char
#include <limits>
{
int n=значение;
char c;
if( (n >= numeric_limits<char>::min() ) &&
(n <= numeric_limits<char>::max() ) c=n; // без потери
значения
}
Пример 2.
На самом деле стандартная библиотека предоставляет много других полез-
ных средств для получения информации о базовых типах (листинг 3.6).
Листинг 3.6. Примеры использования средств стандартной библиотеки для
определения свойств встроенных типов
{
//сколько значащих цифр соответствует каждому из базовых типов:
n = numeric_limits<char>::digits; //7 значащих двоичных цифр
n = numeric_limits<unsigned char>::digits; //8 значащих цифр
//как округляются числа в плавающем формате при приведении
к целому типу:
if(numeric_limits<double>::round_style==round_to_nearest)
//округляется до ближайшего целого
//…
}
3.4.4. Знаковость переменной
Когда мы объявляем знаковую или беззнаковую переменную, то указываем
компилятору:
􀂈 сколько зарезервировать памяти, при этом знаковость переменной никак
не проявляется — это только наше представление (интерпретация про-
72 Глава 3
граммистом) того значения, которое лежит по ассоциированному месту
в памяти. Например, если мы знаем, что диапазон изменения данных не
более чем от –128 до +127 (всего 256 возможных значений), тогда логично
для хранения таких данных завести знаковую переменную типа char.
А если диапазон изменения данных от 0 до 255 (возможных значений
тоже 256), то можно использовать переменную типа unsigned char;
􀂈 какие команды низкого уровня (разные!) компилятор должен генериро-
вать при операциях с этой переменной, теперь знаковость начинает влиять.
Обратите внимание на то, что двоичные представления для разных значений
переменных: знаковой x и беззнаковой y в двоичном виде могут быть абсо-
лютно одинаковыми (см. разд. П1.5 приложения). А результат сравнения
двух значений получается разный, т. к. компилятор, исходя из типа перемен-
ных, генерирует разные низкоуровневые команды (листинги 3.7 и 3.8, в кото-
рых соответствующие строки на ассемблере приведены для VC.NET 2005).
Листинг 3.7. Переменные объявлены как знаковые
{
int x=0x1; //Компилятор сгенерирует:
mov dword ptr[x],000000001h
int y=0xffffffff; //представление -1. Компилятор сгенерирует:
mov dword ptr[y],0FFFFFFFFh
if(x>y){…} //должны получить true, т. к. 1>-1. Компилятор
сгенерирует:
mov eax,dword ptr[x]
cmp eax,dword ptr[y] ; команда сравнения изменяет флаги
jle <адрес_перехода> ; переход, если меньше или равно
с учетом знака
}
Листинг 3.8. Переменные объявлены как беззнаковые, а значения в них
те же самые
{
unsigned int x=0x1; //Компилятор сгенерирует:
mov dword ptr [x],000000001h
unsigned int y=0xffffffff; //представление значения 4294967295.
Данные 73
Компилятор сгенерирует:
mov dword ptr [y],0FFFFFFFFh
if(x>y){…} //должны получить false, поскольку 1<4294967295.
Компилятор сгенерирует:
mov eax,dword ptr[x]
cmp eax,dword ptr[y] ; команда сравнения изменяет флаги
jbe <адрес_перехода> ; переход, если меньше или равно
без учета знака
}
3.4.5. Приведение типов
В приведенных в предыдущем разделе примерах операнды, участвующие
в выражении, были одного типа. На практике в любом выражении могут уча-
ствовать переменные и литералы разных типов.
Проблемы:
􀂈 процессор не умеет работать с операндами разного типа, поэтому прежде
чем производить вычисления, компилятор должен все значения привести
к одному типу, например:
char a=1;
double b=2.2;
double с = a+b; //прежде чем вычислять сумму, компилятор должен
привести значение, хранящееся в байтовой
переменной с к типу double
􀂈 наиболее эффективно вычисления выполняются, если значения находятся
в регистрах;
􀂈 смысл выражения с точки зрения программиста не всегда очевиден,
а компилятор всегда должен действовать однозначно, поэтому существу-
ют правила, которым в таких ситуациях следует компилятор.
В примерах, приведенных в табл. 3.9, исходные значения переменных
одинаковы, но результат будет разным. Попробуйте предсказать их
в каждом случае, а затем сравните ваши предположения с правилами
(по которым будет действовать компилятор), изложенными в следую-
щем разделе.
74 Глава 3
Таблица 3.9. Задания для проверки интуиции
Номер Попробуйте предсказать результат в каждом случае
1 char c1=0xff;
unsigned char c2 = 0xff;
if(c1==c2){…}
2 int n=0xff;
char c = 0xff;
if(c==n){…}
3 int n=0xff;
unsigned char c = 0xff;
if(c==n){…}
Неявное приведение типов (компилятором)
Для того чтобы компилятор мог вычислить выражение, операнды должны
быть одинакового типа, поэтому перед вычислением выражения компилятор
модифицирует операнды таким образом, чтобы они были одного и того же
типа, но (важно!) сохранили свое значение (операции приведения типов на
уровне двоичного кода обсуждаются в разд. П1.10 приложения). При этом
для того, чтобы не потерять точность, компилятор приводит все значения
к старшему типу (о понятии старшинства типов см. разд. П1.12 приложения).
Если программист не указывает компилятору явно, как ему делать преобра-
зования при использовании в выражении переменных разных типов, то ком-
пилятор в ходе вычисления перед выполнением действия делает внутренние
преобразования сам, т. е. осуществляет неявное приведение типов.
Правила:
􀂈 сначала вычисляется выражение справа от знака равенства. Важно! При
вычислении выражения справа от знака равенства значения преобразуют-
ся всегда к старшему типу:
• компилятор разбивает выражение на подвыражения;
• каждое подвыражение обрабатывается в соответствии со следующими
правилами:
◊ если в выражении используются короткие целые, то компилятор
приводит их к размеру регистра с учетом знаковости;
◊ если в подвыражении фигурируют плавающие или long, все операн-
ды приводятся к старшему типу;
◊ вычисляется значение подвыражения;
Данные 75
• все, сказанное о вычислении подвыражений, применяется для вычис-
ления выражения в целом;
􀂈 полученное в результате вычисления выражения значение приводится
к типу слева от знака равенства.
ЗАМЕ ЧАНИЕ
При выполнении операции присваивания результат приводится к типу выраже-
ния слева от знака равенства. В этом случае может возникнуть ситуация пре-
образования старшего типа к младшему, и, соответственно, потеря точности
или даже возникновение грубой ошибки, если значение старшего типа не по-
мещается в разрядную сетку младшего (см. разд. П1.12 приложения).
Для того чтобы не получать странные результаты или не потерять точность при
вычислении выражений, программист должен знать правила, по которым ком-
пилятор осуществляет неявные преобразования. И, если действия компилятора
не соответствуют замыслу программиста, необходимо уточнить компилятору
смысл посредством явного приведения типов (см. следующий раздел).
Особенности приведения целых типов:
􀂈 при преобразовании знаковых типов (младшего целого типа к старшему
целому типу) старшие биты могут заполняться либо нулями, либо значе-
нием знакового (старшего) бита преобразуемого значения (такое преобра-
зование называется распространением знака — sign extention);
ПР А В И Л О
Общее правило состоит в следующем: при преобразовании младшего знаково-
го типа к старшему (знаковому или беззнаковому) типу расширенные старшие
биты заполняются значением знакового разряда преобразуемого значения; при
преобразовании младшего беззнакового типа к старшему (знаковому или без-
знаковому) типу расширенные старшие биты всегда заполняются нулями.
􀂈 при вычислении выражения целые типы (короче, чем int) сначала приво-
дятся к размеру регистра с учетом их знаковости (это сделано для повы-
шения эффективности вычислений, т. к. оптимизирующий компилятор
старается все операции выполнять в регистрах процессора);
􀂈 преобразование целых типов в типы с плавающей точкой выполняются
с помощью команд сопроцессора (или специальными библиотечны-
ми процедурами) с заполнением свободных правых битов мантиссы
нулями;
􀂈 преобразование старших целых типов в младшие выполняется отбрасы-
ванием старших байтов. При этом возможно возникновение грубой
ошибки.
76 Глава 3
ЗАМЕ ЧАНИЕ
При преобразовании старшего целого типа к младшему типу, результат коррек-
тен только тогда, когда целая часть преобразуемого значения помещается
в диапазон представления для более короткого целого типа. Компилятор при
таких потенциально опасных преобразованиях выдает предупреждение о воз-
можной потере значения.
Особенности приведения плавающих типов:
􀂈 преобразование double к float выполняется специальными командами со-
процессора с округлением числа до нужного количества знаков в мантиссе;
􀂈 преобразование типа с плавающей точкой в целый тип выполняется
командами сопроцессора или специальными библиотечными процедурами
и дает ближайшее целое число в соответствии с используемым правилом
округления (см. разд. П1.10 и П1.12 приложения).
Пример 1.
int x=1;
double res1 = x/2; //так как в выражении участвуют только целые
типы (целая переменная x и целый литерал 2), то
компилятор сгенерирует низкоуровневую команду
целочисленного деления idiv, при выполнении которой
дробная часть просто не формируется, поэтому,
несмотря на то, что тип res1 — плавающий,
значение res1 = 0
double res2 = x/2.; //а в этом случае второй операнд выражения —
плавающий литерал, поэтому компилятор сгенерирует
совершенно другую низкоуровневую команду плавающего
деления fdiv и res2 = 0.5
В целях закрепления материала примените правила неявного приведения
типа при вычислении выражений (табл. 3.10) и проинтерпретируйте ре-
зультат.
Пример 2.
Для повышения эффективности вычислений компилятор предпочитает по-
мещать значения операндов в регистры. Следовательно, если в выражении
используются короткие целые (и не используются плавающие типы или
long), компилятор должен преобразовать значение каждого короткого целого
к размеру регистра (т. е. представить то же самое значение в другой разряд-
ной сетке).
Данные 77
Таблица 3.10. Задания для закрепления материала
Номер Проинтерпретируйте результат
1 int x=1;
double y=0.1;
double dres = y + x/2; //объясните результат
2 int x=1;
double y=0.1;
int ires = y + x*0.1; //объясните результат
3 int x=10;
if(1/x >0)… //объясните результат
Таблица 3.11. Как компилятор поступает
с беззнаковыми короткими целыми
Исходные
значения
Преобразованные значения
(на самом деле будут складываться)
Результат
с1 = 0xFF 0x000000FF
с2 = 0x01 0x00000001
0x00000100
Если короткие целые беззнаковые, то компилятор преобразует хранящиеся
в таких операндах значения к размеру регистра посредством заполнения
старших разрядов нулями. Это означает, что число 255, которое было
представлено в байтовой разрядной сетке значением 0xff, в четырехбайтовой
разрядной сетке должно превратиться в 0x000000ff (табл. 3.11).
unsigned char с1=0xff, с2=0x1; // с1=255, с2=1
int sum = c1+c2; //
Пример 3.
Пусть имеем выражение такое же, как в предыдущем примере. Внутренние
представления значений переменных c1 и c2 тоже такие же. Единственным
и существенным отличием является то, что они объявлены как знаковые. Пе-
ред вычислением выражения компилятор преобразует значения, хранящиеся
в c1 и c2, к размеру регистра (табл. 3.12), а это означает, что число –1, кото-
рое было представлено в байтовой разрядной сетке значением 0xff, в четы-
рехбайтовой разрядной сетке должно превратиться в 0xffffffff. Компиля-
тор сохраняет значение знаковой переменной, распространяя значение
старшего знакового разряда на всю старшую часть (три старших байта)
78 Глава 3
посредством специальных низкоуровневых команд. Такая операция носит
название sign extension (расширение знака).
char с1=0xff, с2=0x1; //с1=-1, с2=1
int sum = c1+c2;
Таблица 3.12. Как компилятор поступает со знаковыми короткими целыми
Исходные значения Преобразованные значения
(на самом деле будут складываться)
Результат
с1 = 0xFF 0xFFFFFFFF
с2 = 0x01 0x00000001
0x00000000
Пример 4.
Посмотрим, как поступает компилятор, если в выражении используются как
знаковые, так и беззнаковые операнды.
ПР Е ДУП Р Е Ж ДЕ НИ Е
Не следует смешивать в операторах сравнения знаковые и беззнаковые опе-
ранды. Компилятор в таких ситуациях обычно выдает предупреждение, и со-
гласно своим правилам сначала интерпретирует значения как беззнаковые,
а потом вычисляет выражение
int x=-1; //внутреннее представление - 0xffffffff
unsigned int y=1; //внутреннее представление - 0x00000001
if(x<y){…} //сначала компилятор проинтерпретирует значение
переменной x как беззнаковое,
а потом сравнит два
значения без учета знака.
Результатом сравнения будет false
int a=-1;
unsigned int b=4294967295; //внутреннее
представление - 0xffffffff
if(a==b){…} //какое значение примет выражение
в данном случае?
Явное приведение типа (программистом)
Если программиста не устраивает результат неявных преобразований, то име-
ется возможность явно указать компилятору, как осуществлять преобразова-
ние. При явном приведении типов вся ответственность за результат ложится на
программиста, который должен учитывать перечисленные правила для про-
стых типов данных, а также особенности приведения типов для указателей.
Данные 79
Не рекомендуется без оправданной необходимости (особенно начинающим
программистам) пользоваться явным преобразованием типа (Б. Страуструп).
Необходимость возникает, например, в ситуациях, когда без явного приведе-
ния типа теряется точность вычисления выражений.
Явные преобразования типа в стиле Си:
int x=1, y=2;
double z = (double)x/y; //явное указание компилятору при
вычислении выражения привести значение целой
переменной x к типу double
ЗАМЕ ЧАНИЕ
Достаточно явно привести к старшему типу только один из операндов. Второй
операнд будет приведен к старшему типу по правилам неявного приведения
типов компилятором при выполнении операции деления.
Явные преобразования типа в стиле Си стали нежелательными после введе-
ния операторов приведения в новом стиле в С++, поэтому там, где необходи-
мо явное преобразование, рекомендуется пользоваться новыми операторами:
static_cast, reinterpret_cast, const_cast, dynamic_cast
или их сочетаниями (табл. 3.13).
Таблица 3.13. Новые операторы явного приведения типа
static_
cast <type>
(выражение)
reinterpret_
cast <type>
(выражение)
const_
cast <type>
(выражение)
dynamic_
cast <type>
(выражение)
механизм времени компиляции (преобразование осуществля-
ется на этапе компиляции)
механизм времени
выполнения
преобразование
с проверкой кор-
ректности преоб-
разования во вре-
мя компиляции
преобразование
без проверки
константное пре-
образование
преобразование
с проверкой во
время выполнения
осуществляет
преобразование
базовых типов,
void-указателей
и указателей для
классов, связанных
наследованием
осуществляет
преобразование
не связанных ме-
жду собой типов
аннулирует или,
наоборот, назна-
чает действие мо-
дификаторов
const и volatile
осуществляет пре-
образование ука-
зателей (ссылок)
для классов, свя-
занных наследова-
нием
80 Глава 3
ЗАМЕ ЧАНИЕ 1
Несмотря на то что использование оператора static_cast отнимает у про-
граммиста больше сил, чем использование старого оператора явного приведе-
ния типа (писать приходится больше), все же предпочтительнее использование
нового оператора static_cast, т. к. при этом компилятор следит не только за
возможностью, но и за безопасностью приведения типа. И если с точки зрения
компилятора приведение небезопасно, он выдает ошибку. Таким образом, по-
вышается надежность программного обеспечения.
ЗАМЕ ЧАНИЕ 2
Операторами const_cast и reinterpret_cast злоупотреблять не стоит. Эти
операторы позволяют отменить ограничения, что, в свою очередь, снижает на-
дежность программного обеспечения (т. е. компилятор в такой ситуации просто
"умывает руки"). Применять их можно, только отчетливо представляя послед-
ствия такого преобразования (см. разд. 6.1.9).
Примеры применения операторов явного преобразования.
Пример 1.
Следующие выражения на первый взгляд выглядят одинаково, но результат
получается разный:
int x=1;
double res1 = x/2; //т. к. оба операнда в выражении целого типа,
компилятор генерирует низкоуровневую команду
целочисленного деления idiv, в результате выполнения
которой дробная часть просто нигде не сохраняется,
а потом целый результат выражения (0) приводится к
типу double, поэтому res1=0
double res2 = static_cast<double>(x)/2; //тип переменной x явно
приводится к типу double. Так как в выражении
появился операнд старшего плавающего типа, второй
операнд будет приведен к тому же типу компилятором
неявно и деление будет сгенерировано плавающее –
fdiv, поэтому res2=0.5
Подумайте, почему значение res3 будет отличаться от res2?
double res3 = static_cast<double>(x/2);
Пример 2.
char x=-1; //0xff
int y = x; //значение короткой целой переменной x будет приведено
с учетом знаковости к размеру операнда y. В этом
случае y=0xffffffff (представление -1)
Данные 81
int z = static_cast<unsigned char>(x); //а в этом примере мы
заставили компилятор проинтерпретировать значение
переменной x как беззнаковое, поэтому компилятор
дополнит старшую часть нулями и в результате
y=0x000000ff (представление 255)
Используйте операторы явного приведения типа (а также побитовые опе-
раторы и операторы сдвига) для того, чтобы поменять местами младший
и старший байты знаковой целочисленной переменной
int x = значение;
x = … //напишите выражение
3.4.6. Тип wchar_t
Тип char используется для хранения ASCII кодов символов в диапазоне
0—127, а при 8-битовой кодировке коды в диапазоне 128—255 могут исполь-
зоваться для локализации приложений. С появлением UNICODE-кодировки
символов появилась потребность хранить расширенные (двухбайтовые) коды
символов, поэтому был введен новый тип: wchar_t.
Пример.
wchar_t cw = L‘Ф’; //компилятор зарезервирует для переменной cw
2 байта и занесет туда значение 0x424
(из диапазона кириллицы)
size_t n = sizeof(cw); //n=2
сw = L’\0’; //какое значение примет переменная сw?
wchar_t cw1 = ‘Ф’; //какое значение примет переменная cw1?
Подсказка: символьный литерал ‘Ф’ будет интерпретироваться компиля-
тором как signed char.
ЗАМЕ ЧАНИЕ
Не во всех реализациях wchar_t по умолчанию является встроенным типом. Это
означает, что без подключения заголовочных файлов компилятор выдаст ошибку.
В этом случае можно подключить заголовочный файл стандартной библиотеки
<string>, в котором типу wchar_t сопоставлен синоним unsiged short.
3.4.7. Тип bool и BOOL
Переменные логического типа используются для хранения результата вычис-
ления логического выражения и принимают одно из двух значений: true (со-
ответствует 1) или false (соответствует 0). В соответствии с новым стандар-
82 Глава 3
том С++ тип bool является встроенным типом, размером 1 байт, а для обозна-
чения логических значений используются ключевые слова true и false.
Примеры.
bool b = false; //переменной b будет присвоено нулевое значение
int x=-1, y=1;
b = (x<=y); //т. к. -1<1, b=true (а на самом деле компилятор
занесет в переменную b 1)
b=5; //т. к. выражение справа от знака равенства !=0 (что
соответствует true), b=true (а в переменную b
компилятор все равно занесет 1)
int n=b + 1; //при использовании логических переменных в
выражениях, компилятор вместо true подставляет 1,
а вместо false – 0. Поэтому n = 1+1 = 2
ЗАМЕ ЧАНИЕ
В Си и ранних не стандартизованных версиях С++ встроенного логического ти-
па не было, а вместо него в заголовочных файлах стандартной библиотеки был
определен тип BOOL как псевдоним типа int (см. разд. 3.5.1 — ключевое сло-
во typedef), а соответствующие значения TRUE и FALSE там же были опреде-
лены посредством макроподстановок (см. разд. 5.2.1 — директива препроцес-
сора #define).
В С++ рекомендуется пользоваться встроенным типом bool, хотя в большин-
стве случаев эти понятия являются взаимозаменяемыми. Основное отличие,
которое может в некоторых редких случаях вызвать проблемы, заключается
в размере переменной каждого типа:
int n = sizeof(bool); // 1 байт
int m = sizeof(BOOL); // 4 байта
3.5. Понятия объявления и определения
Программист дает имена переменным или функциям, а потом использует пе-
ременные в выражениях или вызывает функции. Когда компилятор встречает
в тексте программы любое имя, он должен знать, что имеется в виду под этим
именем (свойства переменной или функции), иначе компилятор не знает, как
поступать с таким именем и выдает ошибку. Поэтому в языке C/C++ исполь-
зованию любого имени должно предшествовать описание его свойств.
Объявление (declaration) — это инструкция компилятору, как использовать
указанное имя (описывает свойства переменной или функции). Объявлений
Данные 83
одного и того же имени может быть сколько угодно, главное — чтобы они
все были согласованы (т. е. одинаковы)!
Определение (definition) осуществляет привязку имени к сущности (к памяти
для данных или к коду для функций), т. е. специфицирует код или данные,
которые стоят за этим именем. В языке C/C++ существует правило единст-
венного определения. Это означает, что определение может быть только од-
но! Если программист это правило нарушает, то получает ошибку компо-
новщика о множественном определении.
ПР А В И Л О
В С/С++ нет умолчаний, поэтому любое имя должно быть объявлено, прежде
чем оно может быть использовано!
ЗАМЕ ЧАНИЕ
В большинстве случаях объявления и определения разнесены, но иногда эти
понятия совмещаются — например, для переменных зачастую определение
совмещено с объявлением.
3.5.1. Объявление переменной
Переменная — это не что иное, как именованная область памяти, используе-
мая для хранения информации (значения). Свойства переменной (рис. 3.4)
определяются:
􀂈 ключевыми словами, использованными при объявлении (обязательным
является указание типа переменной — int, double…, но могут быть упот-
реблены и другие ключевые слова, которые предоставляют компилятору
дополнительную информацию);
􀂈 контекстом определения (некоторые свойства переменных зависят от того
места в тексте программы, где находится определение переменной).
Встречая имя переменной в выражении, компилятор должен знать свойства
переменной с указанным именем, для того чтобы сгенерировать низкоуров-
невый код.
Объявление — это инструкция (statement), которая описывает свойства пере-
менной с указанным именем. Следует отметить, что язык C++ (а изначально
и Си) — это язык типизированный, т. е. разработанный таким образом, что
существует очень тесная связь между типами, переменными и инструкциями
для манипулирования этими переменными, а компилятор дотошно проверяет
правильность использования программистом переменной в любом выражении.
84 Глава 3
Встретив объявление переменной, компилятор:
􀂈 запоминает соответствие имени переменной и ее типа, что будет в даль-
нейшем использоваться:
• для контроля типов (можно ли использовать данную переменную в ука-
занном выражении);
• при преобразовании операций с данной переменной на языке высокого
уровня в конкретные машинные команды (разные в зависимости от ти-
па переменной);
􀂈 выделяет требуемый объем памяти для хранения значения переменной
данного типа (но только в том случае, когда объявление является одно-
временно и определением) и дальше ассоциирует ее имя с адресом выде-
ленного блока памяти.
Рис. 3.4
Примеры простых объявлений:
extern int iNumber; //это только описание свойств (объявление)
внешней переменной iNumber, определенной
Данные 85
в другом модуле. Компилятор никакой памяти
не резервирует!
char cSymbol; //а это объявление, совмещенное с определением.
Компилятор резервирует 1 байт
Приведенные объявления являются минимальными, в том смысле, что ком-
пилятору сообщается необходимый минимум информации, а он додумывает
все остальное. На самом деле в примерах опущены еще две необязательные
составляющие:
􀂈 если объявление совмещено с определением, то можно инициализировать
переменную требуемым значением;
􀂈 можно ввести в объявление ключевые слова (спецификаторы объявления),
которые не связаны с типом переменной, но, тем не менее, предоставляют
компилятору некоторую дополнительную информацию о переменной (т. е.
указания о том, как переменную следует использовать).
ЗАМЕ ЧАНИЕ 1
Если несколько переменных имеют один и тот же тип, то можно в объявлении
использовать список имен через запятую:
int iX1, iX2=1, iX3;
РЕ К О МЕ Н Д А Ц И Я
Кроме простейших объявлений, не следует использовать список. Не экономьте —
пишите объявление для каждой переменной, тогда в случае сложных объявле-
ний избавите себя от поиска непонятных ошибок.
ЗАМЕ ЧАНИЕ 2
В языке Си обязательным требованием является указание всех объявлений
переменных в начале того блока, в котором они используются (непосредствен-
но после открывающей фигурной скобки). В С++ таких ограничений нет, более
того, рекомендуется объявлять переменные по мере необходимости.
Ключевое слово typedef
Синтаксис:
typedef тип синоним_типа;
Объявления, начинающиеся с typedef — это указание компилятору на то,
что задаваемый в объявлении синоним_типа не будет именем новой перемен-
ной (не следует отводить память), а будет использован программистом в ка-
честве псевдонима указанного типа.
Ключевое слово typedef не создает новых типов данных, оно создает полез-
ные мнемонические синонимы (псевдонимы) для существующих типов.
86 Глава 3
Используется typedef в двух случаях:
􀂈 для упрощения сложных объявлений (назначается короткий синоним для
часто используемого типа):
typedef unsigned char BYTE; //вводит синоним типа, который
компилятор будет воспринимать точно так же,
как unsigned char
unsigned char cChar1; //создает переменную типа unsigned char
BYTE cChar2; //создает переменную типа unsigned char
􀂈 для устранения зависимостей, например, от платформы или среды (при-
мер приведен в разд. 5.5).
ЗАМЕ ЧАНИЕ 1
Нельзя комбинировать псевдонимы, определенные с помощью typedef, с дру-
гими типами:
typedef int MYINT;
unsigned MYINT my; //компилятор выдаст ошибку, т. к. он считает,
что за типом должно следовать имя переменной
ЗАМЕ ЧАНИЕ 2
Так как имена, вводимые typedef, являются синонимами, а не новыми типами,
то старые типы можно продолжать использовать наравне с их синонимами.
3.6. Способы использования переменных
и типы компоновки
Типичными являются следующие способы применения переменных про-
граммистом (рис. 3.5):
􀂈 первый — переменная используется внутри того блока кода, в котором
она объявлена (локально), при этом могут быть два варианта:
• (1а) — каждый раз при выполнении этого блока кода переменная зано-
во инициализируется;
• (1б) — переменная должна сохранять значение при следующем выпол-
нении блока;
􀂈 второй (2) — переменная используется только внутри одного файла, но
несколькими функциями. Поэтому, с одной стороны, это имя должно быть
доступно в любом месте данного файла, а с другой стороны — заносить
имена таких объектов в таблицу экспорта объектного модуля не нужно
(см. разд. 1.2.1) — эта переменная в других модулях использоваться не
будет;
Данные 87
􀂈 третий (3) — переменная используется разными единицами компиляции
(функциями, расположенными в разных файлах), поэтому необходимо за-
нести такое имя в таблицы экспорта/импорта соответствующих объектных
модулей.
Рис. 3.5
Со способами использования связаны понятия внутренней компоновки
(internal linkage), внешней компоновки (external linkage) и без компоновки
(no linkage):
􀂈 без компоновки (для первого способа — 1а, 1б). Не подлежат компоновке:
• все переменные, объявленные внутри любого блока без ключевого сло-
ва extern (такие имена являются уникальными в блоке);
• параметры функций;
88 Глава 3
􀂈 внутренняя (для второго способа — (2)). Справедливо для переменных,
объявленных вне фигурных скобок, но с ключевым словом static или за-
ключенных в неименованное пространство имен (такие имена уникальны
для данной единицы компиляции, поэтому конфликтов при использовании
одного и того же имени в разных файлах не возникает);
􀂈 внешняя (для третьего способа — (3)). Справедливо для переменных, оп-
ределенных вне фигурных скобок без спецификатора static. Понятие
внешней компоновки относится к тем именам, которые описывают в раз-
ных единицах компиляции одну и ту же переменную, поэтому все объяв-
ления одной и той же переменной должны быть согласованы! Задачей
программиста является обеспечение корректного объявления в каждом
файле всех имен, определенных в других файлах. Для того чтобы сооб-
щить компилятору, что переменная определена в другом модуле, ее нужно
описать (объявить) в файле-клиенте с ключевым словом extern.
3.6.1. Безопасная сборка проекта (type-safe linkage)
В языке С++ поддерживается безопасная сборка исполняемого файла с уче-
том типов (type-safe linkage). Этот механизм не допускает ситуаций, когда,
например, подлежащая внешней компоновке переменная в одном модуле
объявлена как int, а в другом используется как double. В языке Си такого
механизма защиты нет, поэтому там вполне возможна ситуация, представ-
ленная на рис. 3.6.
Рис. 3.6
Данные 89
Рис. 3.7
Защита от таких ситуаций основана на понятии декорирования имен.
Декорирование (decorating) — это способность компилятора хранить в объ-
ектном модуле информацию об имени переменной вместе с ее типом. На-
пример, если объявлена переменная int My; то компилятор помещает в объ-
ектный файл не просто имя My, а нечто, вроде My_int (рис. 3.7). Поэтому
My_int и My_double для компоновщика будут различаться.
Существуют две основные причины для декорирования имен компилятором:
􀂈 обеспечение безопасной сборки исполняемого модуля;
􀂈 поддержка перегрузки имен функций (см. разд. 8.5), что невозможно
в языке Си.
ЗАМЕ ЧАНИЕ
Следует отметить, что способы декорирования имен могут существенно разли-
чаться в разных компиляторах C++.
3.7. Размещение и время существования
переменных
С видами компоновки связана область памяти, в которой компилятор выде-
лит место для переменной (в С/С++ есть четыре основных способа разме-
щения переменных — табл. 3.14). В свою очередь, от того, где компилятор
90 Глава 3
выделит память, зависит время существования переменной. По истечении
этого интервала компилятор считает данный участок памяти свободным
и может занять его под значения других переменных.
Каким образом компилятор решает, в какой же области памяти разместить
переменную? В основном, исходя из контекста определения (того места
в тексте программы, где определена переменная). Дополнительную информа-
цию программист может предоставить компилятору посредством соответст-
вующих ключевых слов: static, auto, register.
Таблица 3.14. Способы размещения и время существования переменных
Способы размещения Время существования
Статическая память, в которую компилятор
помещает объект на все время выполнения
программы. Здесь располагаются глобальные
переменные, переменные из пространств имен
и статические переменные.
Переменная, размещаемая в статической па-
мяти, создается один раз (память выделяется
один раз перед началом выполнения), ее зна-
чением можно пользоваться на всем протяже-
нии выполнения программы. Такая перемен-
ная всегда имеет один и тот же адрес
Статическое
Переменные существуют на всем
протяжении выполнения про-
граммы
Автоматическая память, в которой по умол-
чанию располагаются переменные, опреде-
ленные внутри любого блока (программист
может явно определить их со спецификатором
класса хранения — auto), а также параметры
функций.
Для таких переменных компилятор выделяет
место в стеке. Память выделяется и освобож-
дается автоматически, отсюда и название (ее
также называют памятью в стеке). Следует
помнить, что после освобождения памяти, вы-
деленной под автоматическую переменную,
компилятор может использовать освобожден-
ную память для других целей.
Для автоматических переменных при каждом
последующем вызове функции может быть
использован совершенно другой участок
стека
Локальное
Можно считать, что переменные
создаются при входе в окружаю-
щий их определение блок и осво-
бождают память при выходе из
блока.
Замечание
На самом деле для всех локаль-
ных переменных функции компи-
лятор выделяет память один раз
при вызове функции, а освобож-
дает после завершения функции
(см. разд. 8.4)
Данные 91
Таблица 3.14 (окончание)
Способы размещения Время существования
Регистровая память. Можно порекомендо-
вать компилятору для повышения эффектив-
ности вычислений отвести для хранения зна-
чения переменной регистр (спецификатор
класса хранения — register). Это будет слу-
жить подсказкой компилятору — по возможно-
сти размещать переменную в регистре, с чем,
впрочем, современные компиляторы С++ и
сами успешно справляются. Следует отметить,
что такой способ оптимизации остается акту-
альным при программировании микроконтрол-
леров на языке Си
Локальное
Динамическая память, которую явно запра-
шивает программист для размещения пере-
менных по мере необходимости и которую сам
же освобождает, когда динамический объект
больше не нужен (см. разд. 6.4). Такая память
также называется кучей (heap).
Выделение памяти из кучи осуществляется
оператором С++ new (или функцией языка Си
типа malloc()), а освобождение — операто-
ром С++ delete (или функцией Си free()).
При загрузке программы в ОП система выде-
ляет также память и для кучи, если этой памя-
ти в процессе выполнения не хватает, опера-
тор new (или функция malloc()) запраши-
вает ее у диспетчера свободной памяти.
В результате динамического выделения памя-
ти программист получает для косвенного об-
ращения к объекту адрес объекта
Динамическое
Продолжительность существова-
ния определяется программи-
стом.
Замечание
Аккуратный программист не дол-
жен забывать освобождать захва-
ченную таким образом память,
иначе образуются "утечки памяти"
(см. разд. 6.4)
3.7.1. Ключевое слово static
Ключевое слово static — это указание компилятору выделить память для
переменной в постоянной (статической) области памяти. Существуют два
способа использования ключевого слова static.
Первый способ.
Спецификатор класса хранения static можно применить к переменной, оп-
ределенной внутри любого блока. Смысл введения такой переменной: ком-
92 Глава 3
пилятор позволит обращаться к ней только внутри блока, в котором она оп-
ределена, но существовать она будет до завершения программы (т. е. значе-
ние переменной будет сохраняться до следующего выполнения этого блока).
Спецификатор static при объявлении локальной переменной предписывает
компилятору:
􀂈 выделить память для такой переменной в постоянной (статической)
области;
􀂈 проинициализировать такую переменную только один раз (на момент на-
чала выполнения программы или при первом выполнении блока).
Например:
//выполнить_3_раза (i – номер итерации)
{
static int n1 = 0; //такое инициализирующее значение будет
сформировано компоновщиком и будет храниться в
соответствующем разделе исполняемого файла,
поэтому никакого низкоуровневого кода этой строке
соответствовать не будет! Существует и сохраняет
свое значение до завершения программы
static int n2 = выражение (например, i+4); //т. к.
выражение требуется вычислить при первом (только!)
выполнении этого блока, компилятор формирует
некоторый признак и проверяет этот признак при любом
выполнении данного блока. Инициализируется такая
переменная по правилам один раз, существует и
сохраняет свое значение до окончания программы
int n3 = 0; //а это обычная автоматическая переменная,
которая инициализируется при каждом выполнении блока
n1++;
n2++;
n3++;
//распечатать значения n1, n2, n3
}
//n1++; //ошибка: вне блока нельзя использовать любую
из локальных переменных
В результате выполнения данного фрагмента переменные примут значения,
представленные в табл. 3.15.
Данные 93
Таблица 3.15. Значения переменных для соответствующих итераций
Номер итерации (i) n1 n2 n3
0 1 5 1
1 2 6 1
2 3 7 1
Второй способ.
Спецификатор класса хранения static можно применить к переменной, объ-
явленной вне любых фигурных скобок. Если программист объявляет пере-
менную (или функцию) с ключевым словом static, он сообщает компилято-
ру, что собирается пользоваться этой переменной в нескольких функциях, но
только внутри данного файла (такие переменные не подвержены внешней
компоновке, сведения об их экспорте компилятором не формируются). Клю-
чевое слово static предотвращает ошибки компоновщика, т. к. каждая пере-
менная используется только внутри соответствующего файла (рис. 3.8).
Рис. 3.8
ЗАМЕ ЧАНИЕ
Использование static в языке С++ для внутренней компоновки считается ус-
таревшим. Новые стандарты языка предлагают употреблять для тех же целей
неименованные пространства имен (см. разд. 3.8.2).
94 Глава 3
3.8. Область видимости
переменной (scope)
Область видимости переменной контролируется компилятором. Это означа-
ет, что имена переменных могут быть использованы только в конкретных
областях текста программы. Такой фрагмент текста программы называется
областью видимости имени. Компилятор в каждый момент времени должен
ассоциировать указанное имя с конкретной областью памяти (если такая ас-
социация у него отсутствует, то он выдает ошибку о том, что имя не опреде-
лено). Существуют правила, по которым компилятор формирует области ви-
димости переменных.
С точки зрения программиста эти правила выглядят следующим образом:
􀂈 локальная область видимости. Переменные, определенные внутри любого
блока (в частности таким блоком может быть тело функции), называются
локальными. Область видимости локальной переменной простирается от
места определения до конца блока, содержащего определение:
{
…
int i;
i++;
}
i=1; //ошибка: неопределенное имя
ЗАМЕ ЧАНИЕ
Параметры функции тоже имеют локальную область видимости;
􀂈 область видимости — файл (File Scope). Любое имя, объявленное вне фи-
гурных скобок, обладает областью видимости файла. Компилятор позво-
лит использовать такое имя (оно видно компилятору) в любом месте дан-
ного файла после объявления и до конца файла без каких-либо
дополнительных ухищрений.
ЗАМЕ ЧАНИЕ
Имена, объявленные таким образом без ключевого слова static, часто назы-
вают глобальными. К таким именам можно обращаться из других файлов. Они
подвержены внешней компоновке;
􀂈 область видимости — пространства имен (namespaces) — относительно
новое средство языка С++ ограничения области видимости глобальных
имен (см. разд. 3.8.2);
Данные 95
􀂈 область видимости — тело функции (Function scope). Этой областью ви-
димости обладают только метки (см. разд. 4.4). Их можно использовать
в любом месте функции, но извне функции они не видны:
void f()
{
goto LABEL;
…
LABEL: //метка
…
goto LABEL;
}
􀂈 область видимости имен параметров прототипа функции (см. разд. 8.2)
распространяется только на объявление функции;
􀂈 область видимости членов структуры объединения, класса разрешается
посредством объектов или указателей на объекты (см. разд. 9.3, 9.11).
РЕ К О МЕ Н Д А Ц И Я ( БЬЕ Р Н СТ Р АУСТ Р УП)
В С++ не объявляйте локальную переменную, пока она вам действительно не
потребуется (это сделает вашу программу более читабельной)! При объявле-
нии по возможности инициализируйте локальные переменные! Неинициализи-
рованные переменные провоцируют ошибки!
3.8.1. Скрытие (замещение) имени переменной
Иногда случайно (реже специально) программист называет одним и тем же
именем две разные переменные. Объявление имени в блоке скрывает пере-
менную с тем же именем в охватывающем блоке или глобальную перемен-
ную. После выхода из блока имя восстанавливает свой прежний смысл. Пра-
вила перекрытия областей видимости продемонстрированы в листинге 3.9.
Листинг 3.9. Замещение имени переменной
int X; //глобальная переменная
int main()
{
X = 1; //компилятор ассоциирует имя X с глобальной переменной
int X; //объявление локальной переменной с таким же именем
как и у глобальной. С этого момента и до конца функции
имя локальной переменной скрывает имя глобальной
96 Глава 3
X = 2; //локальной переменной присваивается 2
{
int X; //во вложенном блоке объявляется еще одна локальная
переменная с тем же именем. С этого момента и до
конца блока имя внутренней переменной скрывает не
только имя глобальной, но и имя внешней локальной
переменной
X = 3; //внутренней локальной переменной присваивается 3
} //здесь заканчивается область видимости внутренней локальной
переменной, и имя X восстанавливает тот смысл, который был
у него перед началом блока
X = 4; //внешней локальной переменной присваивается 4
}
Компилятор никогда не позволит определить в одной области видимости не-
сколько переменных с одним и тем же именем (листинг 3.10).
Листинг 3.10. Попытка определения двух переменных с одним и тем же именем
в одной области видимости
{
int value;
…
float value; //ошибка: переменная с таким именем в данной
области видимости уже существует!
{
float value=1.1; //a здесь ошибки не будет, т. к.
внутренняя локальная переменная
перекрыла область видимости
внешней локальной переменной
value++; //инкремент внутренней переменной
}
Оператор разрешения области видимости
В С++ (в языке Си такой возможности не было) к скрытому глобальному
имени можно обратиться с помощью оператора разрешения области видимо-
сти — "::". Пример приведен в листинге 3.11.
Данные 97
Листинг 3.11. Оператор разрешения области видимости
int X;
int main()
{
X = 1; //компилятор ассоциирует имя X с глобальной переменной
int X; //внешняя локальная переменная "перекрыла" область
видимости глобальной
::X = 100; //указание компилятору присвоить значение 100
глобальной переменной
X = 2; //а здесь компилятор под именем X "видит" внешнюю
локальную переменную
{
int X; //внутренняя локальная переменная перекрыла область
видимости как глобальной, так и внешней локальной
::X = 200; //поскольку :: разрешает только глобальную
область видимости, то модифицирована будет
глобальная переменная
X = 3; //под именем X видит внутреннюю локальную
переменную
}
X = 4; //внешняя локальная переменная восстановила свой контекст
}
ЗАМЕ ЧАНИЕ
Не существует способа обращения к скрытой локальной переменной!
3.8.2. Пространства имен — namespace
Если переменная определена вне фигурных скобок без ключевого слова static,
то компилятор по умолчанию считает, что такая переменная является гло-
бальной (т. е. ее можно использовать в других модулях). При этом возникают
следующие проблемы:
􀂈 имена всех глобальных переменных и функций (их много!) находятся
в единой (глобальной) области видимости:
• имена ваших собственных глобальных переменных и функций;
• имена, предоставляемые стандартной библиотекой (такие простые
имена как copy, sort, find, set);
• глобальные имена вашего коллеги, работающего над тем же проектом;
98 Глава 3
􀂈 глобальные имена, логически относящиеся к одному понятию, оказыва-
ются никаким образом не связанными друг с другом.
Для того чтобы упорядочить этот "глобальный хаос", состоящий в том, что
глобальных имен оказывается слишком много и они относятся к объектам,
логически не связанным друг с другом, было введено понятие пространств
имен (стандарт языка С++ 1998). На рис. 3.9 приведен простой пример воз-
никновения конфликта.
Рис. 3.9
В такой ситуации при сборке проекта компоновщик выдаст ошибку: "множе-
ственное определение имени", хотя под этим именем по замыслу програм-
миста имеются в виду две совершенно разных переменных.
Чтобы избежать таких ситуаций, в современных версиях языка С++ введено
понятие пространства имен — namespace. Пространство имен является сред-
ством ограничения области видимости. Для того чтобы поместить несколько
имен в одно пространство имен, надо написать:
namespace имя_пространства_имен{ объявления_переменных_или_функций; }
Каждое имя становится уникальным в своем пространстве имен. Объявив
переменную или функцию в пространстве имен, к ним можно (без специаль-
ных ухищрений) обратиться только посредством явного указания имени про-
странства в качестве квалификатора и оператора разрешения области види-
мости — "::", т. е. все объекты, принадлежащие одному пространству имен,
имеют имена, состоящие из двух частей:
имя_пространства::имя_переменной_или_функции
Данные 99
СЛ Е ДСТ ВИЕ
При заключении имени в пространство имен, глобальные переменные (и функции)
могут иметь одинаковые имена даже в пределах одного файла, но, естествен-
но, такие преднамеренные дублирования имен вряд ли полезны при програм-
мировании. Скорее namespace — это средство от случайного дублирования
имен.
Конфликтную ситуацию, приведенную на рис. 3.9, можно было бы разре-
шить способом, который иллюстрируется листингом 3.12.
Листинг 3.12. Использование пространств имен для ограничения области
видимости глобальных переменных
namespace One{ int version = 1;}
namespace Second{ int version = 2;}
int main()
{
int n1 = One::version; //n1=1
int n2 = Second::version; //n2=2
}
Особенности использования пространств имен:
􀂈 пространство имен позволяет не только ограничить доступ к именам из-
вне, но и сгруппировать имена по некоторому критерию (например, имена
переменных и функций, относящихся к одной области применения, или
все имена, входящие в разрабатываемые отдельным программистом моду-
ли большого программного проекта). Например:
namespace Version
{
int currentVersion;
int previousVersion;
void SetVersion(int ver); //причем внутри такой функции можно
обращаться к переменным currentVersion и
previousVersion, а также вызывать другие функции,
заключенные в данное пространство имен без
префикса Version
int GetVersion();
...
}
􀂈 в сущности понятия, заключенные в пространство имен, являются гло-
бальными, а сами пространства просто ограничивают их область видимости.
100 Глава 3
Поэтому для переменных из пространств имен справедливы те же прави-
ла, что и для обычных глобальных переменных — такие переменные
должны быть определены только один раз. А для того чтобы можно было
пользоваться такими переменными в других модулях, нужно описать ком-
пилятору их свойства посредством ключевого слова extern. При этом
необходимо уточнить, что используемая внешняя переменная заключена
в пространство имен (рис. 3.10).
Рис. 3.10
ЗАМЕ ЧАНИЕ
Объявление внешних понятий корректнее помещать в специальные, предна-
значенные для описаний заголовочные файлы (см. разд. 5.6);
􀂈 пространства имен обладают свойством открытости. Это означает, что
программист может дополнять пространства имен членами по мере необ-
ходимости (рис. 3.11). Поэтому возможно разносить понятия, относящие-
ся к одному пространству имен, по разным файлам (на свойстве открыто-
сти основано постепенное включение имен стандартной библиотеки);
Рис. 3.11
Данные 101
􀂈 использование псевдонимов пространств имен. Короткие имена про-
странств рано или поздно приведут к конфликту (рис. 3.12). Длинные
имена непрактичны и рано или поздно программисту надоест писать та-
кой длинный префикс, поэтому можно сопоставить длинному имени ко-
роткий псевдоним и пользоваться им до завершения области видимости
псевдонима.
{
namespace ver = Version_beta_12345; //псевдоним
ver::currentVersion++; //до конца блока можно пользоваться
псевдонимом ver для обращения к членам пространства
имен Version_beta_12345
}
Рис. 3.12
Директива using
Ограничение доступа было введено для повышения надежности программ.
Обеспечение безопасности имеет свою оборотную сторону: для каждого об-
ращения к объекту из пространства имен программисту приходится писать
префикс (имя_пространства::). Со временем это начинает раздражать. Если
имя, требующее квалификатора, используется часто, довольно утомительно
каждый раз писать этот квалификатор. Такое неудобство можно устранить
с помощью директивы using, которая делает доступными имена из данного
пространства имен, как если бы они были объявлены глобально.
Существуют две формы директивы:
􀂈 directive — делает все члены пространства доступными, т. е. с ними мож-
но работать как с обычными глобальными понятиями (без указания пре-
фикса):
using namespace имя_пространства;
102 Глава 3
􀂈 declaration — делает видимым только указанный член пространства
имен:
using имя_пространства::имя_члена_пространства;
Например:
{
//currentVersion++; //ошибка: неопределенный
идентификатор currentVersion
using namespace One;
//или using One::currentVersion;
currentVersion++; //корректно
}
//currentVersion++; //ошибка: неопределенный
идентификатор currentVersion
РЕ К О МЕ Н Д А Ц И Я Б. СТ Р А У С Т Р УП А
Если вы хотите пользоваться именами из определенного пространства имен во
всех функциях файла, конечно, можно вынести директиву using до первой от-
крывающей фигурной скобки, но по возможности разрешение таких имен стоит
ограничивать блоком использования.
Специфика использования директивы using:
􀂈 одно пространство имен можно сделать видимым из другого с помощью
директивы using способом, представленным в листинге 3.13.
Листинг 3.13. Использование директивы using в ситуации,
когда одно пространство имен оперирует понятиями из другого пространства
namespace A{ int a = 2;}
namespace B{
int b=1;
using namespace A; //делает доступными все имена из A, т. е.:
а) в функциях, заключенных в пространство имен B,
можно обращаться ко всем объектам пространства A
без префикса
б) ко всем именам A можно обращаться посредством B::
//или using A::a; //если требуется иметь доступ только к какому-то
одному имени из A
void F(){a=5;} //(a) можно обращаться без префикса
}
Данные 103
int main()
{
//разрешили посредством внешнего пространства видеть внутреннее:
B::b=1;
B::a = 2; //(б)можно обращаться посредством B::
//Как работает директива using:
using namespace B; //разрешение видеть (как глобальные)
все имена как из B, так и из A
//или
using B::b;
using B::a;
//в обоих случаях теперь можно обращаться к именам пространств А и B
без префикса
b=22;
a=33;
}
􀂈 директива using разрешает компилятору видеть имена из пространства как
глобальные. В такой ситуации могут возникнуть конфликты (листинг 3.14).
Листинг 3.14. Пример конфликта при использовании директивы using
namespace A{int a=1;} //переменная заключена в пространство имен
int a=2; //обычная глобальная переменная
int main()
{
//Пока не разрешена область видимости имен A, компилятор
однозначно видит под именем a глобальную переменную
a++; //обращение к глобальной переменной
::a++; //или то же самое посредством спецификатора
разрешения области видимости
A::a++; //обращение к переменной из пространства имен
using namespace A;
//a = 5; //ошибка: двусмысленный символ (ambigious symbol).
Возникла неоднозначность.
::a = 5; //OK
A::a = 5; //OK
}
104 Глава 3
􀂈 использование вложенных пространств имен:
• без директивы using (листинг 3.15);
Листинг 3.15. Использование вложенных пространств без директивы using
namespace Out{ //внешнее пространство
int outer;
namespace In{ //внутреннее пространство
int inner;
}
void f(){outer++; In::inner++;} //без using компилятору нужно
явно указать префикс In::inner
}
int main()
{
Out::outer=1;
Out::In::inner=2;
…
}
• с использованием директивы using (листинг 3.16) (цель — обеспечить
видимость членов внутреннего пространства посредством внешнего
пространства);
Листинг 3.16. Вложенные пространства и директива using
namespace Out{
int outer;
namespace In{
int inner;
}
using namespace In;
void f(){outer++; inner++;}//префикс не нужен!
}
int main()
{
Out::outer=1;
Out::inner=2; //теперь можно обращаться к членам внутреннего
Данные 105
пространства имен посредством имени внешнего
пространства
{
using namespace Out; //а если разрешить видимость
внешнего пространства
outer=1;
inner=2; //то члены внутреннего пространства тоже
становятся видимыми глобально
}
􀂈 если видимость переменной из пространства имен разрешена директивой
using, то по правилам замещения имен объявление локальной переменной
с тем же именем скрывает переменную из пространства имен (листинг 3.17);
Листинг 3.17. Правила замещения имен и директива using
namespace A{int a=1;}
int main()
{
using namespace A; //разрешили глобальную видимость
a++; //можем обращаться без префикса
int a=3; //локальная переменная с тем же именем перекрывает
видимость переменной из пространства имен
a++; //увеличивается значение локальной переменной
A::a++; //а переменную из пространства имен теперь можно
увидеть только посредством префикса
::a++; //или так
}
􀂈 специфика использования declaration-формы директивы using (листинг 3.18).
Листинг 3.18. Пример возникновения конфликта при использовании
declaration-формы директивы using
namespace A{int a=1;}
int main()
{
using A::a; //разрешает глобальную видимость только a
a++; //теперь можно обращаться к переменной без префикса
106 Глава 3
//int a=3; //а теперь при попытке объявления локальной переменной
с тем же именем компилятор выдаст сообщение
об ошибке: повторное определение (redefinition)
}
Пространство имен стандартной библиотеки
Так как стандартная библиотека изобилует простыми именами, то для пре-
дотвращения дублирования таких имен согласно стандарту все сервисы стан-
дартной библиотеки заключены в пространстве имен с именем std.
Примеры использования средств ввода/вывода стандартной библиотеки:
􀂈 без директивы using:
{
std::cout<<”Input x:”<<std::endl;
int x;
std::cin>>x;
}
􀂈 c помощью директивы using:
• все имена из пространства имен std делаем видимыми глобально:
{
using namespace std; //все имена из пространства имен std делаем
видимыми глобально
cout<<”Hello, World!” <<endl; //теперь префикс не нужен
}
• делаем видимым глобально только отдельные члены:
{
using std::cout; //только cout делаем видимым глобально
using std::endl; //endl - аналогично
cout<<”Hello, World!” <<endl; //префикс не нужен
}
Неименованные пространства имен
Неименованные пространства имен применяют для того, чтобы ограничить
использование переменной или функции только данным модулем. Таким об-
разом, внутри файла, содержащего безымянное пространство, к членам этого
пространства можно обращаться напрямую без префикса, но вне этого файла
такие идентификаторы использовать невозможно (рис. 3.13).
Данные 107
1.cpp
namespace { int iI; }
void Func1()
{
iI++;//OK
}
voidFunc2()
{
iI--; //OK
}
2.cpp
namespace { extern int iI; }
void Func3()
{
iI++;
}
1.obj 2.obj
Компилятор: OK
Компоновщик:
ошибка: не определена переменная iI
Ограничение использования переменной файлом посредством
неименованного пространства имен
Рис. 3.13
Для переменных, заключенных в неименованные пространства имен спра-
ведливы правила замещения глобальных имен локальными (листинг 3.19).
Листинг 3.19. Неименованные пространства имен и правила разрешения
области видимости
namespace {int a=100;}
int main()
{
a++; //для того, чтобы обратиться к переменной, заключенной
в неименованное пространство имен, префикс не нужен
int a=1; //локальная переменная перекрывает область видимости
переменной из неименованного пространства
a++; //обращение к локальной переменной
::a++; //а так можно обратиться к переменной из пространства имен
}
РЕ К О МЕ Н Д А Ц И Я Б. СТ Р А У С Т Р УП А
Для ограничения области видимости переменных (или функций) пределами од-
ного файла предпочтительнее заключать их в неименованное пространство
имен, нежели использовать ключевое слово static.
108 Глава 3
3.9. Инициализация переменных
3.9.1. Явная инициализация переменных
(программистом)
Большие неприятности могут ожидать программиста, если он небрежно об-
ращается с переменными, в частности — если забывает присваивать им зна-
чения перед использованием. Хороший компилятор выдает предупреждение,
когда встречает непроинициализированную переменную, а некоторые ком-
пиляторы в Debug-версии приложения вставляют проверки на использование
таких значений. Инициализация означает присваивание значения при опре-
делении, например:
int iNumber = 5;
char cSymbol = 'A';
РЕ К О МЕ Н Д А Ц И Я
Не объявляйте локальную переменную, пока она вам не потребуется, чтобы
можно было сразу же ее проинициализировать (это уменьшит вероятность опе-
раций над случайным значением).
3.9.2. Неявная инициализация переменных
(компилятором)
Если при определении программист явно не присвоил переменной какого-
либо значения, компилятор может проинициализировать ее сам. Правила не-
явной инициализации:
􀂈 переменные со статическим временем существования (глобальные, в про-
странствах имен и статические) инициализируются нулем (в прологе при-
ложения, который предоставляется стандартной библиотекой);
􀂈 автоматические переменные не инициализируются (т. е. имеют случайное
значение той области стека, которую компилятор выделил под автомати-
ческую переменную);
ЗАМЕ ЧАНИЕ
В большинстве реализаций в Debug-версии проекта используемая под автома-
тические переменные область стека заполняется значениями 0xcccccccc, что
позволяет при отладке выявлять использование неинициализированных пере-
менных.
Данные 109
􀂈 динамические переменные не инициализируются (т. е. имеют случайное
значение той области памяти, которая была выделена под объект в куче).
ЗАМЕ ЧАНИЕ
В большинстве реализаций в Debug-версии проекта перед выполнением про-
граммы область heap заполняется значениями 0xcdcdcdcd, что также позволя-
ет выявить значение неинициализированных переменных в куче.
3.10. Модификаторы const и volatile
Посредством ключевых слов const и volatile (или cv-модификаторов) про-
граммист предоставляет компилятору дополнительную информацию о том,
какие ограничения следует соблюдать при использовании таких объектов.
3.10.1. Ключевое слово const
Ключевое слово const в С/С++ в разных контекстах имеет разный смысл!
Применительно к переменным объявление с ключевым словом const означа-
ет, что переменную можно использовать только для чтения (она должна быть
обязательно проинициализирована при определении). Любая попытка впо-
следствии изменить ее значение вызовет ошибку компиляции. Например:
const int nMax=1000; // корректно
int nX = nMax; // корректно
const int nMin; //ошибка: нет инициализатора
nMax = 2000; //ошибка: нельзя модифицировать константу
Подумайте: является ли такое объявление корректным?
extern const int nMin;
Специфика определения переменных с ключевым словом const:
􀂈 инициализирующее значение компилятор знает на этапе компиляции:
const int N = 1; //инициализирующее значение константа
Оптимизирующий компилятор С++ (в зависимости от дальнейшего ис-
пользования такой переменной) память для нее отводить не будет,
а встречая это имя в выражении, будет просто подставлять ее значение.
В языке Си таких оптимизаций компилятор не делает;
􀂈 в качестве инициализирующего значения используется выражение:
const int M = выражение;
110 Глава 3
Если выражение невозможно вычислить на этапе компиляции, компиля-
тор отведет для такой переменной память, вычислит значение, присвоит
этой переменной результат, но в дальнейшем разрешит использовать ее
только для чтения.
3.10.2. Ключевое слово volatile
Модификатор volatile означает, что переменная может изменяться не только
текущей программой, но, возможно, и где-то вне программы (например, об-
работчиком прерывания). Описание переменной как volatile информирует
компилятор о том, что в процессе вычисления переменная может подверг-
нуться изменениям извне, поэтому всякий раз, встречая в выражении это имя,
компилятор должен заново считывать ее значение из памяти.
СЛ Е ДСТ ВИЕ
Запрещается для такой переменной распределять регистр и проводить некото-
рые виды агрессивной оптимизации.
Например, пусть наша программа состоит из двух функций, которые могут
выполняться параллельно (одновременно).
extern volatile int nTicks;
//объявлениесчетчика тиков
таймера
const int INTERVAL = 1000;
int main()
{
…
nTicks = 0;
while(nTicks < INTERVAL);
//ожидание истечения интервала.
Существенным является
считывание значения из памяти
на каждой итерации
//Продолжение выполнения
функции main()
…
}
volatile int nTicks;
//определениесчетчика тиков
таймера
обработчик_прерываний_от_таймера()
{
n T icks++; //увеличение значения
счетчика тиков на единицу
}
main.cpp handler.cpp
Использование ключевого слова volatile
Рис. 3.14
Данные 111
Первая функция main(), дойдя до определенного места, должна приостано-
вить свое выполнение на интервал времени, заданный константой INTERVAL
(для этого она проверяет значение общей переменной nTicks).
Вторая функция является специально оформленным обработчиком прерыва-
ния от системного таймера, ее задачей является подсчет тиков таймера (обра-
ботчик, получая управление, просто инкрементирует общую глобальную пе-
ременную nTicks).
При таком взаимодействии функций важно, чтобы компилятор для проверки
значения переменной nTicks на каждой итерации цикла считывал значение из
памяти (а не держал его на регистре для оптимизации вычислений), т. к. зна-
чение переменной мог изменить обработчик прерываний (рис. 3.14).
ЗАМЕ ЧАНИЕ
Объект может быть одновременно const и volatile.
Например:
extern const volatile clock; //в этом случае наша программа не
может изменять значение, а извне эта переменная
может быть изменена!
Глава 4
Инструкции (statements) С/С++
4.1. Общая информация
об инструкциях
Программа — это последовательность инструкций. Инструкция C/С++
(statement) — это элемент программы, содержащий имена, операторы и раз-
делители и заканчивающийся точкой с запятой (рис. 4.1).
Рис. 4.1
Инструкции выполняются в том порядке, в котором они встречаются в про-
грамме, кроме тех случаев, когда порядок нарушается по замыслу програм-
миста опять же с помощью инструкций (инструкций выбора, цикла или без-
условного перехода).
Признаком конца инструкций является точка с запятой (;) (ограничитель обя-
зателен!).
Разделителями отдельных частей инструкции являются пробелы и табуляции.
В большинстве случаев количество пробелов или табуляций не имеет значе-
ния — препроцессор лишние проигнорирует.
Перечень инструкций приведен в табл. 4.1.
114 Глава 4
Таблица 4.1. Инструкции С/С++
Инструкция Пояснение Назначение
Составная
(compound
statement)
Группа инструкций, заключенная
в фигурные скобки { } или блок
кода
Для выделения логически
связанных между собой инст-
рукций.
Замечание
Группа { } может в частности
не содержать вообще никаких
инструкций
Объявление
(declaration
statement)
Описание свойств переменной,
функции или пользовательского
типа
Объясняет компилятору, ка-
ким образом он должен об-
ращаться с вводимым по-
средством объявления
именем
Выражение
(expression
statement)
Содержит последовательность
операндов и операторов для
действий над этими операндами
Может содержать как ариф-
метические и логические вы-
ражения, так и вызовы функ-
ций.
Замечание: все действия,
предусмотренные в выраже-
нии, гарантированно выпол-
няются, прежде чем начина-
ется выполнение следующей
инструкции
Пустая
инструкция
(null statement)
Инструкция, состоящая только
из ограничителя — точки с за-
пятой (;)
Применяется в том случае,
когда синтаксис С/C++ требу-
ет наличия инструкции, но на
самом деле никаких действий
не предполагается
Выбора (selection
statement)
if (условие) инструкция [else
инструкция];
switch (условие) инструкция;
Средство для выполнения
блока кода в зависимости от
выполнения условия
Цикла
(iteration
statement)
while (условие) инструкция;
do инструкция while (условие);
for (инициализирующая_
инструкция; условие;
выражение) инструкция;
Средство для многократного
выполнения инструкции.
Замечание: в частности, ко-
личество итераций может
быть равно 0
Безусловного
перехода
(jump statement)
break;
continue;
goto идентификатор;
Способ прекращения после-
довательного выполнения
инструкций и передачи
управления в предопреде-
ленное место программы
Инструкции (statements) С/С++ 115
Таблица 4.1 (окончание)
Инструкция Пояснение Назначение
Возврата
(return
statement)
return выражение; Формирование возвращаемо-
го функцией значения и воз-
врат управления
Помеченная
(labeled
statement)
идентификатор: инструкция;
case константа : инструкция;
default : инструкция;
Для того чтобы передать
управление на конкретную
инструкцию, она должна быть
помечена
Обработки
исключений
try {инструкция
throw
catch
Механизм выявления и обра-
ботки исключительных ситуа-
ций в С++
4.2. Инструкции выбора (условия)
Любой язык программирования должен иметь возможность условного ветв-
ления. В некоторых языках для этого есть конструкция if-then-else.
Язык С/С++ для формирования условий предоставляет инструкции: if, if…else
и switch.
4.2.1. Инструкции if, if…else
Синтаксис:
if(условие){true_инструкция} //если условие = true
[else {false_инструкция}] // если условие = false
Если условие принимает значение true, выполняется true-инструкция (воз-
можно единственная), в противном случае — false-инструкция, если она ука-
зана (рис. 4.2).
Специфика использования:
􀂈 в языке С/С++ нет ключевого слова then. Выражение, следующее за усло-
вием, является аналогом then-части. Более того, простейшая форма инст-
рукции не требует даже и else-части. Например, пусть требуется вычис-
лить абсолютное значение переменной x:
if(x<0) x=-x;
􀂈 в качестве условия может быть не только "честное" условное выражение,
в котором участвуют логические операторы и операторы отношения (==,
!=, <, <=, >, >=, &&, ||, !), а результатом является true или false, но и любое
арифметическое выражение, например:
if(x!=0){...} эквивалентно if(x){...};
116 Глава 4
Рис. 4.2
􀂈 true-инструкция и false-инструкция, в свою очередь, сами могут быть ин-
струкциями if, образуя вложенные условные выражения.
Пример.
Пусть в зависимости от значения x переменная y принимает значения,
представленные на рис. 4.3.
Один из возможных способов решения:
if(x>0) y=1;
else if(x==0) y=0;
else y=-1;
Рис. 4.3
Инструкции (statements) С/С++ 117
ЗАМЕ ЧАНИЕ
В таких вложенных конструкциях компилятор сопоставляет каждый else с по-
следним встретившимся (ближайшим) if, не имеющим своего else. Так как ин-
струкция else не обязательна, то если хотите, чтобы компилятор правильно
понял ваш замысел — ставьте фигурные скобки! В табл. 4.2 продемонстриро-
ван фрагмент кода с фигурными скобками и без них, а также результат его вы-
полнения.
Таблица 4.2. Результаты выполнения инструкции if…else
Некорректно Корректно
y=1;
if(x>=0)
if(x==0) y=0;
else y=-1;
y=1;
if(x>=0)
{ if(x==0) y=0;}
else y=-1;
при x>0 y=-1,
(компилятор соотнесет else ближайшему if)
при x>0 y=1
􀂈 возможно объявление переменной в условиях. Область видимости такой
переменной распространяется на обе ветви if…else.
Пример.
int NN = 1;
if(int tmp = func()) //функция может вернуть любое значение,
в частности 0. Возвращенное значение
присваивается временной переменной tmp
и используется компилятором для
формирования условия
{//true-инструкция (tmp!=0)
NN /= tmp; //деление безопасно
}else
{
NN = <что-нибудь другое>; //на ноль делить нельзя!!!
}
􀂈 часто возникает необходимость сравнения результата выражения с набо-
ром целочисленных констант.
Пример.
if(x==1)
...//выполнить действие 1
else if(x==2)
118 Глава 4
...// выполнить действие 2
else if(x==3)
...// выполнить действие 3
else ...//если значение не совпало ни с одним
из перечисленных
ЗАМЕ ЧАНИЕ
Такую же конструкцию можно получить с помощью инструкции switch (гораздо
удобнее и структурнее!).
4.2.2. Переключатель — switch
На практике часто возникает задача выбора одного из вариантов действий
в зависимости от результата вычисления выражения. Это можно сделать с по-
мощью вложенных инструкций if...else (см. разд. 4.2.1). Однако более на-
глядно (структурировано) такие задачи решаются посредством инструкции
switch. Приведенный в предыдущем разделе пример можно переписать:
switch(выражение)
{
case 1:
...//выполнить действие 1
break;
case 2:
...//выполнить действие 2
break;
case 3:
...//выполнить действие 3
break;
default:
...//действие по умолчанию
}
Программист посредством ключевого слова case предоставляет компилятору
набор констант (это точки передачи управления). Компилятор вычисляет выра-
жение и, в случае совпадения результата выражения с одной из констант, переда-
ет управление на инструкцию, помеченную ключевым словом case (рис. 4.4).
Существенно:
􀂈 в скобках программист приводит выражение, которое в конечном итоге
сводится к целому типу, например:
switch(sizeof(x)){…}
Инструкции (statements) С/С++ 119
Рис. 4.4
􀂈 точки, куда передается управление, помечены ключевым словом case,
каждой такой метке сопоставлена константа для сравнения со значением,
вычисленным в скобках;
ЗАМЕ ЧАНИЕ
Для задания таких констант удобно использовать enum!
􀂈 обычное использование инструкции case предполагает, что выполняется
только данная ветвь программы, поэтому эта ветвь должна каким-то обра-
зом завершиться. Для завершения выполняемой ветви используется: или
инструкция break, которая передает управление на первую инструкцию,
следующую за switch (см. рис. 4.4), или инструкция return, которая воз-
вращает управление вызвавшей функции. Возможен и другой способ пре-
рывания последовательного выполнения переключателя;
􀂈 при отсутствии инструкций break или return последовательно выполняет-
ся следующая ветвь переключателя. Иногда бывают случаи, когда про-
120 Глава 4
граммист намеренно из одной ветви передает управление следующей вет-
ви, помеченной другим ключевым словом case:
case 'A':
case 'a':
инструкция; //сюда компилятор передаст управление, если
значение выражения совпало с кодом ‘a’ или ‘A’
􀂈 если значение выражения не совпало ни с одной из констант, выполняется
ветвь, помеченная ключевым словом default (таким образом программист
может предусмотреть действие по умолчанию);
ЗАМЕ ЧАНИЕ 1
Присутствие ветви default необязательно. Если default отсутствует, управ-
ление передается на первую инструкцию после закрывающей скобки переклю-
чателя.
ЗАМЕ ЧАНИЕ 2
Ветвь default может быть в любом месте переключателя switch (не обяза-
тельно в конце);
􀂈 в переключателе можно объявлять и использовать локальные переменные,
при этом лучше локализовать использование таких переменных в соответ-
ствующей ветви переключателя посредством ограничения области види-
мости (фигурных скобок). Например:
switch(x)
{
case 1:
int a; //без инициализации компилятор позволит объявить
переменную. Ее область видимости распространяется до
закрывающей фигурной скобки переключателя (т. е. можно
пользоваться во всех нижележащих ветвях)
{
int b=1; //в этом месте без фигурных скобок
компилятор выдаст сообщение об ошибке
//Замечание. Если вы используете инициализированные локальные
переменные, то фигурные скобки обязательны, т. к.
иначе область видимости переменной b распространялась
бы на все нижерасположенные ветви переключателя и
тогда появилась бы возможность использования
неинициализированного значения b в других ветвях
переключателя!
Инструкции (statements) С/С++ 121
//используем b
} //конец области видимости b
break;
case 2:
...
default:
...
} //конец области видимости a
􀂈 перед закрывающей фигурной скобкой переключателя после метки (case
или default) должна быть хотя бы одна пустая инструкция (;), иначе ком-
пилятору некуда передавать управление:
switch( x )
{
…
default: //ошибка
case 5: //ошибка
}
switch( x )
{
…
default: ;// OK!
//case 5: ;// OK!
}
􀂈 инструкция switch может быть вложенной:
int x,y;
enum {RED,GREEN,BLUE};
enum {ONE=1, TWO};
//Вычисление значения переменной x
switch( x ) //внешний переключатель
{
case ONE: //при значении x = ONE требуется выполнить разные действия
в зависимости от значения переменной y
switch( y ) //вложенный переключатель
{
case RED:
...
122 Глава 4
break;
case GREEN:
...
break;
...
} //конец вложенного переключателя
break;
case TWO
...
break;
default:
...
} //конец внешнего переключателя
4.3. Инструкции цикла
Макс наблюдает картину: сидящий в клетке
попугай говорит "кис-кис", находящаяся ря-
дом кошка подходит к клетке, пытается
просунуть морду между прутьев, получает
клювом по носу, с криком "мяууууу" отпры-
гивает на метр назад, далее попугай говорит
"кис-кис"...
Уже четвертая итерация цикла, однако...
Любой цикл — это возможность повторения блока кода (итерация). Без ите-
раций никакой язык программирования особой ценности не представляет.
Циклы в языке С/С++ можно реализовать инструкциями трех видов:
􀂈 for;
􀂈 while;
􀂈 do…while.
Каждая из этих инструкций, в свою очередь, выполняет инструкцию, назы-
ваемую телом цикла, пока условие продолжения цикла не примет значение
false, либо пока программист не прервет выполнение цикла другим способом.
ЗАМЕ ЧАНИЕ 1
Прервать последовательное выполнение инструкций любого цикла можно с по-
мощью: break (передает управление на следующую за циклом инструкцию),
continue (прерывает выполнение текущей итерации и переходит к следующей),
Инструкции (statements) С/С++ 123
return (возвращает управление вызвавшей функции) и throw (генерирует ис-
ключение).
ЗАМЕ ЧАНИЕ 2
Если тело цикла состоит из нескольких инструкций, то такую последователь-
ность следует заключать в фигурные скобки {…}. В некоторых организациях
обязательным требованием является заключение тела цикла в фигурные скоб-
ки, даже если тело состоит из одной инструкции. Это позволяет избежать оши-
бок при модификации программы.
4.3.1. Инструкция while
Инструкция while обычно используется для так называемых нерегулярных
циклов, т. е. циклов, для которых количество итераций заранее неизвестно.
Синтаксис:
while(условие_продолжения_цикла) {тело_цикла}
Условие продолжения цикла вычисляется в начале выполнения инструкции
while (рис. 4.5). Выражение, которое используется в качестве условия, долж-
но приводиться к целому типу. Если это условие сразу же не выполняется
(false), то тело цикла не будет выполнено ни одного раза!
Рис. 4.5
Пример 1.
Требуется подсчитать сумму значений x/n, начиная с n=1, пока разность ме-
жду двумя соседними значениями не станет меньше некоторого порогового
значения. Решение представлено в листинге 4.1.
124 Глава 4
Листинг 4.1. Использование цикла while для вычисления суммы ряда
{
const double delta = … //задали значение порога
int n = 1; //начальное значение n
double x = …; //сформировали значение x
double sum = x; //подготовили переменную для суммирования
while( (x/n – x/(n+1) ) > delta) //пока два соседних значения
отличаются больше, чем на delta
{
n++;
sum += x /n; //копим сумму
}
}
Пример 2.
Требуется вводить и подсчитывать количество введенных символов, пока
пользователь не введет символ *. Решение представлено в листинге 4.2.
Листинг 4.2. Использование цикла while для подсчета введенных символов
{
int n=0; //инициализация счетчика
char ch; //переменная для ввода
while(std::cin>>ch, ch!='*') //использование в условии
оператора "запятая"
{ n++; }
}
std::cout<<"n="<<n;
Пример 3.
Модифицируем предыдущее задание — подсчитаем общее количество вве-
денных пользователем символов (в т. ч. пробелов и запятых). Решение пред-
ставлено в листинге 4.3.
Листинг 4.3. Подсчет общего количества введенных символов (в т. ч. пробелов
и запятых)
{
int iTotal=0, iSpaces=0, iCommas=0; //счетчики
char ch; //переменная для ввода
Инструкции (statements) С/С++ 125
while(std::cin>>ch, ch!='*')
{
switch(ch)
{
case ' ': //пробел
iSpaces++;
break;
case ',': //запятая
iCommas++;
break;
}
iTotal++; //в общем количестве следует учесть любой
символ
}
std::cout<<"Total "<<iTotal<< std::endl;
std::cout<<"Spaces "<<iSpaces<< std::endl;
std::cout<<"Commas "<<iCommas<< std::endl;
}
ПР Е ДО СТ Е Р Е Ж Е НИ Е 1
Одна из самых неприятных особенностей цикла заключается в возможности
образования бесконечного цикла. Будьте бдительны!
Например:
while(i=1) {тело_цикла} //часто встречаемая ошибка использования
оператора присваивания вместо оператора сравнения на
равенство. Такое условие всегда будет true, и, соответственно,
ваша программа зациклится!
Это тоже очень распространенная ошибка.
Подумайте, сколько раз выполнится цикл?
int i=100;
while(i>0) ;
{ i--; }
ПР Е ДО СТ Е Р Е Ж Е НИ Е 2
Будьте осторожны с условием, в котором фигурируют плавающие переменные
(float или double), т. к. условие типа while(<выражение> != 1.1111) может
из-за округления превратить цикл в бесконечный.
126 Глава 4
ЗАМЕ ЧАНИЕ
Иногда программист в явном виде задает бесконечный цикл: while(true)
{тело_цикла}. Такой цикл обязательно должен быть прерван, например, инст-
рукцией break.
Подумайте, имеет ли смысл такой цикл?
while(false){тело_цикла}
Если программист никаким образом не вмешивается в естественное выпол-
нение цикла, то выход происходит только в том случае, когда условие про-
должения цикла принимает значение false. Бывают ситуации, когда естест-
венное выполнение цикла требуется прервать при возникновении некоторого
дополнительного условия в теле цикла. Для этих целей можно воспользо-
ваться инструкциями break и continue (см. рис. 4.5).
Использование инструкции continue демонстрирует листинг 4.4, а инструк-
ции break — листинг 4.5.
Листинг 4.4. Подсчет количества символов без учета пробелов
{
int iTotal=0; //счетчик символов без учета пробелов
char ch; //переменная для ввода
while(std::cin>>ch, ch!='*')
{
if(ch==' ') continue; //прерываем текущую итерацию,
передаем управление на следующую итерацию.
При этом остаток тела цикла игнорируется
iTotal++; //а все остальные символы считаем
}
std::cout<<"Without spaces"<<iTotal<< std::endl;
}
Листинг 4.5. Подсчет количества символов до первого пробела
{
int iTotal=0;
char ch;
while(std::cin>>ch, ch!='*')
Инструкции (statements) С/С++ 127
{
if(ch==' ') break;
iTotal++;
}
std::cout<<"Up to first space "<<iTotal<< std::endl;
}
4.3.2. Инструкция do...while
Инструкция do...while аналогична инструкции while (рис. 4.6).
Синтаксис:
do {тело_цикла} while (условие_продолжения_цикла);
Рис. 4.6
Основное отличие (и причина ошибок) состоит в том, что сначала выполня-
ется тело цикла, а потом проверяется условие, поэтому независимо от зна-
чения условия тело цикла всегда выполняется хотя бы один раз. Как след-
ствие, во многих случаях оказывается необходимой дополнительная
проверка внутри тела цикла. В листинге 4.6 демонстрируется подобная си-
туация.
128 Глава 4
Листинг 4.6. Вычисление суммы натуральных чисел до указанного
пользователем значения без проверки введенного значения
{
int n; //в этой переменной пользователь сформирует значение
std::cout<<"Input integer positive value: "; //предложим ему
ввести целое положительное значение
std::cin>>n; //но он может не послушаться и ввести отрицательное!
int sum=0; //здесь будем копить сумму
do{
sum +=n; //при отрицательном значении n переменная sum
все равно будет модифицирована!
n--;
} while(n>0); //условие продолжения цикла
}
Если пользователь ввел отрицательное значение, то результат получен не-
правильный, поэтому в теле цикла нужна дополнительная проверка. Моди-
фицируем предыдущий пример с учетом проверки (листинг 4.7).
Листинг 4.7. Вычисление суммы натуральных чисел с проверкой введенного
значения
{
int n;
std::cout<<"Input integer positive value: ";
std::cin>>n;
int sum=0;
do{
if(n<=0) break; //дополнительная проверка
sum +=n;
n--;
} while(n>0); //условие продолжения цикла
}
Бывают ситуации, когда логично использовать цикл do…while. Например,
пользователю предлагается ввести два значения: top и bottom, причем зна-
чение top должно быть больше, чем bottom (но пользователь может пренеб-
речь этим условием и ввести значения с точностью до наоборот). С помощью
цикла do…while заставим его вводить значения до тех пор, пока он не сфор-
мирует их правильно (листинг 4.8).
Инструкции (statements) С/С++ 129
Листинг 4.8. Использование цикла do…while для правильного формирования
вводимого пользователем диапазона
{
int top, bottom;
do
{
std::cout<<"Input bottom::";
cin>>bottom;
std::cout<<"Input top (it must be larger than bottom)::";
cin>>top;
}while(top<=bottom); //а если пользователь ввел неправильные
значения, отправляем его на новую итерацию…
…
}
4.3.3. Инструкция for
Если инструкции while и do…while используются в основном (хотя это совер-
шенно необязательно) для нерегулярных циклов (когда количество повторе-
ний явно не задано), то инструкция for служит (хотя это тоже необязательно)
для организации регулярного цикла (с известным числом повторений).
Синтаксис:
for([вычисление_инициализаторов] ; [выражение1, обычно условие] ;
[выражение2]) {тело_цикла}
В отличие от while и do…while в инструкции for все части, управляющие цик-
лом (переменная цикла, условие продолжения и выражение, модифицирую-
щее переменную цикла), сосредоточены в одном месте, что улучшает вос-
приятие кода. Порядок выполнения инструкции for (рис. 4.7):
1. Сначала один раз вычисляется инициализирующая часть (обычно здесь
задаются начальные значения).
2. Затем вычисляется выражение 1 (условие продолжения цикла), и если ус-
ловие принимает значение true, то выполняется текущая итерация:
• выполняется тело цикла;
• вычисляется выражение 2 (обычно здесь модифицируется переменная
цикла).
3. Итерации повторяются, пока условие не примет значение false.
130 Глава 4
Рис. 4.7
Пример 1 (самое распространенное применение for).
Реализуем посредством for задачу из разд. 4.3.2 (см. листинг 4.6).
Решение представлено в листинге 4.9. Если пользователь вводит отрицатель-
ное значение, то тело цикла не выполняется.
Листинг 4.9. Вычисление суммы n натуральных чисел
{
int n;
std::cout<<”Input integer positive value: ”;
Инструкции (statements) С/С++ 131
std::cin>>n;
int sum=0;
for(int i=1; i<n; i++) //i-переменная цикла, с помощью которой
перебираем диапазон значений от 1 до n
{
sum +=i;
}
}
Пример 2.
Переменная цикла не обязательно должна быть типа int (листинг 4.10).
Листинг 4.10. Вывод на экран всех заглавных английских букв по алфавиту
{
for(char c='A'; c<='Z'; c++) //c-переменная цикла
{
std::cout<<c;
}
}
Специфика использования инструкции for:
􀂈 условие продолжения цикла вычисляется на каждой итерации, поэтому не
стоит в этом месте заставлять компилятор всякий раз вычислять сложные
выражения (если есть такая возможность, лучше вычислить его один раз
до начала цикла):
for(int i=0; i< x*y*z; i++){тело_цикла}
Если переменные x, y, z в теле цикла не изменяются, то эффективнее
такую задачу реализовать следующим образом:
int n = x*y*z;
for(int i=0; i< n; i++){тело_цикла}
􀂈 три составляющих цикла разделяются обязательными символами (точка
с запятой), а сами составляющие (все три) являются необязательными;
Если необязательные составляющие опустить, получится бесконечный
цикл.
Подумайте, как прервать выполнение такого цикла?
for(;;){…}
132 Глава 4
􀂈 в любой части цикла может быть несколько выражений. Они должны
быть разделены запятой, а не точкой с запятой:
int i;
double res;
for(i=0, res=1 ; i<100 ; i++, res+=res/i){тело_цикла}
􀂈 не стоит смешивать в инициализирующей части выражения и объявления
(компилятор воспримет все как список объявлений, проигнорирует в при-
веденном примере double, выдаст предупреждение и будет интерпретиро-
вать sum как int):
for(int i=0, double sum=0; i<100; i++) { sum+=…; }
􀂈 видимость переменных, объявленных в инициализирующей части for,
распространяется до закрывающей фигурной скобки тела цикла.
ЗАМЕ ЧАНИЕ
Специфика Microsoft (до версии VC.net 2003 включительно): переменные, объ-
явленные в инициализирующей части for, имеют такую же область видимости,
как если бы они были объявлены непосредственно перед for;
􀂈 тело цикла может быть пустым:
for(int i=0, sum=0; i<n; sum+=i,i++) ;
􀂈 обычно выражение 2 (см. синтаксис инструкции for) используется для
модификации переменной цикла, но это не обязательно;
􀂈 переменная цикла в принципе может быть любого типа, но будьте осто-
рожны с переменными цикла плавающего типа, т. к. из-за ограниченности
разрядной сетки при большом количестве итераций можно накопить
ошибку!
Для прерывания выполнения инструкции for можно использовать инструк-
ции break и continue.
Пример 1.
Пусть требуется определить в заданном диапазоне количество значений,
удовлетворяющих некоторому условию (листинг 4.11).
Листинг 4.11. Подсчет количества чисел, делящихся нацело на 3
int iUp = 100, iDown = 0;
for(int nTotal = 0, i = iDown; i<iUp; i++)
{
if( i%3 ) continue; //если
Инструкции (statements) С/С++ 133
остаток от целочисленного деления не равен нулю
(условие=true), то считать его не нужно, поэтому
переходим на следующую итерацию
nTotal++;
}
Пример 2.
Допустим, необходимо ввести максимально N целых чисел и просуммиро-
вать введенные положительные значения, но если очередное введенное число
окажется отрицательным, то нужно прекратить суммировать и выйти из цик-
ла. Решение представлено в листинге 4.12.
Листинг 4.12. Ввод и суммирование целых чисел
int Sum = 0;
for(int i=0; i<N; i++)
{
int n;
cin>>n;
if(n<0) break; //если очередное
введенное значение оказалось
отрицательным, то выход из цикла
Sum += n;
}
Пример 3.
Модифицируем предыдущий пример. Введем все N чисел, но просуммируем
только положительные, а отрицательные проигнорируем. Решение представ-
лено в листинге 4.13.
Листинг 4.13. Суммирование только положительных целых чисел
int Sum = 0;
for(int i=0; i<N; i++)
{
int n;
cin>>n;
if(n<0) continue; //если
очередное введенное значение оказалось
134 Глава 4
отрицательным, то переходим к следующей
итерации (т. е. игнорируем его)
Sum += n;
}
4.4. Инструкции безусловного перехода:
break, continue, return, goto
Инструкция break прерывает выполнение switch, while и for и передает
управление на инструкцию, следующую за ними.
ЗАМЕ ЧАНИЕ
Если имеет место вложенность, то прерывается самая внутренняя по отноше-
нию к break инструкция.
Инструкция continue прерывает выполнение while и for и переходит к сле-
дующей итерации.
Инструкция return прерывает выполнение текущей функции и возвращает
управление вызвавшей функции.
Инструкция goto осуществляет безусловный переход (только в пределах од-
ной функции!).
Синтаксис:
goto <идентификатор>;
Например:
{
goto M;
…
M: инструкция
}
//или
{
N: инструкция
…
goto N;
}
ЗАМЕ ЧАНИЕ
Без инструкции goto в подавляющем большинстве случаев можно обойтись
(Дейкстра). Не рекомендуется использовать ее, поскольку в этом случае неоче-
видно, из какой точки программы было передано управление!
Инструкции (statements) С/С++ 135
Одним из немногих разумных случаев использования инструкции goto явля-
ется выход из вложенного цикла или switch-инструкции (т. к. break прекра-
щает выполнение только самого внутреннего цикла или switch-инструкции):
for(int i=0; i<n; i++)
{
for(int j=0; j<m; j++)
{
if(условие) goto found;
}
…
}
found:…
Глава 5
Препроцессор.
Заголовочные файлы
5.1. Директивы препроцессора
Получение исполняемого модуля из исходного текста происходит в несколь-
ко этапов (см. разд. 1.2.1). На первом этапе с исходным текстом программы
работает специальная программа — препроцессор. Основная его цель —
закончить формирование исходного текста программы на языке С/С++, в ча-
стности, препроцессор должен выполнить предназначенные ему программи-
стом директивы (список директив представлен в табл. 5.1). И только затем
окончательно сформированный текст программы поступает на обработку
компилятору.
Таблица 5.1. Список директив препроцессора
Директива Пояснение
#include Включает в исходный текст обрабатываемого файла содержимое
других файлов, указанных в директиве (в частности, содержащих
интерфейс стандартной библиотеки)
#define Задает макроподстановки и делает определенными имена для пре-
процессора
#undef Отменяет действие директивы #define
#if
#elif
#else
#endif
#ifdef
#ifndef
Директивы условной трансляции позволяют на стадии препроцессо-
ра формировать из исходного текста файла разный конечный текст,
который в дальнейшем поступает на обработку компилятору. Это,
в свою очередь, позволяет получать различный выполняемый код,
не модифицируя исходный текст программы
138 Глава 5
Таблица 5.1 (окончание)
Директива Пояснение
#pragma Позволяет настраивать компилятор с учетом специфических особен-
ностей конкретной машины или операционной среды (эти особенно-
сти и варианты директивы #pragma индивидуальны для каждого
компилятора)
#line Позволяет включать номера строк исходного кода заимствованных
файлов в диагностику компилятора об ошибках и предупреждениях
#error Обычно включается между директивами #if…#endif для проверки
какого-либо условия на этапе препроцессора. При выполнении тако-
го условия компилятор выводит сообщение, указанное в директиве
#error и останавливается
ЗАМЕ ЧАНИЕ
В реализации препроцессоров семейства Microsoft Visual Studio имеются еще
две директивы: #import и #using, которые в других реализациях могут отсут-
ствовать.
Специфика использования директив препроцессора:
􀂈 директивы препроцессора пишутся каждая на отдельной строке;
􀂈 никакие разделители, вроде признака конца С/С++ инструкции (точки с
запятой) не нужны! Но если директива слишком длинная, то для переноса
на другую строку следует применять символ обратной косой черты \, при
этом везде препроцессор будет удалять начальные (левые) пробелы;
􀂈 большинство директив препроцессора можно использовать в любом месте
файла, при этом их действие на препроцессор распространяется, начиная
от того места, где они использованы, до конца файла;
􀂈 комментарии первого рода в стиле С++ — две косые черты // в директивах
препроцессора понимает не каждая реализация (не каждый препроцессор).
5.2. Директива #define
Директива #define позволяет программисту задавать макроопределения (или
макросы).
Термином макроопределение обозначают возможность сопоставления задан-
ному программистом идентификатору текстового фрагмента. Препроцессор
каждый раз, встречая в обрабатываемом тексте этот идентификатор, будет
выполнять макроподстановку (макрорасширение), т. е. заменять имя указан-
ным фрагментом. Таким образом, препроцессор формирует окончательный
текст, который поступает на обработку компилятору.
Препроцессор. Заголовочные файлы 139
Во времена ранних версий Си считалось, что использование макросов улуч-
шает визуальное восприятие текста программы, т. к. во-первых — позволяет
вводить осмысленные обозначения для констант, а во-вторых — укрупняет
текстовые фрагменты, заменяя их на короткий идентификатор.
Но в связи с развитием языка и появлением новых стандартов С++ теперь
принято считать (Бьерн Страуструп — создатель С++), что злоупотребление
макросами чревато возникновением трудно выявляемых ошибок. Я бы пере-
фразировала эту рекомендацию следующим образом: оставим написание
макроопределений профессионалам, а сами будем осмысленно использовать
созданное профессионалами! Заглядывая в заголовочные файлы стандартной
библиотеки С/С++, а также заголовочные файлы Windows и MFC (что бывает
очень полезным), вы будете встречать директиву #define довольно часто.
5.2.1. Использование директивы #define
Простое макроопределение
Синтаксис:
#define идентификатор_макро тело_макро
Препроцессор просматривает исходный текст и заменяет каждое вхождение
лексемы "идентификатор_макро" на лексему (совокупность лексем) "те-
ло_макро", осуществляя макроподстановки.
Пример.
#define FIRST 1 //эта директива может быть приведена в любом месте
до ее первого использования
int main()
{
if(n == FIRST) {...} //препроцессор заменит FIRST на 1 и на
компиляцию будет отправлен текст if(n == 1)
}
ЗАМЕ ЧАНИЕ
Задать макроподстановку можно двумя способами: с помощью директивы
#define или посредством соответствующего ключа в опциях командной строки
компилятору (в VC таким ключом является \D). Использование в тексте про-
граммы #define FIRST 1 эквивалентно \DFIRST=1.
Вложенные макросы
Препроцессор просматривает текст несколько раз, осуществляя макропод-
становки на каждом проходе. После первой подстановки снова выполняется
140 Глава 5
просмотр уже расширенного макросами текста, что позволяет организовы-
вать вложенные макросы.
Пример.
#define FALSE 0
#define TRUE !FALSE
int main()
{
if(выражение == FALSE) {...} //препроцессор заменит на
if(выражение == 0) {...}
if(выражение == TRUE) {...} //при первом просмотре препроцессор
заменит на if(выражение == !FALSE),
при втором просмотре на:
if(выражение == !0), что
эквивалентно if(выражение ==1)
}
Макроc с параметрами
Синтаксис:
#define идентификатор_макро(список_параметров) тело_макро
Далее, встретив в тексте программы указанный идентификатор, совершая
макроподстановку, вместо формальных имен, приведенных в списке пара-
метров макроса, препроцессор будет просто подставлять выражения, указан-
ные программистом.
Пример 1.
Рассмотрим макрос, который из четырех однобайтовых значений формирует
четырехбайтовое (рис. 5.1).
Рис. 5.1
#define MAKE(b1, b2 ,b3, b4) static_cast<unsigned char>(b1) | \
static_cast<unsigned char>(b2) << 8 | \
Препроцессор. Заголовочные файлы 141
static_cast<unsigned char>(b3) << 16 | \
(b4) << 24
int main()
{
int res = MAKE(1,2,3,255);
}
Подумайте: зачем используется явное приведение типа к unsigned char
первых трех параметров макроса и почему оно необязательно для чет-
вертого.
Подсказка: каким был бы результат без использования явного приведения
типа в случае:
int res = MAKE(0xff,1,2,3);
Пример 2.
Рассмотрим макрос для получения квадрата любого числа:
#define SQUARE(x) x*x
int main()
{
int z = 2;
int y = SQUARE(z); //препроцессор заменит SQUARE(z) на z*z и
на компиляцию пойдет строка: y = z*z;
}
ЗАМЕ ЧАНИЕ 1
Существенным моментом при написании тела макроса с параметрами являет-
ся использование скобок, в частности — заключение параметра в теле макроса
в скобки.
Например:
//без скобок
int z = 2, y;
y = SQUARE(z-1); //препроцессор сформирует для компилятора строку:
y = z-1 * z-1; и результат будет совсем
не таким, как задумал программист
//используем скобки
#define SQUARE(x) (x)*(x)
int z = 2, y;
y = SQUARE(z-1); //теперь препроцессор сформирует строку:
y = (z-1) * (z-1);
142 Глава 5
Подумайте, каковы были бы результаты макрорасширения и каким обра-
зом можно исправить ситуацию?
#define SUM(x,y) x + y
int a=2,b=3;
int c = SUM(a,b) * 5;
ЗАМЕ ЧАНИЕ 2
Некоторые ошибки не устранить никакими скобками.
Например:
#define SQUARE(x) (x)*(x)
int z = 2, y;
int y = SQUARE(z++); //на компиляцию будет отправлена строка:
int y = (z++) * (z++); и значение z будет
инкрементировано дважды, чего программист,
скорее всего, не предполагал
ЗАМЕ ЧАНИЕ 3
Пробел перед открывающей скобкой списка параметров вызовет ошибку, т. к.
препроцессор в таком случае не сможет отличить список параметров от тела
макроса.
Например:
#define SQUARE (x) x*x //ошибка
ЗАМЕ ЧАНИЕ 4
Как и для обычных макросов, после первой подстановки выполняется повтор-
ный просмотр полученного текста, что позволяет создавать сложные вложен-
ные макросы с параметрами.
Пустые макросы
Синтаксис:
#define идентификатор_макро
Встречая в тексте идентификатор пустого макроса, препроцессор просто ис-
ключает его из текста программы. Такие пустые макросы используются не
для макрорасширений, а обозначают определенное для препроцессора со-
стояние данного идентификатора. В основном такие макроопределения при-
меняются для условной компиляции кода (см. разд. 5.4 и 5.5).
Препроцессор. Заголовочные файлы 143
ЗАМЕ ЧАНИЕ
Определенность идентификатора для препроцессора можно задать также с по-
мощью опций командной строки компилятору. В VC #define идентификатор_
макро эквивалентно \Dидентификатор_макро.
Конкатенация макросов
С помощью сочетания символов ## можно слить несколько лексем в одну.
Это означает, что препроцессор просто объединит указанные строки в одну
значимую единицу для компилятора.
Пример 1.
Можно компоновать идентификаторы из отдельных частей:
#define NUM(name,number) name##_##number
int main()
{
int NUM(n,1) = 1; //препроцессор подставит вместо NUM(n,1) n_1 и
на компиляцию пойдет строка int n_1 = 1;
double NUM(d,1) = 1.1; //на компиляцию
пойдет строка double d_1 = 1.1;
}
Пример 2.
Макрос _TEXT подставляет префикс L, позволяя формировать расширенные
(UNICODE) символы или строки:
#define _TEXT(x) L##x
int main()
{
std::wcout<<_TEXT("ABC"); //препроцессор вместо _TEXT("ABC")
подставит L"ABC"
}
5.2.2. Предопределенные макросы
Язык С/С++ предоставляет программисту набор макросов (некоторые из них
приведены в табл. 5.2) для получения разнообразной информации во время
компиляции.
Пример.
int main()
{
144 Глава 5
std::cout<<"Current file "<<__FILE__<<
"\nLine "<<__LINE__<<
"\nTime"<<__TIME__;
}
Таблица 5.2. Предопределенные макросы
Идентификатор Пояснение
__cplusplus
(специфика VC)
Определен, если исходный файл должен компилироваться
как С++, а не Си
__DATE__ Преобразуется в строку, заключенную в кавычки и содержа-
щую дату компиляции
__FILE__ Преобразуется в строку, заключенную в кавычки и содержа-
щую имя исходного файла с учетом полного пути
__LINE__ Преобразуется в строку, заключенную в кавычки и содержа-
щую номер текущей строки в исходном файле
__TIME__ Преобразуется в строку, заключенную в кавычки и содержа-
щую время последней компиляции
и т. д.
5.2.3. Диагностический макрос assert
Стандартная библиотека предоставляет программисту возможность отладки
своей программы посредством использования макроса assert.
Макрос имеет вид:
assert(выражение);
Он позволяет программисту при отладке программы отследить непредусмот-
ренные задачей ситуации. Этот макрос определен в заголовочном файле
<cassert>.
Например: программист предполагает, что, исходя из задачи, некоторая пере-
менная x ни при каких обстоятельствах не должна становиться положительной.
Но чего только в реальной жизни не бывает, поэтому на всякий случай в неко-
торых местах программы дотошный программист включает проверку:
assert(x<0);
Тогда в DEBUG-версии производятся следующие действия:
1. Макрос вычисляет свой аргумент, и если результат равен false (0), то вы-
водит полную диагностику о том, что произошло:
assertion failed: x<0, file:\…\имя_файла.cpp, line номер_строки,
Препроцессор. Заголовочные файлы 145
2. Вызывает функцию аварийного завершения программы abort(). Если вы
пользуетесь компилятором Microsoft Visual C++, то при этом еще появля-
ется диалоговое окно диагностики Debug error.
ЗАМЕ ЧАНИЕ
В RELEASE-версии макрос ничего не делает, т. е. никаких проверок не осуще-
ствляет.
5.2.4. Рекомендации
Начинающему программисту Б. Страуструп рекомендует воздерживаться от
написания собственных макросов, т. к. это может привести к появлению
трудновыявляемых (а иногда и неустранимых) ошибок. Создание макросов —
это прерогатива профессионалов (разработчиков библиотек). Обычному про-
граммисту следует стремиться использовать другие (более безопасные) сред-
ства языка, предоставляющие практически те же возможности, что и макро-
сы (табл. 5.3).
Таблица 5.3. Средства С++, альтернативные директиве #define
Вместо макроса Пользуйтесь понятиями
Для определения констант:
#define YES 0
const (см. разд. 3.10.1) и для
целочисленных констант enum (см.
cраoзnдs.t 3 .i3n):t YES=0;
enum {YES,NO};
Для того чтобы избежать расходов на
вызов функции:
#define SQUARE(x) (x)*(x)
inline (см. разд. 8.1.4):
inline SQUARE(int x) {return x*x;}
Для определения семейства функций
или классов
template (эта тема в данной книге не
рассматривается)
ЦИ Т А Т А И З Б. СТ Р А У С Т Р УП А
"Предпочитайте компилятор препроцессору!"
5.3. Директива #undef
Если программист использовал идентификатор для макроподстановки, или
идентификатор является именем пустого макроса, или программист исполь-
зовал это имя с ключом \D в командной строке компилятору, то препроцес-
146 Глава 5
сор считает такой идентификатор определенным и действующим до конца
файла или до тех пор, пока в файле не встретится директива #undef.
Поэтому один и тот же идентификатор может означать для компилятора раз-
ные лексемы, т. е. одному и тому же имени макроса можно поставить в соот-
ветствие разные тела. Можно отменить действие макроопределения с помо-
щью директивы #undef.
Пример.
#define MESSAGE "Hello"
std::cout<< MESSAGE; //будет выведено Hello
#undef MESSAGE //отмена действия идентификатора MESSAGE
std::cout<<MESSAGE; //ошибка: т. к. идентификатор стал
неопределенным и препроцессор вместо того, чтобы
подставлять тело макроса, отправил эту строку,
как есть, компилятору, а тот не понял,
что такое MESSAGE
#define MESSAGE "Bye"
std:: cout<< MESSAGE; //будет выведено Bye
ЗАМЕ ЧАНИЕ 1
Директива #undef_идентификатор будет корректно выполняться независимо от
того, был ли до того определен идентификатор или нет.
ЗАМЕ ЧАНИЕ 2
Если одному и тому же идентификатору (не отменяя его действие с помощью
#undef) программист сопоставляет новое тело, то препроцессор ANSI Си вы-
дает ошибку, а препроцессор С++ предупреждает о повторном определении
макроса и использует последнее значение.
Например:
#define MESSAGE "Hello"
std::cout<< MESSAGE; //будет выведено Hello
#define MESSAGE "Bye" //здесь препроцессор С++ выдаст
предупреждение о повторном определении
идентификатора MESSAGE (macro redefinition)
std:: cout<< MESSAGE; //но использовано будет последнее
и выведено Bye
Препроцессор. Заголовочные файлы 147
5.4. Директивы #ifdef, #ifndef, #else и #endif
Условные директивы #ifdef, #ifndef используются для проверки: является
ли для препроцессора в данный момент указанный идентификатор опреде-
ленным (определенность идентификатора задается с помощью директивы
#define или посредством ключа \D компилятору). Этот механизм позволяет
препроцессору в зависимости от определенности идентификатора формиро-
вать разный текст, который затем отправляется на компиляцию, т. е. манипу-
лируя только определенностью идентификатора, можно получать разный ре-
зультирующий код.
Синтаксис:
#ifdef идентификатор_макро
инструкции //если идентификатор является определенным для
препроцессора, этот блок кода будет вставлен
в текст, который пойдет на компиляцию
#else
инструкции //иначе на компиляцию препроцессор отправит
этот текст
#endif //признак конца условного блока для препроцессора обязателен!
ЗАМЕ ЧАНИЕ
Директивы препроцессора #ifdef и #else не имеют никакого отношения к ин-
струкциям if…else языка Си! Это механизм совершенно другого этапа (форми-
рования текста, а не собственно компиляции).
Пример 1.
В DEBUG-версии проекта программист для своего удобства может выводить
какие-то промежуточные значения на печать, но заказчика эти отладочные
распечатки не интересуют, поэтому логично вставлять их только в DEBUG-
версию проекта:
{//в VC в опциях командной строки компилятору в отладочной версии
определено имя _DEBUG
int x=выражение;
#ifdef _DEBUG // если имя _DEBUG является определенным (отладочная
версия исполняемого файла), то следующая строчка
будет отправлена на компиляцию, а иначе
препроцессор ее проигнорирует
cout<<x;
#endif
}
148 Глава 5
Пример 2.
Хорошим примером использования директив условной трансляции является
способ получения простых (однобайтовых) или расширенных (двухбайто-
вых) символов без модификации исходного текста в VC (это специфика
Microsoft). В файле <tchar.h> все понятия, так или иначе связанные со стро-
ками, заключены в директивы условной трансляции:
#ifdef _UNICODE //если определено имя _UNICODE
typedef wchar_t TCHAR; //везде, где программист использует
псевдоним TCHAR, компилятор будет
иметь в виду wchar_t
#define _T(x) L##x //везде, где препроцессор встретит
макрос _T, он подставит префикс L
#define _tmain wmain //вместо макроса _tmain препроцессор
подставит wmain (версия функции main
для расширенных символов)
#define _tcscpy wcscpy //вместо макроса _tcscpy препроцессор
подставит wcscpy (версия функции
стандартной библиотеки для копирования
расширенных символов)
…
#else //иначе тем же самым псевдонимам и макроподстановкам будут
сопоставлены варианты для однобайтовых символов
typedef char TCHAR; //псевдониму TCHAR будет соответствовать char
#define _T(x) x //префикса L не будет
#define _tmain main //_tmain превратится в main
#define _tcscpy strcpy //_tcscpy превратится в strcpy (версия
копирования однобайтовых строк символов)
…
#endif
В табл. 5.4 приведен пример исходного текста (столбец 1) и результат работы
препроцессора (столбец 2 либо 3) в зависимости от определенности иденти-
фикатора _UNICODE.
Пример 3.
Директивы условной трансляции могут быть вложенными:
#define VERSION
#define BETA
Препроцессор. Заголовочные файлы 149
#ifdef VERSION //в программе используется контроль версий
#ifdef ALFA
std::cout<<"Alfa version";
#else
std::cout<<"Beta version"; //эта строка будет отправлена
препроцессором на компиляцию
#endif
#endif
Таблица 5.4. Примеры использования средств <tchar.h>
Фрагмент программы,
написанный
с использованием
макросов
Если имя _UNICODE
для препроцессора
определено, препро-
цессор сформирует:
Если имя _UNICODE
для препроцессора
не определено,
на компиляцию пойдет:
#include <tchar.h>
int _tmain()
{
TCHAR c=_T('Ф');
TCHAR ar[10];
tcscpy(ar,_T("ABC"));
}
int wmain()
{
wchar_t c=L'Ф';
wchar_t ar[10];
wcscpy(ar, L"ABC");
}
int main()
{
char c='Ф';
char ar[10];
strcpy(ar, "ABC");
}
ЗАМЕ ЧАНИЕ
Директивы #ifdef, #else устарели и продолжают существовать только для
совместимости с предыдущими версиями языка. Предпочтительным является
использование директив, приведенных в следующем разделе.
5.5. Директивы #if, #elif, #else, #endif.
Оператор препроцессора defined
Условные директивы #if, #elif, #else и #endif работают так же, как
и обычные условные инструкции С/С++, только действуют они на стадии
формирования исходного текста, а не выполнения. По сравнению с #ifdef
и #ifndef директивы #if, #elif предоставляют альтернативный, более гиб-
кий способ формирования условий на этапе препроцессора.
Оператор препроцессора defined используется только с директивами #if,
#elif и служит для выявления определенности идентификатора.
150 Глава 5
Специфика использования операторов #if, #elif:
􀂈 в простейшем случае директиву #if и оператор defined можно употреб-
лять для выяснения определенности идентификатора, при этом:
#ifdef идентификатор эквивалентно #if defined идентификатор
#ifndef идентификатор эквивалентно #if !defined идентификатор
Пример 1.
Перепишем пример из предыдущего раздела, используя директиву #if
и оператор препроцессора defined:
#if defined _DEBUG //если DEBUG-версия проекта
cout<<x; //вывод отладочных значений
#endif
Пример 2.
Рассмотрим, как можно средствами препроцессора устранить зависимость
от платформы:
#if defined (_WIN32) //если 32-разрядная платформа
typedef int int32; //вводим псевдоним для int
#else
typedef long int32; //иначе на 16-разрядной платформе
тому же самому псевдониму сопоставляем long
#endif
int32 value; //гарантировано 32 разряда независимо от платформы
􀂈 одним из преимуществ использования #elif является возможность много-
кратного использования этой директивы в сложных конструкциях, сле-
дующих за директивой #if.
Например, пусть программа ориентирована на нескольких потребителей,
при этом для каждого клиента в определенном месте программы нужно
реализовать разную функциональность. Чего в таких ситуациях точно не
следует делать, так это для каждого клиента создавать отдельный проект
и дублировать код. Гораздо удобнее и надежнее в такой ситуации в соот-
ветствующем месте использовать директивы условной трансляции и
управлять получением результирующего кода, делая один из идентифика-
торов определенным:
#define CLIENT2
int main()
{
Препроцессор. Заголовочные файлы 151
…//действия, не зависящие от конкретного клиента
//действия, специфичные для каждого клиента
#if defined CLIENT1 //если создаем версию программы
для пользователя №1
…//в текст программы будет включен текст, специфичный
для пользователя №1
#elif defined CLIENT2 //а если для пользователя №2
…//в текст программы будет включен текст, специфичный
для пользователя №2
#elif defined CLIENT3
…//для пользователя №3
#else
std::cout<<"Client not supported!";
#endif
}
􀂈 также, в отличие от директивы #ifdef, которая умеет проверять только
определенность идентификатора макроса, в директиве #if можно исполь-
зовать сложное выражение, где могут фигурировать как идентификаторы,
так и логические операторы и целочисленные литералы. При этом следует
помнить, что вычислять это выражение будет препроцессор, поэтому
в выражении можно использовать только константы. Например:
#if defined CLIENT1 || defined CLIENT2 //если определен любой
из идентификаторов, то будет компилироваться
следующая последовательность инструкций
…
#endif
􀂈 часто в качестве идентификаторов в директиве #if используются имена,
определяющие тип процессора или операционной системы. Это позволяет
учитывать особенности архитектуры или операционной системы на этапе
компиляции, что, в свою очередь, позволяет программисту без изменений
адаптировать исходный текст программы к разным средам:
#if defined _WIN32_WINNT && _WIN32_WINNT >= 0x0400 //если версия
Windows NT4 или более поздняя
// код, специфичный для NT
#elif defined _WIN32_WINDOWS && WINVER>=0x0410
// код, специфичный для Windows 98 и более поздних версий
#endif
152 Глава 5
5.6. Директива #include.
Заголовочные файлы
Зачем нужны заголовочные файлы:
􀂈 для того чтобы структурировать программу, мы разбиваем текст на от-
дельные файлы, поэтому, естественно, появляются зависимости между
этими файлами (см. разд. 1.2.1). Одним из способов разрешения этих за-
висимостей является отделение интерфейса (объявлений внешних поня-
тий) (см. разд. 3.5) от реализации (от определений) и помещение интер-
фейсов в заголовочные файлы;
􀂈 для того чтобы воспользоваться средствами стандартной библиотеки,
нужно в своем модуле предоставить компилятору их описания (объявле-
ния). Эти описания сгруппированы разработчиками стандартной библио-
теки в соответствующих заголовочных файлах;
􀂈 ОС Windows позволяет программисту пользоваться системными возмож-
ностями (Win32API) посредством подключения системных заголовочных
файлов;
􀂈 библиотека MFC предоставляет свои заголовочные файлы
􀂈 и т. д.
Заголовочные файлы предоставляют возможность программисту:
􀂈 реализовать механизм раздельной компиляции;
􀂈 обеспечить согласованность объявлений пользовательских объектов во
всех файлах проекта.
В соответствии с потребностями программиста заголовочные файлы подраз-
деляются на следующие группы (рис. 5.2):
􀂈 пользовательские — создает сам программист, описывая экспортируемые
понятия;
􀂈 библиотечные — предоставляют программисту интерфейс для использо-
вания средств библиотек:
• стандартной библиотеки С++;
• Windows;
• MFC;
• прочих библиотек.
Препроцессор. Заголовочные файлы 153
Рис. 5.2
5.6.1. Концепция разделения на интерфейс
и реализацию. Механизм подключения
заголовочных файлов
Всегда есть кто-то, кто поставляет сервисы (сервер), и те, кто этими сервиса-
ми пользуются (клиенты). А каждый клиент, в свою очередь, может быть
сервером для другого клиента (другого уровня) и т. д.
Согласно этой терминологии файл, который экспортирует данные или функ-
ции, является сервером, а файл, который их использует, является клиентом.
При компиляции каждого файла-клиента компилятор должен знать свойства
всех тех переменных или функций, которые определены в других файлах-
серверах, и обращение к которым происходит в данном файле-клиенте. Обя-
занность программиста — предоставить компилятору объявления, т. е. опи-
сания импортируемых клиентом понятий:
􀂈 для переменных нужно описать тип и, возможно, некоторую дополни-
тельную информацию, чтобы компилятор смог генерировать низкоуров-
невые инструкции при действиях с этой переменной (см. разд. 3.5.1);
􀂈 для функций нужно описать способ вызова, количество и типы парамет-
ров (см. разд. 8.2), чтобы компилятор смог сгенерировать вызов.
Программисту необходимо описывать все внешние зависимости в исходном
тексте программы (иначе компилятор выдаст ошибку), но это можно делать
по-разному.
Способ первый.
Если каждый клиент описывает компилятору все используемые им внеш-
ние понятия, то текст программы выглядит примерно так, как показано
154 Глава 5
на рис. 5.3, что является неэффективным описанием внешних зависимостей,
поскольку:
􀂈 программист в каждом файле-клиенте пишет одни и те же объявления (extern
int x, y, z;), непроизводительно расходуя свои силы и увеличивая
размер текстов исходных файлов;
􀂈 при этом у него всегда остается возможность сделать при переписывании
какую-нибудь ошибку (например, extern int X, Y, Z;), а т. к. все объяв-
ления одного и того же объекта в разных единицах компиляции должны
быть согласованы (одинаковы), то компоновщик выдаст ошибку;
􀂈 если программист, разрабатывающий сервер, по каким-нибудь причинам
решит модифицировать экспортируемые понятия, то в файле-клиенте
придется изменять все объявления.
Рис. 5.3
При таком способе описания внешних зависимостей каждый клиент само-
стоятельно должен заботиться о том, чтобы все внешние для данного файла
понятия были описаны до их первого использования клиентом (рис. 5.4).
Способ второй.
Для эффективного описания внешних зависимостей сервер сам предоставля-
ет свой код в виде двух отдельных частей (рис. 5.5):
􀂈 файл интерфейса или заголовочный файл (обычно с расширением .h),
в который программист помещает описания всех экспортируемых сер-
вером понятий (объявления функций и переменных) — это интерфейс,
посредством которого любой файл-клиент может пользоваться экспорти-
руемыми сервером понятиями;
Препроцессор. Заголовочные файлы 155
Рис. 5.4
Рис. 5.5
􀂈 файл реализации (обычно файл с расширением .c или .cpp), в котором на-
ходятся определения экспортируемых сервером функций и переменных.
А начинка такого файла — это подробности реализации, о которых клиен-
ту знать вовсе не обязательно.
Для того чтобы любой клиент мог воспользоваться содержимым заголовоч-
ного файла, ему достаточно подключить этот файл посредством директивы
препроцессора #include.
Встретив директиву:
#include "включаемый_файл"
156 Глава 5
препроцессор заменяет строку, содержащую #include, на содержимое ука-
занного файла. Таким образом, оказывается, что все клиенты пользуются од-
ним и тем же интерфейсом (одними и теми же объявлениями), поэтому вероят-
ность ошибки у программиста уменьшается. Приведенный пример (см. рис. 5.3)
нужно переписать, используя механизм #include. Результат представлен
на рис. 5.6.
Рис. 5.6
РЕ ЗЮМЕ
В языке С/С++ механизм #include является эффективным средством манипу-
лирования текстом, позволяющим собрать фрагменты исходного кода в одну
единицу компиляции. Первейшая задача начинающего программиста — нау-
читься пользоваться этим средством грамотно!
5.6.2. Формы директивы #include
Существуют следующие формы директивы:
􀂈 #include <спецификация_файла>
􀂈 #include "спецификация_файла"
При использовании любого варианта препроцессор заменяет директиву
#include текстом указанного файла.
Отличие двух форм:
􀂈 первая форма директивы предполагает, что подключается стандартный
файл. Поиск файла ведется последовательно в каждом из каталогов, пере-
численных в опциях проекта в порядке их определения. В основном,
Препроцессор. Заголовочные файлы 157
таким образом подключаются заголовочные файлы стандартной библио-
теки, возможно — других библиотек;
􀂈 второй вариант специфицирует определенный пользователем включаемый
файл. Если путь не указан, то сначала препроцессор ищет файл в текущем
каталоге (в том каталоге, в котором находится исходный файл, содержа-
щий #include). Если в текущем каталоге данного файла нет, то поиск про-
должается дальше в перечисленных в опциях проекта каталогах (так же,
как и в первом варианте).
Примеры.
#include <iostream> //указание препроцессору искать файл iostream
в стандартном включаемом каталоге
#include "my.h" //указание препроцессору искать файл my.h сначала
в текущем каталоге, а потом в каталогах проекта
#include "c:\myhdr\my.h" //указание препроцессору искать файл my.h
только в c:\myhdr и нигде больше
ЗАМЕ ЧАНИЕ
Пробелы внутри < > или " " являются значащими.
Поэтому запись #include < iostream > вызовет ошибку — препроцессор не
найдет файл с таким именем.
5.6.3. Вложенные включения заголовочных файлов
(стратегии включения)
Использовать механизм #include тоже можно по-разному. Согласно прави-
лам структурного программирования разработчик группирует логически свя-
занные между собой понятия (функции и данные) в отдельных cpp-файлах.
Как быть с интерфейсами?
Для удобства интерфейсы можно группировать (все, что используется боль-
шинством файлов-клиентов, можно объединить с помощью вложенных
#include). Например, пусть большинство (100) файлов проекта используют
сервисы ОС Windows (заголовочный файл <windows.h>), макросы стандарт-
ной библиотеки, определенные в <tchar.h> и описания используемых всеми
клиентами пользовательских переменных и функций, объявленных в "my.h".
Без группировки заголовочных файлов картина выглядела бы так, как пред-
ставлено на рис. 5.7.
158 Глава 5
Рис. 5.7
Рис. 5.8
Препроцессор. Заголовочные файлы 159
Это означает, что в каждом файле-клиенте (т. е. 100 раз) программист должен
написать последовательность из трех совершенно одинаковых директив
#include. Для того чтобы избежать дублирования текста и избавить програм-
миста от интеллектуального занятия "copy-paste", можно ввести вспомогатель-
ный заголовочный файл, в котором сгруппировать подключение таких заго-
ловочных файлов проекта, используемых большинством клиентов (рис. 5.8).
Тогда для получения доступа к общеиспользуемым внешним понятиям каж-
дому клиенту достаточно подключить этот единственный вспомогательный
файл, в котором сгруппированы все общие интерфейсы. А для получения
специфических для данного конкретного клиента интерфейсов, каждый кли-
ент может подключить дополнительные (специфические для данного клиен-
та) заголовочные файлы.
5.6.4. Предкомпиляция заголовочных файлов
В предыдущем примере для удобства мы просто сгруппировали используе-
мые всеми клиентами заголовочные файлы, чем слегка облегчили жизнь про-
граммисту, но не компилятору. При компиляции любого клиента препроцес-
сор сначала заменит директиву #include "general.h" на содержимое файла
general.h, а затем, в свою очередь, каждую директиву #include из файла
general.h на содержимое соответствующего файла.
Содержимое каждого заголовочного файла — это текст на языке С/С++, ко-
торый компилятор должен синтаксически разобрать, следовательно в нашем
примере он будет сто раз проделывать одну и ту же работу!
Неэффективно заставлять компилятор столько раз анализировать один и тот
же текст (хотя, справедливости ради, стоит отметить, что заголовочные фай-
лы, как правило, содержат только объявления, а на анализ объявлений ком-
пилятор тратит времени меньше, чем на создание кода).
Чтобы минимизировать затраты компилятора, большинство современных
реализаций С++ обеспечивают возможность предварительной обработки
компилятором заголовочного файла и сохранения результатов этой обработ-
ки в промежуточном файле для дальнейшего использования. Такой механизм
называется предкомпиляцией. Компилятор один раз осуществляет синтакси-
ческий разбор заголовочного файла, предназначенного для предкомпиляции,
и сохраняет результат в некотором внутреннем формате (формат может зави-
сеть от конкретного компилятора) в файле с расширением .pch (это расши-
рение принято в VC — от PreCompiled Headers, но расширение файла может
зависеть также и от конкретного компилятора). Эту, уже готовую к исполь-
зованию информацию, компилятор может учитывать при компиляции любо-
го клиента, требующего тот же интерфейс (т. е. не анализировать заново).
160 Глава 5
Предкомпиляция бывает полезной во время цикла разработки для уменьше-
ния общего времени получения загрузочного модуля, особенно если:
􀂈 используется большое количество кода, который не изменяется (систем-
ные заголовочные файлы: <windows.h> или библиотечные — <tchar.h>);
􀂈 во многих файлах-клиентах подключаются одни и те же пользовательские
интерфейсы ("my.h"), которые изменяются редко.
Рис. 5.9
Как использовать предкомпиляцию? Посредством разных опций в командной
строке компилятору исходные файлы можно компилировать по-разному.
Обычно поступают следующим образом (рис. 5.9): кроме модулей-клиентов
в проекте создается вспомогательный файл (пусть в нашем примере он назы-
вается general.cpp), который содержит одну-единственную строчку: #include
"general.h". Этот файл предназначен для единственной цели — создать
Препроцессор. Заголовочные файлы 161
предкомпилированный файл, содержащий результаты синтаксического раз-
бора файла general.h. Он будет компилироваться с ключом компилятору —
\Yc (создать файл предкомпиляции) посредством синтаксического разбора
файла general.h. А все остальные исходные файлы проекта (клиенты) компи-
лируются с ключом \Yu– (использовать файл предкомпиляции). В этом слу-
чае первая компиляция занимает времени много, т. к. создается pch-файл,
зато все последующие уже используют этот полуфабрикат, поэтому суммар-
ное время получения исполняемого файла уменьшается.
ЗАМЕ ЧАНИЕ
Хотя вы можете использовать только один предкомпилированный файл (с рас-
ширением .pch) для каждого исходного cpp-файла, ничто не мешает использо-
вать несколько pch-файлов в одном проекте.
Предкомпиляция — это только один из способов ускорения получения ис-
полняемого файла. Для большинства реализаций существуют несколько спо-
собов ускорения процесса построения приложения, например для VC:
􀂈 предкомпиляция (precompiled headers) — позволяет компилятору не по-
вторять синтаксический разбор общеиспользуемых заголовочных файлов
при компиляции каждого cpp-файла. Обычно в такой предкомпилирован-
ный файл включаются системные и библиотечные заголовочные файлы
(они большие!), а включать свои (особенно на стадии разработки) смысла
не имеет, т. к. одно-единственное изменение в таком файле повлечет пере-
стройку (rebuild) всего проекта. С другой стороны, если в вашем проекте
уже имеются отлаженные, не меняющиеся заголовочные файлы, то вклю-
чение их в предкомпилированный файл ускорит время сборки;
􀂈 incremental linking — позволяет делать сравнительно небольшие измене-
ния в программе (ставить "заплаты"), не перестраивая всю программу.
То есть компилятор предусматривает для каждой функции небольшой ре-
зерв для расширения. Если изменения оказываются достаточно большими,
то осуществляется полная перекомпоновка программы;
􀂈 minimal rebuild — анализирует изменения, которые вы сделали в h-файлах
(в основном это касается объявлений классов), и физически перекомпили-
руются только те cpp-файлы, которые реально зависят от изменений (без
этой опции cpp-файл будет перекомпилирован, даже если вы измените
лишь комментарий во включаемом заголовочном файле).
Такие способы ускорения получения исполняемого модуля можно задать по-
средством опций командной строки компилятору и компоновщику. В интег-
рированных средах это можно сделать в опциях проекта.
162 Глава 5
5.6.5. Заголовочные файлы стандартной
библиотеки
Практически с момента появления языка Си, в понятие реализации (и в ком-
плект поставки, соответственно) входит, помимо компилятора и компонов-
щика, стандартная библиотека или (C Run-Time Library) (сокращенно CRT).
Библиотека включает в себя часто используемые понятия и действия, к кото-
рым программисты на С/C++ уже настолько привыкли, что отождествляют
их с языком программирования. Стандартность библиотеки заключается
в том, что ее составляющие (имена компонентов, их назначение и принципы
применения) должны соответствовать принятым стандартам (т. е. интерфейс
использования функций и других средств стандартной библиотеки должен
быть одинаков, а реализация (внутренняя начинка) может зависеть от кон-
кретного производителя).
Стандартная библиотека С++ создавалась для предоставления программисту:
􀂈 часто используемых функций (printf(), strcpy());
􀂈 макроопределений (va_arg, min);
􀂈 полезных псевдонимов типов (size_t);
􀂈 часто используемых констант (NULL, EOF);
􀂈 глобальных переменных (errno);
􀂈 стандартных типов данных (классов);
􀂈 шаблонов классов, на основе которых программист может строить свои
сложные структуры данных и шаблоны функций для часто используемых
задач, таких как поиск, сортировка и т. д.
ЗАМЕ ЧАНИЕ
Все перечисленное готово к употреблению, и любой компилятор С++, отве-
чающий принятым стандартам, должен все эти понятия поддерживать.
Как использовать возможности стандартной библиотеки
Стандартная библиотека предоставляет программисту свои возможности по-
средством набора стандартных заголовочных файлов. Сервисы, предостав-
ляемые стандартной библиотекой С++, можно условно разделить на три ка-
тегории (рис. 5.10).
􀂈 STL (Standard Template Library) — библиотека шаблонов (в данной книге
не рассматривается):
• контейнеры (заготовки для сложных типов данных, таких как векторы,
списки, деревья и т. д.);
Препроцессор. Заголовочные файлы 163
Рис. 5.10
164 Глава 5
• обобщенные алгоритмы (алгоритмы для работы с контейнерами любо-
го типа);
• итераторы (средства для навигации по любым контейнерам).
􀂈 Ввод/вывод — средства форматирования и управления операциями ввода/
вывода (вывод на экран, ввод с клавиатуры, работа с файлами и т. д.).
􀂈 Остальные возможности: математические функции (sqrt, pow, sin, atof,
функции Бесселя и т. д.), функции для работы со строками (поскольку та-
ких встроенных типов данных, как строки, в языке С/С++ нет), средства
для локализации программ, манипулирования датами, временем и т. д.
Новые заголовочные файлы стандартной библиотеки
По мере развития языка С++, стандартная библиотека тоже развивалась,
расширялась и совершенствовалась (рис. 5.11). Сначала была разработана
библиотека Си, потом появились классы (библиотека пополнилась полезны-
ми классами С++), потом появились шаблоны (в библиотеку добавили кон-
тейнеры, обобщенные алгоритмы и итераторы). А потом был утвержден
стандарт ISO/IEC 14882 (Standard for the C++ Programming Language…), и как
использование, так и состав стандартной библиотеки были унифицированы.
Рис. 5.11
Согласно стандарту, заголовочные файлы были переименованы (поэтому ре-
комендуется использовать имена заголовочных файлов в новом стиле). Пра-
вила, по которым были сформированы названия новых заголовочных файлов,
достаточно просты:
􀂈 в заголовочных файлах, которые появились только в С++, просто опущено
расширение (<iostream.h> переименовали в <iostream>);
Препроцессор. Заголовочные файлы 165
СУЩЕ СТ ВЕ ННО
Содержимое двух таких файлов может быть принципиально разным!
􀂈 в заголовочных файлах, которые пришли из языка Си, опущено расшире-
ние и перед названием добавлен символ c (<math.h> переименовали
в <cmath>). Такие файлы в основном являются просто обертками для соот-
ветствующих нестандартизованных заголовочных файлов с прежним со-
держимым.
РЕ К О МЕ Н Д А Ц И Я
Так как изменились не только названия, но в большинстве случаев и содержи-
мое заголовочных файлов, то старые файлы использовать не рекомендуется,
а тем более смешивать новые и старые (хотя в большинстве реализаций парал-
лельно с новыми библиотечными файлами продолжают существовать старые).
ЗАМЕ ЧАНИЕ
Забавно, что некоторые сервисы пока существуют одновременно в трех реали-
зациях. Например, строковые функции поддерживаются тремя заголовочными
файлами: <string.h> — процедурно-ориентированные строковые функции,
<cstring> — новая обертка для string.h и <string> — классы (вернее, шаблоны
классов) поддержки работы со строками.
СУЩЕ СТ ВЕ ННО
Новые сервисы стандартной библиотеки заключены в пространство имен std.
Например:
//Файл <iostream>
namespace std{
объявления
}
Специфика Microsoft: для заголовочных файлов, пришедших из Си-
библиотеки, сделано примерно следующее: согласно стандарту все понятия
заключены в пространство имен std, но тут же посредством директивы using
разрешается их видимость, т. е. к ним разрешается обращаться без префикса:
//Файл <cmath>
namespace std{
#include <math.h>
}
using namespace std;
166 Глава 5
Стандартная библиотека C++ в соответствии с новым стилем вместо имен
заголовочных файлов использует стандартные идентификаторы, посредством
которых препроцессор находит требуемое содержимое. Новые заголовки С++
являются абстракциями, гарантирующими объявления соответствующих сер-
висов стандартной библиотеки. Для преемственности новые идентификаторы
по-прежнему включаются в исходный файл директивой #include. Старый
заголовочный файл всегда должен находиться на жестком диске (в него
можно заглянуть, как и в любой текстовый файл). Новые заголовки в пер-
спективе могут стать виртуальными. При этом предполагается, что препро-
цессор по идентификатору всегда сможет найти содержимое заголовочного
файла (будет ли этот файл на диске или препроцессор загрузит требуемую
информацию каким-либо другим способом).
5.6.6. Защита от повторных включений
заголовочных файлов
Иногда (обычно неявно) программист создает такую ситуацию, когда при
компиляции исходного файла препроцессор встречает несколько раз включе-
ние одного и того же заголовочного файла. В некоторых случаях такое по-
вторное подключение приводит к ошибкам компилятора (рис. 5.12).
Рис. 5.12
В этой ситуации при обработке препроцессором исходного файла my.cpp
текст интерфейсного файла 2.h будет включен дважды, и компилятор выдаст
ошибку: повторное определение enum COLOR.
Для того чтобы избежать повторного подключения, удобно использовать ди-
рективы условной трансляции препроцессора так, как это показано на рис. 5.13.
При первом подключении файла 2.h имя HEADER_2 для препроцессора не оп-
ределено, поэтому весь текст файла 2.h препроцессор подставляет вместо
строки #include "2.h". А на момент вторичного подключения того же заго-
Препроцессор. Заголовочные файлы 167
ловочного файла имя HEADER_2 уже является для препроцессора определен-
ным, поэтому весь текст файла 2.h до директивы #endif препроцессор игно-
рирует.
Рис. 5.13
5.6.7. Что может быть в заголовочных файлах
и чего там быть не должно
За небольшим количеством исключений, в заголовочных файлах могут быть
только объявления (табл. 5.5), они не должны содержать определений (табл. 5.6).
Это скорее рекомендация, а не требование языка. Она просто отражает ра-
зумный способ использования заголовочных файлов (Б. Страуструп). Компи-
лятор позволит вам не следовать этим рекомендациям, но тогда от использо-
вания механизма подключения заголовочных файлов вы получите
неприятностей больше, чем выгод (см. следующий раздел).
Таблица 5.5. Что может быть в заголовочном файле
Что может содержать заголовочный файл Пример
Вложенные директивы #include #include "general.h"
Объявления функций, определенных в другом
модуле
[extern] void MyFunc();
Определение встроенных (inline) функций inline void MyInlineFunc()
{ тело_функции }
Объявления внешних переменных, определен-
ных в другом модуле
extern int Global;
168 Глава 5
Таблица 5.5 (окончание)
Что может содержать заголовочный файл Пример
Определения простых констант const double pi = 3.141593;
Перечисления enum color{RED, GREEN,
BLUE};
Директивы условной трансляции #if !defined HEADER_2
…
#endif
Макроопределения #define VERSION 1
Именованные пространства имен namespace Version{
extern int currentVersion;
...}
Объявления структур, объединений, классов struct Point{int m_x,
m_y;};
Предварительное неполное объявление class Point;
Определения шаблонов template<class T> class
MyTempl{...};
Объявления шаблонов template<class T> class
MyTempl;
Таблица 5.6. Чего в заголовочном файле быть не должно
Что не следует помещать в заголовочный
файл
Пример
Определения невстроенных функций void MyFunc(){ тело_функции }
Определения данных int a;
char Ar[] = {'A', 'B', 'C'};
Неименованные пространства имен namespace{...}
Почему не стоит помещать в заголовочные файлы
определения и подключать файлы реализации (.cpp)
Заголовочные файлы могут содержать любой допустимый текст на языке
C/C++, в частности — ничто не мешает программисту поместить в заголо-
вочный файл определения переменных или функций (рис. 5.14). Так как
#include — это просто текстовая подстановка, то в файлах 1.cpp и 2.cpp
(в том тексте, который пойдет на компиляцию) будут определены две пере-
менные, подлежащие внешней компоновке, с одним и тем же именем. При
сборке компоновщик обнаружит двойное определение и выдаст ошибку.
Препроцессор. Заголовочные файлы 169
Рис. 5.14
Поэтому структурный подход к оформлению исходных текстов предполагает,
что каждый сервер предоставляет свои сервисы в двух частях: интерфейсный
файл, содержащий только объявления (описания свойств экспортируемых
понятий), и файл реализации, содержащий определения (встречая определе-
ние переменной, компилятор выделяет память, встречая определение функ-
ции — генерирует код). Тогда для того чтобы воспользоваться внешними
понятиями, клиенту достаточно подключить файл интерфейса, а определения
будут существовать в единственном экземпляре.
По той же причине не рекомендуется подключать файлы реализации. Несмот-
ря на то что директиву #include можно использовать для подключения файла
с любым содержимым и любым расширением (это просто текстовая подста-
новка), подключение несколькими клиентами одного и того же файла реали-
зации снова приведет к повторным определениям.
170 Глава 5
5.7. Директива #pragma
Синтаксис:
#pragma имя_директивы
Посредством директивы #pragma программист имеет возможность давать
указания препроцессору, компилятору, а опосредованно — и линкеру.
Специфика:
􀂈 каждая реализация C/С++ может поддерживать какие-то особенности,
уникальные для используемого процессора или ОС. Директива #pragma по-
зволяет настраиваться на реализацию, не модифицируя текст программы;
􀂈 эти директивы зависят от конкретной реализации (от конкретного препро-
цессора). Если препроцессор встречает #pragma-директиву, которую он не
распознает, то ничего не делает и генерирует не ошибку, а предупреждение;
􀂈 если некоторые #pragma-директивы дублируют опции командной строки
компилятора или компоновщика, то первые являются по отношению ко
вторым более приоритетными;
􀂈 в отличие от опций командной строки (которые применяются ко всему
файлу в целом), #pragma-директивы позволяют применять действия к от-
дельным функциям и переменным.
Пример 1.
C помощью #pragma check_stack можно дать указание компилятору вставлять
(или наоборот исключать) в генерируемый низкоуровневый код проверку
(хватает ли места в стеке для размещения локальных переменных). Если па-
мяти не хватает, то генерируется исключение.
#pragma check_stack(on)
void f()
{// проверка
…
}
#pragma check_stack(off) //отключает проверку
#pragma check_stack() //восстанавливает параметры командной строки
Пример 2.
Посредством #pragma optimize можно предписать компилятору оптимизиро-
вать при генерации кода время, память…:
#pragma optimize ("t",on) //включает оптимизацию по времени
…
Препроцессор. Заголовочные файлы 171
#pragma optimize ("",on) //восстанавливает параметры командной
строки
Пример 3.
Посредством #pragma once можно избежать повторных подключений заголо-
вочных файлов. Модифицируем пример из предыдущего раздела (рис. 5.15).
VC предоставляет возможность посредством #pragma once сообщать препро-
цессору, что остаток текста до конца файла нужно игнорировать при повтор-
ных подключениях данного заголовочного файла.
Рис. 5.15
5.8. Директива #error
Если препроцессор встречает директиву #error, он прекращает формировать
текст для компилятора и в качестве диагностики выдает сообщение, преду-
смотренное программистом.
Пример.
#if !defined _WIN32
#error Valid only in Win32 applications
#endif
Глава 6
Указатели и массивы
В языке C/C++ существует взаимосвязь между указателями и массивами на-
столько сильная, что их следует рассматривать одновременно. При объясне-
нии одного понятия неизбежны ссылки на другое. Поэтому, начиная тему
с рассмотрения указателей, введем очень примитивное понятие массива.
Массив можно рассматривать как один (сложный) программный объект. На
самом деле массив — это совокупность элементов одного и того же типа
(пронумерованных с нуля, последовательно расположенных в памяти), к ко-
торым можно обращаться по номеру (индексу).
6.1. Указатели
Указатель — это бумеранг. Если умеешь
им пользоваться, возвращаешься с добы-
чей (получаешь эффективный код), а если
не умеешь…
При выполнении программы фрагменты программного кода и элементы дан-
ных располагаются в различных участках оперативной памяти, каждый из
которых имеет свой (уникальный) адрес. Обращение к любому элементу C/C++
программы (имеется в виду переменная базового типа, функция или объект
более сложного типа) можно осуществить, зная его адрес.
Такой способ, когда для обращения к объекту программист явно использует
адрес объекта, называется косвенным обращением. Для представления адреса
в C/C++ предназначен тип данных, называемый указателем.
Указатель — это переменная, содержащая адрес другого элемента C/C++
программы. Если переменная содержит адрес некоторого другого элемента,
то говорят, что переменная указывает на этот элемент.
174 Глава 6
Указатель может указывать на любой программный объект (рис. 6.1):
􀂈 на обычную переменную;
􀂈 на более сложные типы данных:
• массив (см. разд. 6.3);
• строку (см. разд. 6.1.2);
• структуру (см. разд. 9.11);
• другой указатель (см. разд. 6.1.7);
• функцию (см. разд. 8.11).
Указатели подразделяются на две основные категории:
􀂈 указатели на данные;
􀂈 указатели на функции.
Хотя оба типа указателей представляют собой адрес, они имеют различные
свойства, назначение и правила работы с ними. В данной главе рассматрива-
ются только указатели на элементы данных. Указатели на функции будут
рассмотрены в гл. 8.
Рис. 6.1
Указатели и массивы 175
6.1.1. Объявление и определение
переменной-указателя
Указатель всегда содержит адрес, а каким образом компилятор должен ин-
терпретировать этот адрес, сообщает ему программист, задавая тип указы-
ваемого объекта!
Например:
int* p1; //объявление, совмещенное с определением, где:
p1 – имя переменной-указателя,
int – тип указываемого объекта,
символ * говорит о том, что p1 — это указатель.
В этом случае компилятор должен зарезервировать
память для p1 (4 байта на 32-разрядной платформе)
double* p2; //p2 – имя переменной-указателя,
double* - тип переменной.
Зарезервирована память для указателя p2 – 4 байта
extern char* p3; //а это только объявление внешней переменной-
указателя, которая определена в другом модуле.
Сравним, каким образом компилятор выделяет память под объекты и под
указатели на объекты (рис. 6.2). Количество байтов, выделяемых компилято-
ром под объект, зависит от типа объекта. Количество байтов, выделяемых
для хранения адреса, не зависит от типа объекта, а определяется только аппа-
ратными особенностями используемого процессора — разрядностью регист-
ров (фиксирована для каждой конкретной архитектуры), предназначенных
для хранения адресов.
ЗАМЕ ЧАНИЕ
Существует лишь очень небольшое количество архитектур, в которых может
использоваться несколько видов указателей, различающихся размерами. При-
мер такой архитектуры: семейство Intel MCS-52/251 — в ней указатели могут
иметь размер 1, либо 2, либо 3 байта.
Специфические особенности указателей:
􀂈 при объявлении указателя компилятору все равно, где располагается символ *.
То есть все приведенные ниже способы объявления указателя синтаксиче-
ски корректны. Каждое из них означает, что объявляется указатель (пере-
менная с именем pn), которая может содержать адрес переменной типа int;
int* pn;
int *pn; //или так
int * pn; //и так тоже можно
int*pn; //и даже так
176 Глава 6
Рис. 6.2
􀂈 указатель может содержать адрес как одиночной переменной некоторого
типа T, так и адрес одного из элементов массива (см. разд. 6.2). Об этом
знает только программист, у компилятора такой информации нет;
􀂈 при определении указателя вида T* p; (без инициализации) выделяется
память для переменной типа указатель, но сам указатель пока ни на что не
указывает, поскольку его значение (т. е. адрес) еще не сформировано.
Корректный адрес должен быть присвоен указателю до его первого ис-
пользования. Это рекомендуется (но не обязательно) делать при определе-
нии указателя;
􀂈 в зависимости от контекста определения компилятор может выделить па-
мять под указатель в разных областях, независимо от того, где находится
сам указываемый объект (о выделении памяти при объявлении перемен-
ных см. разд. 3.7). Память под указатель может быть выделена:
• в стеке (локальный указатель);
• в статической области данных (глобальный или статический);
• в "куче" (динамический указатель);
Указатели и массивы 177
Например:
int* p; //глобальный
void f()
{
int* p1; //локальный
static int* p2; //статический
}
􀂈 после объявления указателя на один тип попытка использования этого
указателя для ссылки на другой тип (без явного преобразования типа)
приведет к ошибке при компиляции (см. разд. 6.1.9):
int* p;
double* p1=p; //ошибка: компилятор не может преобразовать int*
к типу double*
При объявлении указателей можно использовать объявление списком, но на-
чинающий программист легко может допустить следующую ошибку:
//программист хочет объявить три указателя, вот так:
int* p1,p2,p3; //а компилятор считает, что объявлен один указатель
p1 и две переменные типа int — p2, p3
int* p4, *p5, *p6 //а теперь компилятор считает, что объявлены три
указателя
Подумайте, в чем заключается разница приведенных примеров (табл. 6.1).
Что объявлено?
Таблица 6.1. Задания на интерпретацию объявлений
Номер Задание
1 typedef char* PCHAR;
PCHAR p1,p2;
2 define PCHAR char*
PCHAR p1,p2;
6.1.2. Инициализация указателя
и оператор получения адреса объекта — &
Если программист не проинициализировал переменную-указатель при опре-
делении, то компилятор будет инициализировать указатели по общим прави-
лам (см. разд. 3.9.2). Глобальные указатели, указатели, заключенные в про-
178 Глава 6
странства имен, и указатели, объявленные с ключевым словом static, неявно
(по умолчанию) инициализируются нулем. Локальные и динамические указа-
тели неявно компилятором не инициализируются, т. е. значение указателя
после объявления не определено!
Для того чтобы воспользоваться указателем, программист должен сформиро-
вать в такой переменной адрес объекта. Это можно (и предпочтительнее)
сделать при определении указателя, явно проинициализировав переменную
посредством оператора получения адреса объекта &:
int n=1; //переменная типа int
int* pn=&n; //определение указателя на объект типа int и инициализация
указателя адресом переменной n с помощью унарного
оператора получения адреса — &
Действия со строковыми литералами в языке С/С++ всегда имеют особенности.
В частности, рассмотрим специфику инициализации указателя адресом стро-
кового литерала:
char* pStr = "Строка"; // компилятор отводит память для хранения
строкового литерала (массива символов), а указателю
присваивается адрес начала строки (адрес первого
символа)
//или эквивалентное выражение:
char* pStr = &"Строка"; //синтаксически оба варианта корректны
и смысл их одинаков
ЗАМЕ ЧАНИЕ 1
Оператор & можно применять только к объектам, с которыми компилятор ассо-
циирует выделенную память, поэтому следующие примеры вызовут сообщение
компилятора об ошибке:
//int* p = &0xff00; //ошибка: нельзя определить адрес константы
int value=2;
//int* pV = &(value*3); //ошибка: нельзя определить адрес
результата, получаемого при вычислении арифметического
выражения справа от знака равенства
ЗАМЕ ЧАНИЕ 2
Нельзя присвоить указателю абсолютное значение без явного приведения типа
(см. разд. 6.1.9), исключение составляет нулевое значение:
//int* p = 0x100000; //ошибка: компилятор не может преобразовать
int к типу int*
int* p = reinterpret_cast<int*>(0x100000); //корректно
int* p1 = 0; //корректно
Указатели и массивы 179
Выполните задания, приведенные в табл. 6.2.
Таблица 6.2. Задания на использование оператора получения адреса
Номер Задание Подсказка
1 Подумайте, каким образом будет проинициализиро-
ван указатель?
int* p = &((x>y) ? x : y);
См. разд. 2.4.5
2 Являются ли корректными оба выражения?
int* p1 = &(++x);
int* p2 = &(x++);
См. разд. 2.4.1
6.1.3. Получение значения объекта посредством
указателя: оператор разыменования — *
Сам по себе адрес объекта обычно особой ценности не представляет. Он слу-
жит лишь средством для доступа к объекту, на который указывает, и во многих
случаях использование указателя может повысить эффективность вычислений.
Например:
int* p; //объявление указателя
//формирование значения p
int n=*p; //унарный оператор * интерпретирует операнд p как
адрес и обращается по этому адресу, чтобы извлечь содержимое
ПР А В И Л О
Сравните объявление указателя с операцией получения значения по указате-
лю. Это поможет вам сформулировать простое мнемоническое правило, кото-
рое будет полезно при использовании любых сложных описаний: если объяв-
лен указатель p на объект типа T, то выражение *p эквивалентно объекту
типа T.
Пусть даны:
x=1;
int* p=&x;
Попробуйте при одних и тех же исходных данных описать последователь-
ность действий компилятора и получите значение переменной n в приме-
рах, приведенных в табл. 6.3.
180 Глава 6
Таблица 6.3. Задания на использование оператора разыменования
Номер Задание
1 n= *(p++);
2 n= (*p)++;
3 n = ++(*p);
4 n = *(++p);
ЗАМЕ ЧАНИЕ
Выражение int n = *(reinterpret_cast<int*> (0x42bb18)); будет верно
только в том случае, если константа представляет собой корректный адрес. Такой
прием не имеет особого смысла, если вы разрабатываете Windows-приложение,
которое выполняется в защищенном режиме (т. е. ошибки при компиляции
не будет в любом случае, а ошибка периода выполнения вполне вероятна!).
Однако именно так порой приходится поступать при работе с периферийными
устройствами, если в вычислительной системе реализован ввод/вывод, ото-
бражаемый на память (см. разд. 6.1.9 и разд. П2.1 приложения).
Как для переменной-указателя, так и для указываемого значения компилятор
выделяет память. Как определить объем зарезервированной памяти? Опера-
тор sizeof можно использовать для определения размера любого объекта,
в частности с помощью этого оператора можно определить размер указателя:
double d = 1.1;
double* pd = &d;
size_t n1 = sizeof(pd); //n1=4 на 32-разрядной платформе
size_t n2 = sizeof(char*); //такой же результат
Подумайте, чему будут равны n3 и n4?
size_t n3 = sizeof(*pd);
char* pc = "abc";
size_t n4 = sizeof(*pc);
6.1.4. Арифметика указателей
Важными особенностями арифметических операций с указателями являются:
􀂈 физическое изменение значения адреса, который хранится в указателе,
зависит от типа (т. е. от размера) указываемого объекта;
􀂈 при выполнении действий с указателем компилятор всегда интерпретиру-
ет то, на что указывает указатель Т*, как совокупность (массив) элементов
типа Т. А на что действительно указывает указатель (одиночный объект
или массив объектов), знает только программист.
Указатели и массивы 181
Рассмотрим, что можно делать с указателями:
int n = 1;
int* pn1=&n; //определен и проинициализирован указатель pn1
int* pn2; //определен pn2
Пример 1.
Адрес можно копировать из одного указателя в другой того же типа (рис. 6.3):
pn2=pn1; //компилятор копирует значение адреса из переменной pn1
в переменную pn2, т. е. теперь оба указателя содержат
адрес переменной n
//double* pd = pn1; //ошибка: указатели разного типа
Рис. 6.3
Пример 2.
К указателю можно прибавить (или из него вычесть) значение, но только целое:
pn1++; //смысл такой операции заключается в том, что указатель
должен переместиться в памяти на следующий объект того же
типа, например, на следующий элемент массива, поэтому
компилятор прибавляет к адресу, хранящемуся в указателе,
размер объекта, в нашем случае sizeof(int)=4)
int n = 5;
pn2=pn1+n; //а здесь компилятор должен вычислить адрес элемента,
отстоящего на n элементов от pn1. То есть значение,
182 Глава 6
которое будет присвоено pn2, вычисляется как сумма
значения адреса, хранящегося в pn1, плюс n*sizeof(типа),
в нашем случае плюс 5*sizeof(int)=20
//pn2=pn1+1.1; //ошибка: прибавлять к указателю
можно только целое!
Пример 3.
Указатели одного типа можно вычитать (результат вычитания говорит о том,
на сколько элементов один адрес отстоит от другого):
int number=pn2 – pn1; //результат вычисляется компилятором следующим
образом: это разность значений, поделенная
на sizeof(типа), в данном случае 5
Пример 4.
Два указателя одного типа можно всегда сравнить на равенство/неравенство
(т. е. выяснить, указывают ли они на один и тот же объект):
if(pn2 == pn1){…} //или !=
А если указываемые объекты не только одного типа, но еще и последова-
тельно расположены в памяти (например, содержат адреса элементов одного
массива), то их также имеет смысл сравнивать с помощью операторов: <, <=,
>, >=.
if(pn2 > pn1) {…}
ЗАМЕ ЧАНИЕ
Сложение указателей бессмысленно — невозможно никаким образом интер-
претировать такое действие, поэтому оно запрещено (компилятор выдаст
ошибку)!
6.1.5. Указатель типа void*
Любой указатель содержит адрес, значение которого не зависит от того, ка-
кого типа указываемый объект. Информация о типе указываемого значения
становится необходимой компилятору только тогда, когда он оперирует со-
держимым по адресу, хранящемуся в указателе.
В языке С/С++ существует специальный вид указателя — void*. Такие указа-
тели обладают важным свойством — они могут содержать адрес объекта
любого типа (листинг 6.1). Но только до тех пор, пока программисту не пона-
добится оперировать содержимым по этому адресу (т. е. это лишь отсрочка
указания типа!). Как только компилятор встретит в программе любые дей-
ствия над void*-указателем, он потребует от программиста указаний, каким
Указатели и массивы 183
образом интерпретировать адрес, иначе компилятор не сможет сгенерировать
низкоуровневый код. Это означает, что программист должен объяснить ком-
пилятору, каков на самом деле тип указываемого значения.
ЗАМЕ ЧАНИЕ
Хотя тип void является базовым (см. разд. 3.4.2), он не является самостоя-
тельным типом, а может использоваться только в более сложных объявлениях.
Применительно к указателям, ключевое слово void говорит об отсутствии ин-
формации о свойствах указываемого объекта, в частности — данных о размере
объекта.
Листинг 6.1. void*-указатель можно направить на объект любого типа
void* pVoid; //определение void*-указателя. Компилятор
зарезервировал память для переменной,
но адрес в ней еще не сформирован
int n=1;
char c='A';
int* pn=&n;
pVoid=&n; //присвоили void*-указателю адрес переменной типа int
pVoid=&c; //а теперь занесли в тот же указатель адрес переменной
типа char
pVoid=pn; //и это корректно
Компилятор позволит присвоить void*-указателю адрес любого объекта, при
этом он осуществляет неявное преобразование типа (например, int* в void*).
Но обратное неверно!
Чтобы манипулировать void*-указателем, необходимо явно объяснить ком-
пилятору, каков тип указываемого объекта. Для явного приведения void*-
указателя к указателю на требуемый тип используется оператор приведения
static_cast (листинг 6.2), т. к. в таких ситуациях компилятор доверяет про-
граммисту, считая, что последний знает, что делает. При этом следует учесть,
что компилятор на самом деле не знает типа объекта, на который указывает
void*-указатель, поэтому результат явного преобразования типа лежит
полностью на совести программиста.
Листинг 6.2. Манипулирование void*-указателем
//Это продолжение листинга 6.1.
//pn = pVoid; //ошибка: несмотря на то, что обе переменные
содержат адрес, компилятор заставит программиста
184 Глава 6
уточнить, адрес объекта какого типа содержит
void*-указатель
pn=static_cast<int*>(pVoid); //явное приведение типа void* к типу
int* посредством нового оператора
приведения типа
pn=(int*) pVoid; //явное приведение в старом стиле (согласно
стандарту данная форма устарела и
предпочтительным является использование
static_cast)
//int m=*pVoid; //ошибка: для того, чтобы получить значение
по адресу, нужно знать, какого типа это значение
int n=*(static_cast<int*> (pVoid) ); //получение значения по
адресу, хранящемуся в void*-указателе
Подумайте, являются ли корректными оба выражения и чему будет равен
результат?
size_t n1 = sizeof(pVoid);
size_t n2 = sizeof(*pVoid);
ЗАМЕ ЧАНИЕ
Как правило, небезопасно обманывать компилятор и приводить void*-указатель
к указателю на тип, отличный от того, на который на самом деле void*-указатель
в данный момент указывает.
Например, форматы представления в памяти целых (см. разд. П1.2—П1.5
приложения) и плавающих чисел (см. разд. П1.11 приложения) совершенно
разные, поэтому в следующем примере наивный программист может полу-
чить странные результаты:
int n = 99;
void* pVoid = &n; //void*-указателю присвоили адрес переменной
типа int
float d = *(static_cast<float*>(pVoid)); //для тех, кто не знает
форматов хранения целых и плавающих, но надеется получить 99.0,
результат окажется "приятным" сюрпризом
6.1.6. Нулевой указатель (NULL-pointer)
Нулевое значение указателя в языке C/C++ имеет специальное назначение —
это признак того, что указатель никуда не указывает и, следовательно, не
может быть использован. В частности, если на момент определения указателя
Указатели и массивы 185
по каким-то причинам его невозможно инициализировать конкретным адре-
сом, рекомендуется присвоить такому указателю нулевое значение. Это дела-
ет вашу программу более устойчивой, т. к. выявить нулевой указатель при
выполнении программы гораздо легче, чем неинициализированный.
Например:
int* p = 0; //нулевое значение — это признак того, что указатель
никуда не направлен
… //предполагается, что по ходу выполнения программы указателю
будет присвоен адрес переменной
if(p) {…} //если указатель ненулевой, то можно его использовать
для получения значения
else {…} //а если указатель остался нулевым, то нужно
предпринимать какие-то другие действия
Вместо нуля для обозначения такого признака можно использовать специ-
альное макроопределение NULL, которое определено в нескольких заголовоч-
ных файлах стандартной библиотеки (в частности, в <cstdlib>, <string>,
<tchar.h>), следующим образом:
#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif
В DEBUG-версии проекта стандартная библиотека предоставляет макрос assert()
(см. разд. 5.2.3), который можно, в частности, использовать для выявления
нулевых указателей.
Например:
int* p = 0;
… //программист уверен, что при выполнении программы в указателе
обязательно будет сформирован корректный адрес
assert(p!=NULL); //а вдруг указатель все-таки остался нулевым?
Тогда такую ситуацию можно будет отследить
на этапе отладки
//или assert(p)
186 Глава 6
6.1.7. Указатель на указатель
Сам указатель (как и любая переменная) тоже имеет адрес, значение которого
можно получить аналогично получению адреса любой переменной (рис. 6.4,
листинг 6.3).
T object; //переменная object - это объект типа T, где под Т
имеется в виду любой тип
T* p = &object; //переменная p содержит адрес объекта типа T
T** pp = &p; //переменная pp содержит адрес указателя
на объект типа T
//и т.д. как в сказке "Дом, который построил Джек".
Рис. 6.4
Указатели и массивы 187
Листинг 6.3. Конструкции типа указатель на указатель
double d=1.1;
double* pd=&d;
double** ppd=&pd;
double*** pppd=&ppd;
//а теперь последовательно разыменовывая каждый указатель,
получим значение переменной d:
double d1 = *pd;
d1 = **ppd;
d1 = ***pppd;
// к каждому указателю применимы правила арифметических действий
с указателями:
pd++; //значение адреса изменится на sizeof(double)
}
На сколько байтов изменится значение каждого указателя после инкре-
мента?
ppd++;
pppd++;
6.1.8. Указатель и ключевые слова const и volatile
Ключевые слова const и volatile (см. разд. 3.10) могут быть использованы
при объявлении указателя. Эти слова являются указанием компилятору, ка-
ким образом следует в дальнейшем обращаться с таким указателем (в отли-
чие от обычных указателей).
ЗАМЕ ЧАНИЕ
Далее в основном рассматривается использование ключевого слова const.
Правила для volatile такие же.
Ключевое слово const может относиться к значению адреса, или к значению
указываемого объекта, или к обоим значениям одновременно. Как объяснить
компилятору, что именно является константой? Если ключевое слово const
находится в объявлении слева от *, то константным является указываемое
значение, а если справа от * — то сам указатель.
Рассмотрим специфику использования ключевого слова const (volatile).
Пример 1.
Указываемое значение является константой (листинг 6.4).
188 Глава 6
Листинг 6.4. Константное указываемое значение
{
const char* pc; //указатель на константное значение. Так как сам
указатель не является константой, инициализация
при объявлении не обязательна (разд. 3.10.1)
char const* pc1; //или так (граница константности проходит по *)
pc="ABC"; //направили указатель на строковый литерал.
Так как строковый литерал доступен только для чтения
(во всяком случае, в защищенном режиме процессоров x86
(разд. 3.2.4), то посредством указателя нельзя
допускать модификации значения по адресу
char c = *pc; //читать можно
pc++; //изменять сам указатель можно
//*pc = 'W'; //ошибка: изменять содержимое по адресу запрещено
volatile char* pv; //указываемое значение может быть изменено
извне, поэтому компилятор не должен
оптимизировать действия с содержимым
посредством данного указателя
//Замечание. Компилятор С++ не позволит присвоить обычному указателю
адрес, хранящийся в указателе на константное значение,
т. к. иначе появилась бы возможность модифицировать
константное значение посредством обычного указателя
//char* p=pc; //ошибка, иначе с помощью p можно было бы изменить
значение по адресу, которое посредством pc было
защищено от модификации
//char* p1=pv; //ошибка, иначе компилятор не смог бы отменить
оптимизацию при манипулировании содержимым
посредством p1
}
Пример 2.
Указатель является константой — адрес изменять нельзя (листинг 6.5).
Листинг 6.5. Константный указатель
{
char c='A';
char* const pc = &c; //указатель является константой.
Указатели и массивы 189
Инициализация обязательна!
*pc = 'B'; //ничто не мешает изменять значение по этому адресу
//pc++; //ошибка: попытка изменения адреса
(запрещено перенаправлять такой указатель)
extern char* volatile pv; //значение указателя может быть изменено
извне, поэтому компилятор не должен
оптимизировать действия с указателем
}
Пример 3.
И указатель, и указываемое значение являются константами (листинг 6.6).
Листинг 6.6. Константный указатель на константное значение
{
int x=1, z=2;
const int* const pn =&x; //константный указатель на константное
значение. Инициализация обязательна
//или int const* const pn =&x; //или так
int y=*pn; //читать можно
//*pn = 5; //ошибка: модифицировать значение по адресу запрещено
//pn = &z; //ошибка: модифицировать адрес запрещено
}
Пример 4.
Если требуется сформировать указатель на константную переменную, то та-
кой указатель должен быть также объявлен как указатель на константу (лис-
тинг 6.7).
Листинг 6.7. Формирование указателя на константную переменную
{
const int n = 1;
//int* pn1 = &n; //ошибка: иначе появилась бы возможность
модифицировать константное значение посредством
такого указателя, например (*pn1)++;
const int* pn1 = &n; //корректно: такой указатель можно
использовать только для чтения значения
190 Глава 6
//Замечание. Это как раз тот случай, когда даже оптимизирующий компилятор
С++ будет не просто подставлять значение 1 везде, где
встретит имя n, а отведет память под такую переменную
(см. разд. 3.10.1), т. к. программисту понадобился адрес
этой переменной.
}
Пример 5.
Рассмотрим неявное преобразование const-указателей (volatile-указателей).
Компилятор считает корректным присвоение значения константного указате-
ля обычному не константному указателю того же типа (листинг 6.8).
Листинг 6.8. Неявное приведение типа T* const в T*
{
int *const cp = &x; //указатель cp модифицировать запрещено
int *p; //а это совсем другая переменная, поэтому она имеет
право изменяться
p = cp; //корректно. Неявное приведение типа int* const к int*.
Обе переменные содержат один и тот же адрес, но
одну позволено модифицировать, а другую — нет
p++; //корректно
//cp++; //ошибка: попытка модификации константного указателя
//cp = p; //ошибка: попытка присвоить новое значение константному
указателю
}
Возможно преобразование Т* в const T* (т. е. если речь идет об ужесточе-
нии ограничений на действия с указателем, компилятор тоже справляется сам
неявно). Обычно такая ситуация возникает при вызове функции (подробную
информацию о функциях см. в гл. 8), принимающей в качестве параметра
указатель вида const T* (это означает, что внутри функции нельзя модифи-
цировать значение по переданному адресу, а можно только читать). При этом
в вызывающей части программы этот адрес может быть предназначен как
для чтения, так и для записи (листинг 6.9). Обратное неверно: смягчить огра-
ничения (const Т* в T*) компилятор не позволит!
Листинг 6.9. Неявное приведение типа T* в const T*
void f1(const int* p)
{
//(*p)++; //ошибка: нельзя модифицировать значение по адресу
Указатели и массивы 191
}
void f2(int* p)
{
(*p)++; //а в этой функции изменять значение посредством указателя
разрешено
}
int main()
{
int m=1;
int* pm = &m;
(*pm)++; //OK: модифицировать значения посредством указателя
разрешено
f1(pm); //при вызове функции компилятор преобразует тип int* к
типу const int*
const int* pc = &m;
//(*pc)++; //ошибка: посредством этого указателя значение изменять
нельзя
//f2(pc); //ошибка: компилятор не может преобразовать const int*
к типу int*
}
Пример 6.
Нельзя void*-указателю присвоить адрес переменной, объявленной как const
или volatile (листинг 6.10).
Листинг 6.10. void*-указатель и ключевые слова const и volatile
{
const int m = 1;
//void* p1 = &m; //ошибка: если бы компилятор такое допускал,
то с помощью void-указателя можно было бы
модифицировать значение по адресу
void const* p1= &m; //OK: такой указатель может указывать на все,
что угодно (при условии, что это const)
extern volatile int v;
//void* p2 = &v; //ошибка: если бы компилятор такое допускал,
то не смог бы отменить оптимизации при
обращении к volatile-объекту посредством
void*-указателя
void volatile* p2 = &v; //OK
}
192 Глава 6
Пример 7.
Сложные объявления:
const int* p1,*p2; //это два указателя типа const int*,
инициализация необязательна
int n = 1;
int* const p3=&n,*p4; //p3 – константный указатель,
инициализация обязательна,
p4 – обычный указатель типа int*
Подумайте, что означает каждое объявление, и если по вашему мнению требу-
ется инициализация, то исправьте:
int* const p5,* const p6;
int * const * p7;
6.1.9. Явное преобразование типа указателя
Оператор const_cast
Иногда возникает необходимость снять константность с указателя или с ука-
зываемого значения. Применять такие преобразования стоит только в тех
редких случаях, когда это действительно необходимо, т. к. при этом защит-
ные возможности компилятора уменьшаются. Приведенные примеры демон-
стрируют только механизм отмены константности и на содержательность не
претендуют.
Пример 1.
Указатель является константой (листинг 6.11).
Листинг 6.11. Как снять константность с указателя
{
char c;
char* const pc=&c; //указатель является константой
//pc++; //ошибка: нельзя модифицировать константу
(const_cast<char*>(pc))++; //но если очень хочется…
(и только на время вычисления данного выражения)
}
Пример 2.
Указываемое значение является константой (листинг 6.12).
Указатели и массивы 193
Листинг 6.12. Как снять константность с указываемого значения
void f(char*); //функция принимает обычный указатель, но гарантированно
не модифицирует значение по адресу
int main()
{
char c = 'A';
const char* pc = &c; //посредством указателя pc значение
переменной c изменять нельзя
//*pc = 'B'; //ошибка: указываемое значение модифицировать нельзя
*(const_cast<char*>(pc)) = 'B'; //OK, хотя это злостное нарушение
введенных ограничений, и
грамотный программист
так поступать не должен
//f(pc); //ошибка: компилятор самостоятельно не может смягчить
ограничения и преобразовать const char* в char*
f(const_cast<char*>(pc)); //OK
}
Оператор reinterpret_cast
Компилятор не может вычислить выражение, если в нем используются опе-
ранды разных типов (см. разд. П1.10 — П1.12 приложения).
Поэтому:
􀂈 если компилятор считает приведение типа безопасным (например, int
в double), то осуществляет такие преобразования неявно (см. разд. 3.4.5):
int n = 33;
double d = n; //компилятор осуществляет неявное приведение типа
int в double
􀂈 если (хороший) компилятор подозревает о возможной потере точности
(double в int), то выдает предупреждение:
double d = 99.99;
int n = d; //компилятор выдает предупреждение и осуществляет
неявное приведение типа double в int
􀂈 если компилятор доверяет приведение типа программисту (double в int,
void* в T*), то позволяет использовать оператор static_cast для явного
приведения типа (см. разд. 3.4.5 и 6.1.5):
double d = 99.99;
int n = static_cast<int>(d); //компилятор осуществляет явное
194 Глава 6
приведение типа double в int. Предупреждений нет!
void* pv = &d;
double* pd = static_cast<double*>(pv);
􀂈 если компилятор считает преобразование потенциально опасным, то вы-
дает ошибку (при этом static_cast не поможет!).
В последнем случае с помощью оператора явного приведения типа reinterpret_
cast можно заставить компилятор преобразовать целое значение к типу
указателя (и наоборот) или указатель на объект одного типа к указателю на
объект другого типа. При этом следует учитывать, что объект, адресуемый
приведенным указателем, будет интерпретироваться в соответствии с пере-
определенным типом. Такие преобразования нужно применять с большой
осторожностью (и только если вы, с одной стороны — уверены, что такое
преобразование необходимо, а с другой стороны — четко представляете по-
следствия такого преобразования).
Пример 1.
В распоряжении программиста есть значение адреса, но для того чтобы можно
было по такому адресу обращаться, необходимо объявить указатель и при-
своить ему это значение:
//int* p = 0x10000000; //ошибка: нельзя преобразовать int в int*
int* p = reinterpret_cast< int*>(0x10000000); //OK
Пример 2.
С помощью указателей разного типа можно заставить компилятор интерпре-
тировать одну и ту же область памяти по-разному (листинг 6.13, рис. 6.5).
Листинг 6.13. Интерпретация одной и той же области памяти по-разному
посредством указателей разного типа
{
int n = 0x11223344; //целое можно интерпретировать как
совокупность четырех последовательно
расположенных в памяти байтов
char с = n; //в этом случае компилятор выдаст предупреждение
о возможной потере значения и осуществит неявное
преобразование int к типу char
(т. е. поместит в переменную c значение младшего
байта переменной n — см. разд. 3.4.5).
int* pn = &n; //посредством такого указателя можно работать
с совокупностью из четырех байтов (int) только
Указатели и массивы 195
как с единым целым. А для того, чтобы работать
с каждым байтом независимо, нужен указатель
типа char*
//char* pc = &n; //ошибка: компилятор считает такое преобразование
небезопасным
char* pc = reinterpret_cast<char*>(&n); //указатель pc содержит
тот же самый адрес, что и указатель pn, но
посредством указателя pc можно работать с каждым
байтом отдельно!
c = *pc; //c=0x44
//или
short s=*( reinterpret_cast<short*>(pn) ); //s=0x3344
pc++; //переместили указатель на следующий байт
c = *pc; //c=0x33
}
Рис. 6.5
ЗАМЕ ЧАНИЕ
Используя преобразования такого рода, следует четко представлять себе рас-
положение данных разных типов в памяти (количество занимаемых объектом
байтов, смысл и порядок их следования), иначе результаты могут не соответст-
вовать вашим ожиданиям.
196 Глава 6
Например:
double d=99.99; // 0x4058FF5C28F5C28F в 16-чном виде
int* pn = reinterpret_cast<int*> (&d); //компилятор будет
интерпретировать то, что лежит в памяти по адресу,
задаваемому pn, как int
int tmp = *pn; //если вы ожидаете в переменной tmp получить 99
(целую часть переменной d), то нужно почитать о
представлении данных в приложении П1.11).
tmp будет присвоено значение 0x28F5C28F=687194767(10)
6.2. Массивы
Массив — это сложный программный элемент (встроенное средство языка),
обладающий следующими специфическими особенностями:
􀂈 это совокупность упорядоченных (расположенных последовательно в па-
мяти) элементов данных;
􀂈 все элементы массива — одного и того же типа;
􀂈 все элементы массива занимают непрерывную линейную область памяти;
􀂈 каждый массив имеет имя. Имя массива — это база (адрес участка памяти,
начиная с которого хранятся элементы массива), относительно которой
можно обратиться к любому элементу массива;
ВА Ж Н О Е З А МЕ Ч А Н И Е
В языке C/C++ имя массива имеет смысл сложного указателя, тип которого за-
висит не только от типа элементов, но и от размерностей массива (см. разд. 6.3).
􀂈 все элементы массива пронумерованы, начиная с 0. Доступ к отдельному
элементу массива может осуществляться одинаково эффективно по имени
массива и порядковому номеру элемента:
• с помощью оператора индексирования [] (см. разд. 6.2.2);
• через указатель, посредством оператора разыменования * (см. разд. 6.3);
􀂈 можно задать одномерный, двухмерный, многомерный массив, указав
требуемое количество размерностей.
6.2.1. Объявление массива
Перед использованием массива программист должен описать его свойства
компилятору, т. е. использованию должно предшествовать объявление.
Указатели и массивы 197
Тремя обязательными составляющими при описании являются:
􀂈 имя массива;
􀂈 тип элементов;
􀂈 размерность массива.
Размерности задаются в индексных скобках [] в следующем порядке:
T a1[5]; //это одномерный массив с именем a1 из 5 элементов типа T
T a2[5][10]; //это двухмерный массив с именем a2, в котором 5 строк.
В каждой строке по 10 элементов типа T
T a3[5][10][20]; //это трехмерный массив с именем a3, в котором 5 слоев.
В каждом слое по 10 строк.
В каждой строке по 20 элементов типа T
//и т.д.
Как и для обычных переменных (см. разд. 3.5), объявление может быть со-
вмещено с определением, либо речь может идти об объявлении внешнего
(extern) массива. Отличия приведены в табл. 6.4.
ЗАМЕ ЧАНИЕ
Размерность массива может быть задана только константным выражением (т. е.
на момент компиляции компилятор должен знать, сколько выделить памяти!).
Таблица 6.4. Объявление и определение массива
Без ключевого слова extern С использованием ключевого слова
extern
Объявление совмещено с определени-
ем (т. е. компилятор должен выделить
память), поэтому от программиста тре-
буется предоставить компилятору ин-
формацию о том, сколько требуется
выделить памяти. Это программист
может сделать двумя способами: явно
указать все размерности или предоста-
вить компилятору вычислить (только!)
старшую размерность по списку ини-
циализаторов (см. разд. 6.2.3)
Это только объявление (описание
свойств) внешнего массива, определен-
ного в другом файле, поэтому такие
объявления рекомендуется помещать
в заголовочный файл. При объявлении
программист должен предоставить ком-
пилятору информацию о том, как вы-
числять адрес любого элемента.
А т. к. в вычислении адреса участвуют
все младшие размерности массива
(см. разд. 6.3), то программист обязан
при объявлении явно указать все млад-
шие размерности!
Такой массив может быть, исходя из
контекста объявления, глобальным, ло-
кальным, статическим или заключенным
в пространство имен
Такой массив может быть только гло-
бальными или заключенным в имено-
ванное пространство имен
198 Глава 6
Таблица 6.4 (окончание)
Без ключевого слова extern С использованием ключевого слова
extern
Примеры:
char cAr [10]; //компилятор должен
зарезервировать память под одно-
мерный массив из 10 элементов типа
char
int nAr [10][5]; //двухмерный мас-
сив из 10*5 элементов типа int
float fAr [2][10][5]; //трехмерный
массив из 2*10*5 элементов типа
float
Примеры:
extern int ar[10][5]; //такое объ-
явление информирует компилятор о
том, что на самом деле глобальный
массив из 10*5 элементов типа int
объявлен в каком-то другом модуле,
поэтому память под данный массив
уже отведена
или
extern int ar[][5]; //т. к. стар-
шая размерность не участвует в
вычислении адреса, то для внешнего
массива ее можно опустить
Пример задания размерности массива с помощью ключевого слова const
(только в C++):
const int N = 5;
char ar[N]; //OK
int N1=5;
//char ar[N1]; //ошибка: размерность должна быть задана константой
6.2.2. Обращение к элементу массива —
оператор []
Доступ к отдельным элементам массива может выполняться с помощью ин-
декса или нескольких индексов (если массив многомерный). Индексы — это
средство, которое позволяет компилятору, исходя из размерности массива,
вычислить адрес требуемого элемента (как это делает компилятор — см.
разд. 6.3). При этом для повышения эффективности вычисления адресов ин-
дексы нумеруются с 0, а не с 1. Поэтому корректный диапазон изменения ин-
декса — от 0 до числа, на 1 меньшего размерности массива.
ЗАМЕ ЧАНИЕ
Индекс может быть задан как числом, так и любым целым выражением.
Пример обращения к элементу одномерного массива приведен в листинге 6.14.
Указатели и массивы 199
Листинг 6.14. Обращение к элементу одномерного массива
{
char cAr[10]; //определение одномерного массива
char c = cAr[0]; //обращение к нулевому элементу массива
c=cAr[9]; //обращение к последнему элементу массива
int i, j, k;
//вычисление значений i, j, k
c=cAr[i]; //обращение к i-тому элементу массива
c=cAr[i+j+k]; //можно и так
//c=cAr[5.]; //ошибка: индекс должен быть целым
//Замечание. В языке С/С++ для повышения эффективности вычислений не
реализован автоматический контроль выхода значения индекса
за допустимые пределы, поэтому компилятор не выдаст ошибки
при следующих присваиваниях, а результат будет непредсказуем
c=cAr [10]; //обращение к несуществующему элементу массива,
будет чтение из памяти, занятой неизвестно чем
c=cAr [-1]; //аналогично
int n = <вычисление_n>; //переменная n в результате вычислений
может принять любое значение
cAr [n]='A'; //а в этом случае корректность операции зависит
от значения переменной n
}
Замечание о синтаксисе.
Если а — имя массива, b — имя целочисленной переменной, то все три ни-
жеприведенных выражения будут корректны и результат будет одинаковым:
􀂈 a[b];
􀂈 b[a];
􀂈 *(a + b).
При доступе к элементу многомерного массива должно быть указано столько
индексов, сколько размерностей у массива. При этом, например, для трех-
мерного массива в выражении ar[i][j][k] индексы указывают:
􀂈 i (старший индекс) — номер слоя (т. е. двухмерного массива);
􀂈 j — номер строки в i-том слое (т. е. одномерного массива);
􀂈 k — номер элемента в j-той строке.
Пример приведен в листинге 6.15.
200 Глава 6
Листинг 6.15. Обращение к элементу многомерного массива
int nAr[3][4]; //объявление двухмерного массива
int n=nAr[0][0]; //обращение к нулевому элементу массива.
При этом старший (левый) индекс является номером строки,
младший (правый) — номером элемента в строке
int n=nAr[2][3]; //обращение к последнему элементу массива
6.2.3. Инициализация массива
Инициализация массива может быть:
􀂈 неявной (выполняется автоматически компилятором);
􀂈 явной (выполняется программистом).
Неявная инициализация
По аналогии с переменными базового типа (см. разд. 3.9.2) все элементы
глобальных массивов, заключенных в пространства имен, а также и статиче-
ских инициализируются компилятором по умолчанию нулями, локальных
и динамических массивов — не инициализируются вовсе (листинг 6.16). При
этом программист должен указать все размерности массива, для того чтобы
компилятор знал, сколько зарезервировать памяти.
Листинг 6.16. Неявная инициализация массивов
int ar1[10][5]; //глобальный массив, проинициализирован компилятором
нулями
namespace {char ar1[10][5];} //массив в неименованном пространстве имен,
проинициализирован компилятором нулями
int main()
{
static char ar3[100]; //статический массив, проинициализирован
нулями
float ar4[3][4][5]; //локальный массив, не проинициализирован
//double ar5[]; //ошибка: программист не предоставил компилятору
информацию о том, сколько зарезервировать памяти
}
Явная инициализация
Только при определении программист может указать компилятору, какими
значениями инициализировать элементы массива, причем сделать это можно
несколькими способами.
Указатели и массивы 201
Рассмотрим первый способ.
Программист может явно указать все размерности массива. Таким образом
он предоставляет компилятору информацию о том, сколько зарезервировать
памяти.
Примеры инициализации одномерных массивов:
Пример 1.
int Ar1[3] = {1,2,3}; //для каждого элемента массива указан
инициализатор
Пример 2.
Инициализирующий список может содержать меньше начальных значений,
чем количество элементов в массиве, тогда остальные элементы инициализи-
руются нулем по правилам неполной инициализации массивов (независимо
от того, глобальный массив или локальный!):
char cAr [10] = {'A', 'B', 'C'}; //первые три элемента
инициализируются кодами символов 'A', 'B', 'C',
значения остальных семи элементов — нулями
char cAr1[10] = {"ABC"}; //можно использовать для инициализации
такого массива строковый литерал. В данном примере
результат будет таким же, как и в предыдущем,
т. к. первые четыре элемента массива будут
заполнены копиями значений строкового литерала,
включая завершающий 0, а остальные — по правилам
неполной инициализации компилятор проинициализирует
нулями
char cAr2[10] = "ABC"; //скобки в случае инициализации одномерного
массива строковым литералом можно опустить
//Но! если список инициализаторов содержит больше элементов, чем
размерность массива (значение в индексных скобках), выдается сообщение
компилятора:
char cAr2[3] = "ABC"; //ошибка: слишком много инициализаторов
(см. разд. 3.2.4)
Примеры инициализации многомерных массивов.
Пример 1.
При инициализации многомерных массивов инициализирующие значения
нужно указывать в том порядке, в котором компилятор выделяет память под
202 Глава 6
элементы массива (а выделяет он память линейно и непрерывно), поэтому
если указаны все инициализаторы, то можно написать:
int nAr [2][3]={ 1, 1, 1, //инициализаторы для нулевой строки
2, 2, 2 //инициализаторы для первой строки
};
Пример 2.
Можно с помощью фигурных скобок уточнить компилятору, для какой кон-
кретно строки программист указывает инициализаторы:
int nAr [3][2]={ {1, 1}, //инициализаторы для нулевой строки
{2, 2}, //для первой строки
{3, 3} //для второй строки
};
Пример 3.
Для многомерных массивов также справедливы правила неполной инициали-
зации (рис. 6.6):
int nAr [3][2]={ {1},
{2, 2},
};
Рис. 6.6
Пример 4.
Инициализация строковыми литералами:
char cStringAr [2][80]={ "Первая строка",
"Вторая строка"
}; //компилятор зарезервирует 2*80*sizeof(char)
байтов и скопирует в каждую строку массива
значения соответствующего строкового
литерала (оставшиеся в каждой строке байты
будут проинициализированы нулями)
Указатели и массивы 203
Рассмотрим второй способ.
Только при наличии списка инициализаторов при определении массива можно
опустить старшую размерность (или оставить ее открытой). При этом компи-
лятор по списку инициализаторов сам вычислит, сколько требуется выделить
памяти.
Пример 1.
Можно объявить одномерный массив без указания числа элементов массива,
а только со списком начальных значений:
char cAr []={'A', 'B', 'C'}; //в результате создается одномерный массив
из трех элементов и эти элементы получают
начальные значения из списка инициализации
Определите, сколько элементов в массиве, сколько зарезервировано бай-
тов и как проинициализированы элементы:
char cAr1[]="ABC";
Пример 2.
Многомерные массивы могут инициализироваться без указания одной самой
старшей (или самой левой) из размерностей массива (при этом компилятор
определяет опущенную старшую размерность, исходя из списка инициализации).
Определите, сколько строк в массиве, сколько зарезервировано байтов,
как проинициализированы элементы:
int nAr [][3] = {
{0, 1, 2},
{10, 11, 12},
{20, 30, 40}
};
Если в многомерном массиве необходимо проинициализировать не все элемен-
ты, а только несколько первых в каждой строке (слое), то в списке инициализации
можно использовать фигурные скобки, охватывающие значения инициализа-
торов для строки (слоя...). Все оставшиеся элементы будут проинициализиро-
ваны компилятором нулями по правилу неполной инициализации:
int nAr1[][3] ={ {0}, //0-ая строка
{10, 11}, //1-ая строка
{20, 21, 22} }; //2-ая строка
Специфика инициализации массивов:
􀂈 массив можно проинициализировать с помощью списка инициализации
только при определении. Любая попытка с помощью списка инициализа-
204 Глава 6
торов присвоить элементам уже существующего массива новые значения
вызовет сообщение компилятора об ошибке:
int ar[5];
//ar = {1,2,3}; //ошибка: список инициализаторов можно использовать
только при определении
􀂈 в некоторых реализациях при указании пустого списка инициализаторов
компилятор выдает ошибку, а в других — инициализирует значения всех
элементов нулями:
int ar[3] = {}; //зависит от реализации (например,
в Microsoft Visual Studio 2003 и более поздних
версиях все элементы будут обнулены)
􀂈 в списке инициализаторов могут быть использованы переменные:
int n1=1, n2 = 2;
int ar[4] = {7,n1,n2,8}; //элементы массива будут
проинициализированы значениями 7,1,2,8
􀂈 можно при объявлении сообщить компилятору, что все элементы массива
являются константами. При этом так же, как и в случае константных пе-
ременных базового типа, массив должен быть проинициализирован при
определении:
//const int ar[5]; //ошибка: требуется инициализация
//но!
extern const int ar[5]; //OK, т. к. это просто объявление
внешнего массива констант
//const int ar[5] = {1,2,3}; //в некоторых реализациях возможна
ошибка, т. к. инициализаторов меньше, чем требуется,
в других — компилятор проинициализирует оставшиеся
элементы нулями (например,
Microsoft Visual Studio 2003 и более поздние версии)
//однако!
const int ar[] = {1,2,3,4,5}; //корректно, т. к. компилятор
подсчитает количество элементов
по списку инициализаторов
Пример работы с одномерным массивом
В качестве примера работы с массивом рассмотрим сортировку выбором
(листинг 6.17). Алгоритм этой сортировки основан на поиске самого большо-
го (или самого маленького) из оставшихся не отсортированных элементов
массива и обмене значениями найденного и текущего элемента (рис. 6.7).
Указатели и массивы 205
Рис. 6.7
Листинг 6.17. Сортировка выбором по возрастанию значений
{
int ar[]={7,2,-5,6,0,3,2,5,3,-9,99,100};
int n = sizeof(ar)/sizeof(int); //количество элементов
for(int i=0; i<n-1; i++) //внешний цикл задает количество итераций
(n-1, так как последнее значение
автоматически окажется на своем месте)
{
int min = i; //здесь будет индекс элемента с минимальным
значением
for(int j=i+1; j<n; j++) //внутренний цикл: поиск
наименьшего из оставшихся неупорядоченных значений
{
if(ar[j]<ar[min]) min=j;
}
//Обмен местами значений текущего и минимального элементов
206 Глава 6
int tmp = ar[min];
ar[min] = ar[i];
ar[i] = tmp;
}
}
6.2.4. Массивы и оператор sizeof
Для одномерного массива с помощью оператора sizeof можно на этапе ком-
пиляции вычислить количество элементов:
char ar[] = "abc";
size_t n=sizeof(ar) / sizeof(char); //количество элементов массива
//или
n=sizeof ar / sizeof(ar[0]); //то же самое
Для двухмерного массива можно получить информации больше:
int ar[][3] = {1, 2, 3, 4, 5, 6, 7};
size_t n=sizeof(ar) / sizeof(int); //количество элементов массива
//или
n=sizeof(ar) / sizeof(ar[0][0]); //то же самое
n=sizeof(ar[0]) / sizeof(int); //число элементов в строке
n = sizeof(ar)/ sizeof(ar[0]); //число строк
//или
n = sizeof(ar)/ sizeof(int[3]); //число строк
Для трехмерного массива:
size_t n = sizeof(ar)/sizeof(int); //всего элементов
n = sizeof(ar)/ sizeof(ar[0][0]); //количество строк
n = sizeof(ar)/ sizeof(ar[0]); //количество слоев
n= sizeof(ar[0][0])/sizeof(int); //элементов в строке
Оператор sizeof применительно к массивам бывает полезен в следующих
случаях:
􀂈 если программист решает, что первоначально заданные размерности
массива его не устраивают. В таком случае, если он использует абсо-
лютные значения, скорее всего, ему придется еще во многих местах ис-
правлять текст своей программы. Пусть лучше за программиста текущие
размерности вычислит компилятор. А т. к. оператор sizeof — это меха-
низм этапа компиляции, а не выполнения, то эффективность программы
не ухудшается;
Указатели и массивы 207
􀂈 если программист при определении массива не указывает старшую раз-
мерность, а предлагает компилятору вычислить ее по списку инициализа-
торов (листинг 6.18):
Листинг 6.18. Использование оператора sizeof применительно к массивам
{
const int M=2;
double ar[][M] = { {1.1}, {2.2}, {3.3} };
double sum=0;
for(int i=0; i<sizeof(ar)/sizeof(double[M]); i++) //перебираем строки.
С помощью sizeof определяем количество строк
{
for(int j=0; j<sizeof(ar[0])/sizeof(double); j++) //перебираем
элементы в i-той строке
{sum+=ar[i][j];}
}
}
6.3. Связь массивов и указателей
Теперь рассмотрим связи между массивами и указателями более подробно.
Начинающим рекомендуется перед дальнейшим чтением еще раз просмот-
реть важное замечание в разд. 6.2. и замечание о синтаксисе в разд. 6.2.2.
6.3.1. Одномерные массивы
Имя одномерного массива компилятор интерпретирует так же, как интерпре-
тировал бы константный указатель (константный, потому что перенаправить
или модифицировать его нельзя) на нулевой элемент массива. А для про-
граммиста означает, что этими понятиями можно пользоваться одинаково.
Пусть дан одномерный массив:
int ar[5] = {1,2,3,4,5};
Элементы такого массива располагаются в памяти линейно и непрерывно
(рис. 6.8).
Исходя из интерпретации компилятором имени одномерного массива, можно
объявить эквивалентный указатель и направить его на начало массива:
int* p = ar; //неявное преобразование имени массива в указатель на
его нулевой элемент (int[]в int*)
208 Глава 6
Рис. 6.8
Это означает, что к i-тому элементу массива теперь можно обращаться как
посредством имени массива ar, так и посредством указателя p четырьмя при-
веденными способами:
􀂈 int tmp = ar[i];
􀂈 tmp = p[i];
//или согласно правилам арифметики указателей (см. разд. 6.1.4)
то же самое значение можно получить и так:
􀂈 tmp = *(p+i);
􀂈 tmp = *(ar+i);
Несмотря на то, что использование имени массива и эквивалентного указате-
ля выглядит одинаково, существенными отличиями являются:
􀂈 для переменной-указателя компилятор отводит память, а имя массива это
только эквивалент указателя. С этим именем компилятор просто ассоции-
рует адрес начала массива на этапе компиляции (никакой памяти для хра-
нения такого адреса не отводится);
􀂈 в большинстве случаев программист может синтаксически одинаково
использовать как имя массива, так и соответствующий ему указатель.
Исключением является попытка модификации:
p++; //OK, указатель перемещается на следующий элемент массива
//ar++; //ошибка: ar не является lvalue
Для вычисления адреса произвольного i-ого элемента одномерного массива
компилятору достаточно знать адрес начала массива (адрес нулевого элемен-
та) и размер элемента:
адрес_элемента_i = адрес_начала_массива + i* sizeof(тип элемента)
ВА Ж Н О!
Обратите внимание: размерность массива при вычислении адреса элемента
нигде не фигурирует!
Указатели и массивы 209
В качестве примера перепишем алгоритм сортировки выбором (см. разд. 6.2.3),
используя указатели вместо индексов (листинг 6.19).
Листинг 6.19. Сортировка массива методом выбора посредством
использования указателей
{
int ar[] = {4,1,-10, 55, 2,-5};
size_t n = sizeof(ar)/sizeof(ar[0]); //количество элементов
int* pCur = ar; //на нулевой элемент
for(int i=0; i<(n-1); i++) //внешний цикл задает количество
итераций
{
int* pMin = pCur;//в pMin будет адрес элемента с самым
маленьким из оставшихся значением.
На каждой итерации изначально
предполагаем, что самый маленький
элемент — текущий
int* pTmp = pCur + 1; //с помощью pTmp будем перебирать
оставшиеся до конца массива
элементы
for(int j=i+1; j<n; j++) //внутренний цикл — поиск самого
маленького из оставшихся
неупорядоченных значений
{
if(*pTmp < *pMin) pMin = pTmp; //если очередное
значение оказалось меньше,
перенаправляем на него pMin
pTmp++; //смещаем указатель на следующий элемент
}
//Меняем местами значения, на которые указывают pMin и pCur
int tmp = *pMin;
*pMin = *pCur;
*pCur = tmp;
//Подготавливаем pCur к следующей итерации внешнего цикла
pCur++;
}
}
210 Глава 6
6.3.2. Двухмерные массивы более подробно
Двухмерный массив — это способ организации данных как прямоугольной
таблицы, содержащей несколько строк одинаковой длины. Это означает, что
двухмерный массив можно представить (как и делает компилятор) как одно-
мерный, каждым элементом которого является строка (т. е. одномерный мас-
сив). А имя двухмерного массива компилятор интерпретирует как констант-
ный указатель на нулевую строку.
Пусть дан двухмерный массив:
const int N=2, M=3;
int ar[N][M] = { {1,2,3},{4,5,6}};
Тот факт, что массив двухмерный, означает:
􀂈 удобную для программиста интерпретацию данных (прямоугольная таб-
лица);
􀂈 правила вычисления компилятором адреса [i][j]-го элемента.
А на самом деле элементы такого массива располагаются в памяти линейно и
непрерывно (рис. 6.9).
Рис. 6.9
Для вычисления адреса произвольного [i][j]-го элемента двухмерного мас-
сива элементов типа T компилятору нужно знать адрес начала массива, коли-
чество элементов в строке и размер элемента:
адрес_элемента_i_j = адрес_начала_массива + i*M*sizeof(T) + j*sizeof(T)
Указатели и массивы 211
ОБР АТ ИТ Е В Н И МА Н И Е!
В вычислении адреса участвует только младшая размерность массива, а стар-
шая размерность нигде не фигурирует.
Исходя из интерпретации компилятором имени двухмерного массива, введем
эквивалентный указатель:
int (*p)[3] = ar; //скобки обязательны, иначе для компилятора
смысл объявления будет совершенно другим!
Подумайте, что означает такое объявление:
int *p[3];
Теперь к [i][j]-тому элементу массива можно обращаться, используя имя
массива ar или указатель p. При этом можно использовать любые комбина-
ции операторов [] и * (а низкоуровневый код, который сгенерирует компиля-
тор, будет во всех случаях одним и тем же):
int tmp = ar[i][j];
tmp = *(*(ar+i)+j);
tmp = *(ar[i]+j);
tmp = *(ar+i)[j];
//и то же самое посредством указателя:
tmp = p[i][j];
tmp = *(*(p+i)+j);
tmp = *(p[i]+j);
tmp = *(p+i)[j];
ЗАМЕ ЧАНИЕ
По правилам арифметики указателей при вычислении выражения p++; компи-
лятор переместит указатель на следующую строку массива! Тот же самый ад-
рес он вычислит в выражении (ar+1).
При работе со встроенными массивами программист, зная о том, как они
располагаются в памяти (линейно и непрерывно), может оптимизировать вы-
числения.
Пусть требуется подсчитать сумму элементов двухмерного массива (листинг 6.20).
Листинг 6.20. Вычисление суммы элементов двухмерного массива с помощью
вложенных циклов
{
int ar[N][M]; // N и M – константы
//формирование значений элементов массива
212 Глава 6
int sum=0;
for(int i=0; i<N; i++) //внешний цикл перебирает строки
{
for(int j=0; i<M; j++) //внутренний цикл перебирает
элементы в строке
{
sum+=ar[i][j]; //в этом месте компилятор по
приведенной выше формуле будет на каждой итерации
цикла вычислять адрес, используя операции умножения
и сложения (вычислений будет много!)
}
}
}
Имейте в виду, что время выполнения программы может существенно увели-
читься за счет того, что на каждой итерации цикла при вычислении адреса
[i][j]-го элемента компилятор использует достаточно много вычислений.
А если N и M будут достаточно большими?
На самом деле для решения задачи нужно просто последовательно перебрать
значения элементов. В таких местах программист, зная о том, что элементы
массива расположены в памяти последовательно, может оптимизировать вы-
полнение программы (листинг 6.21), введя вспомогательный указатель, по-
средством которого можно будет просто перемещаться от элемента к элемен-
ту, не думая о том, каким строкам они соответствуют (т. е. рассматривать
такой двухмерный массив как одномерный!). Объем вычислений резко со-
кратится.
Листинг 6.21. Оптимизация вычислений посредством использования указателя
{
int* p = &ar[0][0]; //вспомогательный указатель, который содержит
адрес начального элемента
//или эквивалентное выражение: int* p = ar[0];
for(int i=0; i<sizeof(ar)/sizeof(int); i++)
{
sum += *p; //добавляем к сумме значение по текущему адресу
p++; //перемещаем указатель на следующий элемент
}
}
Указатели и массивы 213
ЗАМЕ ЧАНИЕ
Многие современные оптимизирующие компиляторы (например, транслятор
C++ среды программирования Microsoft Visual Studio 2005) могут сами делать
оптимизации такого рода. При этом в DEBUG-версии программы механизм оп-
тимизации не включается, чтобы предоставить программисту возможность
трассировки, зато в RELEASE-версии компилятор умеет применять очень хит-
рые оптимизации (гораздо хитрее тех, которые мы реализовали вручную).
Для двухмерного массива выражения ar[0], ar[1] будут эквивалентны кон-
стантным указателям на соответствующие строки, т. е. следующие выраже-
ния будут тождественны:
􀂈 ar[0] == &ar[0][0]
􀂈 ar[1] == &ar[1][0]
Пример.
Пусть требуется сформировать двухмерный массив N*M, который будет со-
держать введенные пользователем строки (листинг 6.22). При этом предпола-
гается, что пользователь не введет строку длиннее, чем M символов (т. к. пре-
дусматривать защиту от переполнения строки мы еще не умеем).
Листинг 6.22. Пример работы с двухмерным массивом
#include <iostream>
int main()
{
const int N = 10, M = 10; //размерности массива
char ar[N][M]; //зарезервировали место в памяти для ввода строк
// подумайте, почему нельзя объявить массив для ввода таким
образом:
//char* ar[N];
//Вводим строки
for( int i=0; i<N; i++)
{
//Замечание. Потоки ввода/вывода умеют работать с указателями типа char*
(по указанному адресу вводится вся строка, напечатанная
пользователем, и формируется завершающий ноль)
std::cin>>ar[i]; //или std::cin>>&ar[i][0];
}
//Вывод сформированных строк
for(int k = 0; k<N; k++)
{std::cout<<ar[k]<< std::cout<<endl;}
}
214 Глава 6
6.3.3. Многомерные массивы
Расширим рассмотрение взаимосвязи массивов и указателей на случай мно-
гомерных массивов. При этом нам достаточно сделать еще один шаг — рас-
смотреть случай трехмерного массива, после чего читатель сможет самостоя-
тельно (по индукции) перейти к массивам произвольной размерности.
Трехмерный массив можно представить как одномерный, каждым элементом
которого является слой (т. е. двухмерный массив). Поэтому имя трехмерного
массива компилятор интерпретирует как константный указатель на нулевой
слой (нулевой двухмерный массив), равный начальному адресу области, за-
нимаемой в памяти трехмерным массивом.
Пусть дан трехмерный массив:
const int N=2, M=3, K=4;
int ar[N][M][K] = {
{ {1,2,3,4},{5,6,7,8},{9,10,11,12},
{ {-1,-2,-3,-4},{-5,-6,-7,-8},{-9,-10,-11,-12}
};
Элементы этого массива также располагаются в памяти линейно и непрерыв-
но (рис. 6.10).
Исходя из интерпретации компилятором имени трехмерного массива, введем
эквивалентный указатель (указатель на слой):
int (*p)[3][4] = ar;
Теперь к [i][j][k]-му элементу массива будем одинаковым способом обра-
щаться, используя имя массива ar или указатель p. При этом можно исполь-
зовать любые комбинации операторов [] и * (главное, чтобы суммарно их
было три):
int tmp = ar[i][j][k];
tmp = *(*(*(ar+i)+j)+k);
…
tmp = p[i][j][k];
…
ЗАМЕ ЧАНИЕ
По правилам арифметики указателей при вычислении выражения p++; компи-
лятор переместит указатель на следующий слой массива! Тот же самый адрес
он вычислит в выражении: ar+1 (см. рис. 6.10).
Указатели и массивы 215
Рис. 6.10
Для вычисления адреса произвольного [i][j][k]-ого элемента трехмерного
массива элементов типа T компилятору нужно знать адрес начала массива,
количество элементов в строке, количество строк в слое и размер элемента:
адрес_элемента_i_j_k = адрес_начала_массива + i ∗ M ∗ K ∗ sizeof(T) +
j ∗ K ∗ sizeof(T) + k ∗ sizeof(T)
216 Глава 6
ОБР АТ ИТ Е В Н И МА Н И Е!
В вычислении адреса участвуют только младшие размерности массива,
а старшая размерность (количество слоев) нигде не фигурирует!
Попробуйте самостоятельно оптимизировать задачу о суммировании эле-
ментов для трехмерного массива.
6.3.4. Массивы указателей
Элементы массива могут иметь любой тип (в т. ч. они могут быть указателями).
Наиболее часто массивы указателей используются для хранения адресов строк
текста, динамически создаваемых объектов и т. п. (см. разд. 6.4.4 и 9.10).
Массив указателей, как и любой другой массив, должен быть объявлен и мо-
жет быть проинициализирован при определении.
Пример 1.
extern int* arn[][20]; //объявление внешнего двухмерного массива
указателей int*
Пример 2.
char* arс[5]; //определение одномерного массива из 5 указателей
(компилятор резервирует место 5*sizeof(char*)
байтов и, если массив глобальный, неявно
инициализирует все элементы нулем)
Если массив локальный, то гораздо безопаснее (см. разд. 6.1.6) явно проини-
циализировать его элементы нулевым значением, поскольку нет ничего хуже,
чем пользоваться указателем со случайным значением:
{
char* arс[20]={0};
}
Сравним два внешне похожих выражения (рис. 6.11):
􀂈 инициализация встроенного двухмерного массива строковыми литера-
лами:
char ar1[][6]={ "One", "Two", "Three"};
Компилятор производит следующие действия:
• отводит в статической области памяти место для хранения строк;
• выделяет память 3*6*sizeof(char) для двухмерного массива ar;
Указатели и массивы 217
• копирует содержимое строковых литералов в соответствующие строки
массива;
􀂈 инициализация массива указателей строковыми литералами:
char* ar[]={"One", "Two", "Three"};
Компилятор производит следующие действия:
• отводит в статической области памяти место для хранения строк;
• выделяет память под три указателя для одномерного массива ar;
• присваивает каждому элементу массива значение, равное адресу начала
соответствующего строкового литерала (направляет каждый элемент
массива на соответствующий строковый литерал).
Рис. 6.11
218 Глава 6
ВА Ж Н О!
Поскольку строковые литералы компилятор располагает в области памяти
(нередко защищенной от записи (см. разд. 3.2.4)), то попытка изменить их вы-
зовет ошибку времени выполнения.
Например:
ar1[1][1] = 'D'; //OK, заменили 'w' на 'D'
ar[1][1] = 'D'; //компилятор ошибок не выдаст, т. к. синтаксически
выражение корректно, но зато произойдет ошибка
во время выполнения (что гораздо хуже!)
РЕ К О МЕ Н Д А Ц И Я ( Б. СТ Р АУСТ Р УП)
Предпочитайте ошибки компилятора ошибкам времени выполнения. Поэтому
массив указателей на строковые литералы следует определять таким образом,
чтобы компилятор не позволял модифицировать значения посредством указа-
телей, хранящихся в массиве.
Например:
const char* ar[]={"One", "Two", "Three"};
//тогда компилятор не позволит модифицировать значение по адресу
//ar[1][1] = 'D'; //ошибка: нельзя модифицировать константную
переменную
Приведенные примеры демонстрируют принципиальные различия:
􀂈 в расположении в памяти массива указателей и (на первый взгляд) подоб-
ного ему двухмерного массива;
􀂈 в использовании массивов (хотя синтаксически обращение к элементам
обоих массивов выглядит одинаково!).
6.4. Динамические массивы
Нередко программист на этапе написания программы не может точно ска-
зать, каков размер требуемых массивов — размер вычисляется в процессе
выполнения программы. В таком случае возможны два варианта действий:
􀂈 зарезервировать память с запасом на этапе компиляции (при этом всегда
существует вероятность того, что запаса может не хватить, или наоборот —
неиспользуемый резерв окажется достаточно большим);
􀂈 применить механизм, позволяющий выделить память под массив уже во
время выполнения программы в необходимом объеме. Этот механизм но-
сит название — динамическое управление памятью.
Указатели и массивы 219
Напомним, что существуют три вида и, соответственно, три способа исполь-
зования памяти:
􀂈 статическая память, куда компилятор помещает на все время выполнения
программы глобальные данные, заключенные программистом в простран-
ства имен и объявленные с ключевым словом static;
􀂈 автоматическая память (в стеке), которую компилятор распределяет под
локальные данные и автоматически освобождает ее при завершении
функции (см. разд. 8.4);
􀂈 динамическая память (в куче), в которой требуемый блок захватывается
только по явному запросу программиста (при вызове функции стандарт-
ной библиотеки типа malloc() или оператора языка С++ new) и освобожда-
ется программистом тоже явно (вызовом функции стандартной библиоте-
ки free() или оператора delete).
ЗАМЕ ЧАНИЕ
Использование динамической памяти требует от программиста понимания это-
го механизма, целесообразного его использования и аккуратности. При некор-
ректном манипулировании динамической памятью такая возможность оборачи-
вается существенными неприятностями — ошибками времени выполнения
и утечками памяти.
6.4.1. Управление памятью. Низкоуровневые
функции языка Си
Понятия, связанные с функциями, подробно рассматриваются в гл. 8,
а в данном разделе просто перечислены основные функции стандартной биб-
лиотеки, связанные с динамическим выделением памяти, и показан механизм
выделения, использования и освобождения такой памяти.
Основные функции стандартной библиотеки для работы с динамической па-
мятью объявлены в заголовочном файле <cstdlib>:
􀂈 функция malloc() (или ее аналог calloc(), который не только выделяет
память, но и обнуляет содержимое) выделяет указанное в качестве пара-
метра количество байтов в динамической памяти (или куче — heap). Если
память выделить удалось, функция возвращает ненулевой указатель (ад-
рес начала выделенного блока), в случае же неудачи возвращает нулевое
значение. Тип возвращаемого указателя — void*. Пусть требуется выде-
лить память под переменную BIG элементов типа int (листинг 6.23). Зна-
чение BIG формируется в процессе выполнения программы, поэтому
встроенный массив с переменной размерностью компилятор создать не
позволит:
220 Глава 6
Листинг 6.23. Захват динамической памяти низкоуровневыми средствами Си
{
unsigned int BIG; //здесь будет количество элементов
//вычисление значения BIG (может быть очень большим!)
//int ar[BIG]; //ошибка: размерность должна быть известна на этапе
компиляции
size_t n = BIG * sizeof(int); //число байтов, которые
требуется выделить динамически
int* p = static_cast<int*>(malloc(n)); //возвращаемый функцией
void*-указатель приводим к требуемому типу
//если память выделить не удалось, возвращается нулевое значение
if(p)
{//память выделить удалось, можно пользоваться указателем,
например:
for(int i=0; i< BIG; i++)
{
p[i] = 1;
}
}else
{
//возможно, предпринимаем другие действия
}
}
СУЩЕ СТ ВЕ ННО!
На самом деле выделяется не столько байтов, сколько запросил программист,
а больше, т. к. для каждого запрошенного программой блока памяти формиру-
ется дополнительная служебная информация (рис. 6.12). Размер и формат
служебного блока могут зависеть от конкретного компилятора, поэтому напря-
мую этой информацией программист пользоваться не может. Такую информа-
цию компилятор формирует при динамическом выделении памяти и использует
в первую очередь при освобождении захваченного блока;
􀂈 в некоторых реализациях можно получить размер динамически выделен-
ного блока памяти с помощью функции _msize():
size_t num = _msize(p);
􀂈 если объем блока нужно изменить (обычно увеличить), можно использовать
функцию realloc() (листинг 6.24). При необходимости функция выде-
ляет новый блок памяти, содержимое старого блока переписывает в новый,
а старый освобождает. В случае успеха возвращает ненулевой указатель;
Указатели и массивы 221
Рис. 6.12
Листинг 6.24. Перераспределение динамического блока памяти
{
int* p = static_cast<int*>(malloc(1000));
if(p)
{
//использование p
//потребовалось большее количество памяти
p = static_cast<int*>(realloc(p,2000));
if(p){если удалось захватить новый блок памяти}
}
}
􀂈 функция free() освобождает память. При этом блок, на который указыва-
ет p, исключается из списка занятых и подключается к списку свободных
блоков:
free(p);
222 Глава 6
ЗАМЕ ЧАНИЕ
Если программист не аккуратен и забывает освобождать захваченную память,
он порождает утечки памяти. Это означает, что при выполнении программы об-
разуются области памяти, которые не используются, но будут считаться заня-
тыми вплоть до завершения программы.
6.4.2. Управление памятью.
Операторы С++ new и delete
Операторы new и delete являются надстройкой языка С++ над низкоуровне-
выми функциями malloc() и free(). Эти операторы являются встроенными
средствами языка С++, поэтому никаких заголовочных файлов подключать
не нужно!
Если вы программируете на С++, то предпочтительнее использовать опера-
торы new и delete вместо функций malloc() и free(), потому что:
􀂈 не обязательно явно указывать количество требуемых байтов (компилятор
может подсчитать сам по контексту вызова оператора new);
􀂈 не нужно явно приводить тип возвращаемого значения (void*) к требуе-
мому типу (компилятор неявно делает это сам);
􀂈 основное преимущество использования оператора new проявляется для
объектов пользовательского типа (классов С++), т. к. оператор совмещает
выделение памяти с вызовом специальной инициализирующей функции
(автоматически вызывает для таких объектов конструктор). Соответствен-
но основным преимуществом использования оператора delete является
автоматический вызов специальной функции деинициализации — дест-
руктора для объектов классов.
Существуют несколько форм операторов new и delete. Обычная (самая рас-
пространенная) форма использования на самом деле означает вызов функций
стандартной библиотеки:
void* operator new(size_t); //эта функция, в свою очередь, вызывает
низкоуровневую функцию malloc(), которая
и резервирует память. Согласно стандарту C++ эта
форма оператора new предназначена для выделения
памяти под одиночный объект
void operator delete(void *); //а внутри этой функции вызывается
низкоуровневая функция free().Согласно стандарту C++
эта форма оператора delete предназначена для
освобождения памяти, занятой одиночным объектом
Указатели и массивы 223
В стандартизованном С++ появились еще несколько форм операторов new
и delete. В частности — в силу специфики использования классов, разработ-
чики ввели специальные версии new и delete для массивов:
void* operator new[](size_t); //выделение памяти для массива
void operator delete[](void *); //освобождение памяти, занятой массивом
ЗАМЕ ЧАНИЕ
Пока программист не пользуется классами, принципиальной разницы в исполь-
зовании этих двух вариантов new/delete нет. Несмотря на это, стоит вырабо-
тать полезную привычку использовать new/delete для одиночных динамиче-
ских объектов и new[]/delete[] для массивов объектов.
Использование оператора new для выделения памяти
Динамически можно выделить память для любого объекта или массива объ-
ектов. Например, для того, чтобы зарезервировать память в куче для одиноч-
ного значения типа int:
int* p = new int; //размер выделяемого блока задается неявно.
Оператор new, исходя из указанного типа, выделяет
sizeof(int) байтов в отличие от malloc(4),
где количество байтов нужно указывать явно
int* p = operator new(sizeof(int)); //размер задается явно
ЗАМЕ ЧАНИЕ
В результате успешного выделения памяти возвращается ненулевой указа-
тель, содержащий адрес выделенного блока памяти, а в случае нехватки памя-
ти (согласно стандарту С++) нулевое значение (как в случае с функцией
malloc()) не формируется, а генерируется исключение, поэтому проверять
возвращаемое значение на ноль смысла не имеет. Механизм исключений
в рамках данной книги не обсуждается, а вам пока просто не следует задумы-
ваться над специальной программной защитой в случае нехватки памяти — она
предусмотрена в реализации оператора new.
Программисту следует отдавать себе отчет в том, что использование динами-
ческой памяти — средство достаточно дорогое, поэтому прибегать к нему
следует лишь тогда, когда оно действительно необходимо. Очевидно, что
накладные расходы при динамическом выделении памяти достаточно боль-
шие, поскольку:
􀂈 для небольших объектов дополнительная служебная информация может бо-
лее чем вдвое увеличить количество памяти для каждого выделяемого блока;
􀂈 в процессе выполнения программы на динамическое выделение памяти
тратится дополнительное время (на формирование служебных структур
данных);
224 Глава 6
􀂈 неочевидным следствием использования динамического выделения памя-
ти является фрагментация кучи. То есть при выполнении программы мо-
жет возникнуть такая ситуация, когда суммарно запрашиваемый объем
памяти имеется, но эта свободная память разрезана на кусочки, которые
компилятор склеивать не умеет!
Использование оператора delete для освобождения памяти
Выделив динамически память, программист несет ответственность за ее ос-
вобождение, поэтому, попользовавшись, не забудьте освободить ее (память)
посредством оператора delete:
delete p; //для освобождения блока памяти, адрес которого содержится
в указателе p, компилятор использует информацию,
сформированную в служебном блоке
p=0; //после освобождения памяти в переменной p еще сохраняется
значение адреса уже недействительного блока, поэтому
безопаснее такой указатель обнулить!
ЗАМЕ ЧАНИЕ
Попытка выделить 0 байтов выполняется корректно (в большинстве реализа-
ций резервируется один байт).
ПР Е ДО СТ Е Р Е Ж Е НИ Е
Будьте бдительны при использовании указателя на динамически захваченный
блок памяти! Пример трудно выявляемого дефекта программы приведен в лис-
тинге 6.25.
Листинг 6.25. Пример небрежного использования программистом указателя
на динамически выделенный блок памяти
{
char* p=new char; //динамически выделили один байт
*p='A'; //занесли по этому адресу значение
p="QWERTY"; //перенаправили указатель на строковый литерал,
т. е. занесли в переменную p адрес совершенно другой
области памяти. При этом предыдущее значение адреса
затерли — теперь до завершения программы этот блок
никто не освободит (память потекла)!
delete p; //а потом вспомнили, что когда-то вызывали оператор new
и неплохо бы вызвать соответствующий delete, но при
Указатели и массивы 225
выполнении этой строки скорее всего получили ошибку
времени выполнения.
}
Попробуйте догадаться, почему во время выполнения возникает ошибка и
как следует переписать этот листинг?
6.4.3. Сборщик мусора (garbage collector)
Если неаккуратный программист выделил динамически блок памяти, но за-
был его освободить, то эта память будет освобождена операционной систе-
мой только после завершения приложения. Но если такой программист вы-
деляет память интенсивно и достаточно большими блоками, то даже
виртуальная память может закончиться…
В ряде систем существует механизм автоматического освобождения памяти
(сборщик мусора). В таких случаях система самостоятельно определяет, ка-
кая область памяти больше не используется программой, и освобождает ее.
Такой подход удобен для забывчивых программистов, но имеет свои недос-
татки. Например, он совершенно не годится для создания критичных ко вре-
мени программ (деятельность сборщика мусора может требовать немало
времени и не синхронизирована с выполнением пользовательской програм-
мы). Поэтому в C/С++ сборка мусора не реализована (создатели языка в пер-
вую очередь преследовали цель эффективности). А это означает, что за про-
граммиста его обязанности по освобождению неиспользуемой динамической
памяти никто выполнять не будет!
6.4.4. Операторы new[] и delete[] и массивы
Создавать массивы динамически стоит в тех ситуациях, когда:
􀂈 все или некоторые размерности массива вычисляются только во время
выполнения программы;
􀂈 размерности массива могут изменяться в процессе выполнения программы.
ЗАМЕ ЧАНИЕ
Если вы на каком-либо этапе знаете размеры массива и можете сообщить их
компилятору, не стоит динамически выделять память. Пользуйтесь встроенны-
ми массивами — это сэкономит время и память!
Рассмотрим примеры создания динамических массивов.
226 Глава 6
Пример 1.
Одномерные динамические массивы (с точностью до того, в какой области
выделяется память) очень похожи на встроенные (память выделяется моно-
литно), но в этом случае программист сам должен заботиться об освобожде-
нии памяти (листинг 6.26).
Листинг 6.26. Создание одномерного динамического массива
{
unsigned int n; //здесь будет количество элементов
//вычислили n
//int ar[n]; //ошибка: размерность массива должна быть константой
int* pn=new int[n]; //динамически выделяем требуемый блок памяти
(по контексту вызова оператора new компилятор догадается,
что требуется выделить n*sizeof(int) байтов)
//Использование динамического массива:
pn[i]=…;
//Пусть в процессе выполнения программы оказалось, что требуется
увеличить размерность массива вдвое:
int* tmp = new int[n*2]; //выделили новую память
//переписали старое содержимое в новую область:
//а)
for(int i = 0; i<n; i++){ tmp[i] = pn[i];}
//б) или более эффективный вариант копирования блока байтов из одной
области памяти в другую посредством функции стандартной
библиотеки memcpy():
memcpy(tmp,pn,n*sizeof(int));
delete[] pn; //старую область памяти освободили
pn = tmp; // перенаправили указатель pn на новую область памяти
//Продолжаем пользоваться динамическим массивом посредством
указателя pn:
pn[i]=…;
//Когда массив больше не нужен, память следует освободить
delete[] pn; //освобождение динамической памяти. После
Указатели и массивы 227
освобождения памяти этим адресом пользоваться
нельзя!
pn=0; //безопаснее обнулить указатель, чем оставить в нем значение
недействительного адреса
}
Пример 2.
Многомерные динамические массивы.
В зависимости от того, как задаются размерности, с помощью оператора new
можно создавать массивы по-разному. При этом существенно различаются
способы задания и размещение массивов в памяти!
Способ первый.
Все младшие размерности известны на этапе компиляции (константы) (лис-
тинг 6.27). Как и в случае одномерного массива, такой динамический массив
очень похож на встроенный (отличия: место расположения heap, необходи-
мость явного освобождения памяти).
ЗАМЕ ЧАНИЕ
Обратите внимание на объявление указателя — при любом другом объявлении
указателя компилятор выдаст ошибку.
Листинг 6.27. Создание трехмерного динамического массива с известными
на этапе компиляции младшими размерностями
{
float (*pf)[25][10]; //определение указателя на двухмерный
массив 25*10. Это эквивалент имени
трехмерного массива.
unsigned int n = выражение; //вычислили старшую размерность
pf = new float[n][25][10]; //динамически выделили блок памяти.
Указателем pf можно пользоваться так же, как и
именем трехмерного массива
//Использование:
pf[i][j][k] = …;
delete[] pf; //не забыли освободить память
}
228 Глава 6
ЗАМЕ ЧАНИЕ 1
При определении указателя pf компилятор выделяет память только под пере-
менную для хранения адреса. Посредством указания младших размерностей
мы даем указание компилятору, каким образом интерпретировать этот адрес.
Несмотря на то, что память для самого массива отводится динамически, сам
указатель (в зависимости от контекста определения) может быть локальным,
глобальным, динамическим.
ЗАМЕ ЧАНИЕ 2
При динамическом выделении памяти все размерности массива, кроме самой
левой, должны быть константными выражениями, которые при вычислении да-
ют положительное целое.
Например:
int n, m, k;
//вычисляются значения n, m, k
float (*pf)[25][10];
pf = new float[n+m+k][25][10];
Способ второй.
Часто возникает потребность работать с многомерными массивами, все раз-
мерности которых априори неизвестны. Пусть требуется работать с двухмер-
ным массивом, размерности которого N и M вычисляются в процессе выпол-
нения программы. В этом случае у программиста есть две возможности.
Возможность первая — создать одномерный динамический массив элемен-
тов требуемого типа Т с размерностью (N*M).
int N, M;
//вычисление значений N и M
int* p = new int[N*M]; //выделение памяти для одномерного массива
В результате программист получает в свое распоряжение указатель, который
эквивалентен имени одномерного массива. А ему (программисту) хочется
интерпретировать массив как двухмерный, но тогда он должен сам каждый
раз формировать адрес [i][j]-го элемента таким же образом, как это сделал
бы компилятор для встроенного двухмерного массива:
p[i * M + j]
Программист может облегчить себе обращение к [i][j]-му элементу, создав
вспомогательный массив указателей на строки (рис. 6.13):
int** pp = new int*[N]; //вспомогательный указатель, посредством
которого можно будет обращаться к элементу привычным
Указатели и массивы 229
для двухмерного массива способом (посредством двух
индексов)
for(int i=0; i<N; i++)
{
pp[i] = p + i*M; //направляем каждый i-й указатель на
начало соответствующей i-й строки
}
Рис. 6.13
230 Глава 6
Теперь вспомогательным указателем pp можно пользоваться (синтаксически)
точно так же, как именем двухмерного массива (хотя компилятор будет вы-
числять адрес по-другому, исходя из типа указателя pp):
pp[i][j]
Этот способ хорош в том случае, когда размерности массива в процессе вы-
полнения программы не изменяются. Очевидным плюсом такого подхода
является минимизация накладных расходов при динамическом выделении
памяти — два блока служебной информации (для собственно массива значе-
ний и для вспомогательного массива указателей).
Но! Подумайте, что придется сделать в том случае, когда количество строк
в таком массиве будет уменьшаться или увеличиваться во время выполнения
программы. Например, требуется добавить в массив еще одну строку (лис-
тинг 6.28).
Листинг 6.28. Действия программиста при увеличении количества строк
в динамическом двухмерном массиве
{
N+=1; //увеличили количество строк на 1
int* tmp = new int[N*M]; //выделили новый блок памяти
for(int i=0; i< (N-1)*M; i++)
{tmp[i] = p[i];} //переписали в новый блок старое содержимое
//Теперь старый массив нам не нужен
delete[] p; //освободили старый массив
p = tmp; //перенаправили указатель на новый массив
delete[] pp; //освободили память, занятую вспомогательным массивом
указателей
pp = new int*[N]; //выделить для вспомогательного массива новый
блок (он больше, чем предыдущий)
for(int i=0; i<N; i++) //сформировать во вспомогательном массиве
новые адреса
{
pp[i] = p + i*M;
}
//Продолжаем пользоваться указателем pp
…
//Массив больше не нужен. Память нужно освободить
delete[] p;
delete[] pp;
}
Указатели и массивы 231
Возможность вторую можно использовать в таких задачах, где размерности
массива могут изменяться во время выполнения. При таком подходе в памяти
создается довольно сложная структура (рис. 6.14) со всеми, присущими ди-
намическому выделению памяти накладными расходами, зато минимизиру-
ются действия при изменении размерностей массива во время выполнения.
Рис. 6.14
Последовательность действий при создании такой сложной структуры дан-
ных в памяти представлена в листинге 6.29.
Листинг 6.29. Создание динамического двухмерного массива
{
int N, M;
//вычисляются значения N и M
int** p = new int*[N]; //сразу выделяется память под массив
указателей на строки
for(int i = 0; i<N; i++)
{
p[i] = new int[M]; //динамически выделяется память под
очередную строку, а возвращаемый
232 Глава 6
указатель запоминается в
соответствующем элементе
массива указателей
}
//Для доступа к элементу пользуемся указателем p и двумя индексами
for(int i = 0; i<N; i++)
for(int j = 0; i<M; j++)
{
p[i][j] = i+j; //например, сформируем значения
элементов
}
}
Обращение к элементу такого массива на уровне языка С/С++ синтаксически
выглядит так же, как и в случае обычного встроенного массива, но следует
иметь в виду, что на низком уровне компилятор (исходя из типа указателя)
вычисляет адрес принципиально по-другому.
int x = p[i][j]; //компилятор сначала извлекает адрес i-той строки из
массива указателей, а потом к этой базе добавляет
смещение j-ого элемента относительно
начала i-той строки
Накладных расходов при этом подходе очень много (служебный блок ин-
формации на каждый выделенный блок памяти), зато для такого массива лег-
ко увеличивать или уменьшать количество строк. Рассмотрим, как при такой
организации массива можно добавить одну строку (листинг 6.30).
Листинг 6.30. Действия программиста при увеличении количества строк в
динамическом двухмерном массиве
{
N+=1;
int** tmp = new int*[N]; //выделили новый блок памяти только под
массив указателей на строки (сами
строки трогать не будем!)
for(int i=0; i<(N-1); i++)
{
tmp[i] = p[i]; //просто переписали в новый массив адреса строк
}
delete[] p; //теперь старый массив указателей нам не нужен
– освобождаем память
Указатели и массивы 233
p=tmp; //перенаправили наш указатель p на новый массив
p[N-1] = new int [M]; //динамически выделили память для новой
добавляемой строки
//продолжаем пользоваться указателем p
…
//Поработав с динамическим массивом, аккуратный программист
должен корректно освободить всю захваченную память
for(i=0; i<N; i++)
{
delete[] p[i]; //освобождаем память, занятую i-той строкой
}
delete[] p; //освобождаем память, занятую массивом указателей
на строки
p = 0; //теперь этим адресом пользоваться нельзя, поэтому для
безопасности обнуляем
}
ЗАМЕ ЧАНИЕ
При таком создании динамического массива программист должен понимать,
что строки массива расположены в разных участках heap, а не занимают не-
прерывную, линейную область памяти! Поэтому оптимизации, применимые к
встроенным массивам (листинг 6.21), невозможны.
Различие операторов delete и delete[]
Различие в использовании дух форм delete и delete[] проявляется только
тогда, когда речь идет о динамическом создании объектов пользовательского
типа (классов). Проблема состоит в том, что для таких объектов перед осво-
бождением памяти компилятор должен автоматически вызвать специальную
функцию (деструктор). А т. к. оператор delete получает в качестве параметра
только указатель, то необходимо предоставить ему возможность различать —
является ли данный указатель указателем на одиночный объект (компилятор
должен вызвать деструктор для одного объекта) или на массив объектов (де-
структор должен быть вызван для каждого элемента массива).
Для этих целей в стандартизованном С++ существуют две формы оператора
delete, которые не рекомендуется смешивать:
􀂈 delete — для одиночного объекта;
􀂈 delete[] — для массива.
//Пусть под "T" имеется в виду любой тип
T* p = new T; //выделена память под одиночный объект типа Т
234 Глава 6
T* pAr = new T[100]; //выделена память под массив из 100 элементов
типа Т
//работаем с обоими указателями
delete p; //корректно
p=0; //рекомендуется
//delete[] p; //результат не определен!
delete[] pAr; //корректно
pAr = 0; //рекомендуется
//delete pAr; //память будет гарантированно освобождена, но
если под T имеется в виду пользовательский
тип (class), то деструктор будет вызван
только для нулевого элемента массива
ПР А В И Л О
Если вы применяете new[], то должны использовать delete[] и наоборот!
6.4.5. Инициализация динамических массивов
Оператор new не позволяет инициализировать динамически выделенные мас-
сивы, поэтому программист должен позаботиться о том, чтобы элементы
массива не имели случайных значений. Некоторые компиляторы в DEBUG-
версии программы заполняют свободные и недействительные (освобожден-
ные) области кучи специальными значениями, которые позволяют в DEBUG-
версии отследить ошибки обращения к таким областям памяти.
Глава 7
Ссылки
7.1. Понятие ссылки
Ссылки появились в языке С++ (в языке Си такого понятия не было).
Ссылки — это еще одно средство, помимо указателей, позволяющее про-
граммисту манипулировать адресами программных объектов. Зачем понадо-
билась новая языковая конструкция, указывающая компилятору, что пере-
менная содержит адрес объекта?
Рискну сделать два предположения:
􀂈 если при процедурном подходе без ссылок можно прекрасно обойтись,
пользуясь родным для языка Си указателем, то при объектно-ориенти-
рованном подходе (при программировании в классах) некоторые выраже-
ния при использовании ссылок выглядят привычнее (тема объектно-
ориентированного программирования выходит за рамки данной книги);
􀂈 с целью облегчения адаптации к языку С++ программистов, привыкших
к другим высокоуровневым языкам программирования, в которых такого
понятия, как указатель, не существует. Несмотря на то, что переменная-
ссылка содержит адрес объекта, программист пользуется ссылкой синтак-
сически так же, как если бы он пользовался самим объектом, а компиля-
тор (зная о том, что в переменной содержится адрес требуемого значения)
неявно обращается к содержимому по этому адресу. Таким образом, мож-
но сказать, что программисту посредством ссылки предоставляется псев-
доним объекта.
Разницу в реализации указателей и ссылок иллюстрирует рис. 7.1.
Как бы там ни было (ссылки могут нравиться программисту, или он постара-
ется обойтись без них), но ссылки можно воспринимать как удобную альтер-
нативу указателям. Программисту они могут казаться чуждыми языку Си
236 Глава 7
и искусственными, но, тем не менее, при программировании на С++ пользо-
ваться ими он должен уметь. Более того, в объектно-ориентированной части
стандартной библиотеки для различных целей сплошь и рядом используются
именно ссылки.
Рис. 7.1
ВА Ж Н О Е З А МЕ Ч А Н И Е
Несмотря на то, что и переменная-указатель, и переменная-ссылка содержат
адрес объекта, указатели и ссылки подчиняются разным синтаксическим пра-
вилам, поэтому эти две конструкции программист использует по-разному!
7.2. Сравнение ссылок и указателей
Специфические особенности синтаксиса и использования ссылок (по сравне-
нию с указателями) представлены в табл. 7.1.
Таблица 7.1. Сравнительная характеристика указателя и ссылки
В чем проявляется
отличие
Указатель Ссылка
Тип переменной T* T&
Объявление и опре- int x=1;
деление
int* p = &x; int& r = x;
с этого момента ссылка r ста-
новится псевдонимом x
Ссылки 237
Таблица 7.1 (продолжение)
В чем проявляется
отличие
Указатель Ссылка
Инициализация Инициализация рекомен-
дуется, но не обязательна:
int* p; //OK
Инициализация обязательна!
int& r;
ошибка: нет инициализатора
extern int& r1; //OK
внешняя ссылка, должна быть
проинициализирована в дру-
гом файле при определении
Получение значения.
Ссылка (как и указа-
тель) содержит ад-
рес объекта, но син-
таксически именем
ссылки можно (и
нужно) пользоваться
так же, как именем
самого объекта. При
этом говорят, что
переменная-ссылка
предоставляет аль-
тернативное имя
для объекта
int tmp = *p;
получили значение пере-
менной x
(*p)++;
значение переменной x
изменилось на 1
p++;
значение адреса измени-
лось на sizeof(int)
int tmp = r;
получили значение перемен-
ной x
r++;
значение переменной x изме-
нилось на 1
Ссылку можно интерпретиро-
вать как константный указа-
тель, при каждом использова-
нии которого автоматически
происходит разыменование
Модификация
адреса
Если обычный указатель
не объявлен как констант-
ный, то его значение мож-
но изменять.
p++; //изменение
адреса
int y=2;
p = &y;
перенаправление указате-
ля (переменной p при-
сваивается адрес y)
Ссылка тоже содержит адрес,
но этот адрес формируется
один раз при инициализации
и изменить его невозможно!
r++; //изменение значения
по адресу
int y=2;
r=y;
переменной x (адрес которой
содержится в ссылке r) будет
присвоено значение перемен-
ной y
Нулевое значение Указатель может быть ра-
вен нулю (это значение
говорит о том, что указа-
тель никуда не указывает)
Ссылка всегда содержит адрес
того объекта, которым она
была проинициализирована
238 Глава 7
Таблица 7.1 (продолжение)
В чем проявляется
отличие
Указатель Ссылка
Применение опера-
тора &.
Чтобы получить ука-
затель на объект,
псевдонимом кото-
рого является ссыл-
ка r, можно приме-
нить к ссылке
операцию получе-
ния адреса объек-
та — &
Адрес указателя
int** pp = &p;
применение оператора & к
указателю позволяет
сформировать адрес этого
указателя
int y = **pp;
для того, чтобы получить
значение, указатель pp
нужно дважды разымено-
вать
Адрес ссылки
int* pr = &r;
применение оператора & к
ссылке позволяет сформиро-
вать адрес объекта, псевдо-
нимом которого является
ссылка
int y = *pr;
для того, чтобы получить зна-
чение, указатель pr нужно про-
сто разыменовать
Конструкция "Адрес
адреса"
Конструкция типа "указа-
тель на указатель" (T**)
допустима и используется
достаточно часто при соз-
дании сложных структур
данных (см. разд. 6.4.4).
int** pp = &p;
Понятия "ссылка на ссылку"
(T&&) не существует (при по-
пытке такого объявления ком-
пилятор выдаст ошибку):
//int& & rr = r;
//ошибка
Ссылка на указа-
тель
Ссылка на указатель выглядит
непривычно, но довольно час-
то именно такая конструкция
используется для возвраще-
ния адреса переменной-
указателя из функции.
Поскольку функции рассматри-
ваются в гл. 8, то пока просто
покажем механизм использова-
ния такой конструкции:
int n;
int* p = &n;
int*& refP = p;
теперь можно использовать
refP вместо p
*refP = 2;
переменной n будет присвоено
значение 2
//int*& refM =&n;
ошибка: справа не перемен-
ная-указатель, а выражение
для вычисления адреса (для
результата такого выражения
псевдоним ввести невозможно)
Ссылки 239
Таблица 7.1 (продолжение)
В чем проявляется
отличие
Указатель Ссылка
Ключевое слово
void
Можно объявить универ-
сальный указатель типа
void*
void* p; //OK
Ссылку типа void& объявить
невозможно, т. к. ссылка — это
всегда псевдоним совершенно
определенного объекта.
//void& r = x; //ошибка
Оператор sizeof double* p;
size_t n1 =
sizeof(p); //4 байта
size_t n2 =
sizeof(*p); //8 бай-
тов
double d;
double& rd = d;
size_t n = sizeof(rd);
//8 байтов
Инициализация ли-
тералом. Констант-
ная ссылка
//int* p = 0x10000000;
//ошибка
В стиле Си:
int* p = (int*)
0x10000000; //OK
В стиле С++:
int* p = reinterpret_
cast<int*>
(0x10000000); //OK
//int& r = 1; //ошибка
const int& r=1; //OK!
При этом компилятор выделя-
ет память (в нашем случае
sizeof(int)), заносит туда
единицу, а адрес такой фик-
тивной переменной сохраняет
в ссылке r.
Такой прием в данном контек-
сте особого смысла не имеет,
но весьма актуален при пере-
даче параметров функции
(см. разд. 8.6.2)
ЗАМЕ ЧАНИЕ
Применение ссылок так, как это показано в последнем пункте, весьма экзотич-
но (на мой взгляд), а в основном ссылки используются в качестве параметров
функции и возвращаемых функцией значений (см. разд. 8.6.2 и 8.7.2).
Глава 8
Функции
8.1. Понятия, связанные с функциями
Часто встречается ситуация, когда одно и то же действие необходимо выпол-
нить в разных местах программы, возможно, с разными наборами данных.
Нецелесообразно в каждом таком месте приводить одну и ту же последова-
тельность инструкций (один и тот же текст). Нередко оказывается, что необ-
ходимый фрагмент программы уже реализован другими программистами,
в частности — разработчиками библиотек. И в том, и в другом случае нужно
уметь один раз оформлять такие фрагменты специальным образом, а пользо-
ваться ими многократно. Для того чтобы использовать один и тот же код,
требуется обеспечить следующие действия:
1. Сформировать исходные данные (параметры) для такого фрагмента.
2. Передать управление на начало фрагмента (вызвать его).
3. По окончании выполнения фрагмента получить управление и результат
работы назад.
Механизм функций языка C/C++ помогает программисту обеспечить все пе-
речисленные шаги.
Функции — это кирпичики, из которых строится программа (см. разд. 1.2.2).
Они дают программисту возможность заключить часть кода в черный ящик,
который в дальнейшем можно использовать многократно, не интересуясь его
внутренним содержанием. Функции принимают параметры, выполняют после-
довательность инструкций (называемую телом функции), возможно, формируют
результат, а затем возвращают управление (рис. 8.1). Результат, формируе-
мый функцией, представляет собой единственную (в простейшем случае ска-
лярную) величину.
242 Глава 8
Рис. 8.1
Использование функций позволяет:
􀂈 не дублировать многократно код, который выполняет одни и те же дейст-
вия с разными наборами данных;
􀂈 использовать посредством функций чужой код (в частности, возможности
стандартной библиотеки);
􀂈 улучшать структуру программы (путем выделения в отдельную сущность
некоторого законченного действия);
􀂈 уменьшать сложность восприятия больших программ, а при разработке
больших проектов или библиотек функции позволяют группе разработчи-
ков относительно независимо трудиться над своими частями разработки.
Для грамотного использования функций программисту нужно вспомнить про
такие понятия, как объявление и определение (см. разд. 3.5). Как и в случае
переменных, на момент использования (вызова) функции компилятор должен
знать ее свойства. Обычно с функциями связаны три понятия (рис. 8.2): объ-
явление, определение и вызов. Пользуясь клиент-серверной терминологией,
можно рассматривать функцию как сервер, предоставляющий свои сервисы
любому клиенту. Согласно правилам структурного программирования сервер
предоставляет свои услуги клиентам в двух частях: файл реализации (.cpp),
где находится тело функции, и файл интерфейса (.h), в который сервер по-
мещает описание свойств экспортируемой функции. При таком подходе лю-
бому клиенту достаточно подключить заголовочный файл с объявлением
функции, чтобы на момент вызова этой функции компилятор знал ее свойст-
ва и мог сгенерировать низкоуровневый код, обеспечивающий вызов.
ЗАМЕ ЧАНИЕ
Только в единственном случае, когда определение функции и вызов этой функ-
ции находятся в одном файле, а определение предшествует вызову (рис. 8.3),
объявление функции можно опустить.
Функции 243
Рис. 8.2
Рис. 8.3
Обычно сервер, экспортирующий функцию, разделяет понятия на интерфейс
и реализацию (см. разд. 5.6.1) и помещает объявление функции в заголовочный
файл, а собственно программный код функции — в исходный .cpp-файл. Исклю-
чением является оформление встроенной или inline-функции (см. разд. 8.1.4).
Для встроенной функции и объявление, и определение принято помещать
в заголовочный файл. Специфика понятий, связанных с inline-функциями,
представлена на рис. 8.4.
244 Глава 8
Рис. 8.4
8.1.1. Объявление (прототип) функции
Объявление функции — это предварительное описание, которое извещает
компилятор о типе возвращаемого значения, количестве и типах передавае-
мых аргументов и других свойствах функции. Используя прототип, компиля-
тор может выполнить контроль числа аргументов и проверить соответствие
их типов при вызове функции (а при необходимости сделать неявное преобра-
зование типа) и сгенерировать низкоуровневую последовательность команд
для вызова.
Синтаксис:
[спецификатор] [тип] [соглашение по вызову] имя_функции(
[список_аргументов] || [void]);
Здесь:
􀂈 тип — задает тип возвращаемого функцией значения. Если поле отсутст-
вует, то по умолчанию компилятор считает, что функция должна возвра-
щать тип int. Рекомендация: не экономьте на умолчании — хорошим сти-
лем программирования считается указание типа возвращаемого значения
всегда! Некоторые компиляторы при отсутствии типа возвращаемого зна-
чения просто выдают ошибку. Если поле содержит ключевое слово void,
функция не возвращает никакого значения. Так как на формирование воз-
вращаемого значения тратится несколько машинных инструкций, то ис-
пользование void в тех случаях, когда в возвращаемом значении нет необ-
ходимости, позволяет получить более короткий и производительный код.
Функции 245
Примеры:
char MyFunc(); //функция возвращает значение типа char
char* MyFunc(); //функция возвращает значение типа указатель на char
void MyFunc(); //функция не возвращает никакого значения
MyFunc(); //возвращаемый тип – int по умолчанию.
//Замечание: некоторые компиляторы (VC 2005) такое умолчание
не поддерживают!
int MyFunc(); //то же самое, что и в предыдущем объявлении. Явное
указание типа возвращаемого значения является
предпочтительным!
􀂈 имя_функции — его придумывает программист, используя правила и реко-
мендации, перечисленные в разд. 2.2, а компилятор ассоциирует это имя с
адресом начала тела функции. Программист может давать функциям лю-
бые легальные имена, но для того чтобы имена легче воспринимались,
можно все значащие составляющие имени начинать с заглавной буквы
(например, OnMouseMove);
􀂈 список_аргументов — определяет количество и типы аргументов (пара-
метров), передаваемых в функцию.
Синтаксис:
список_аргументов == тип_аргумента1 [имя_аргумента1] ,
тип_аргумента2 [имя_аргумента2]...
• если функция имеет несколько аргументов, то каждая пара
тип_аргумента [имя_аргумента] разделяются запятыми, например:
(int n, double d);
• поле имя_аргумента при объявлении является необязательным и может
быть опущено, т. к. компилятору важен только тип параметра (имя па-
раметра в объявлении функции он просто игнорирует). Но хорошим
тоном считается присутствие в объявлении функции формальных имен,
которые могут предоставить программисту-клиенту дополнительную
информацию о том, каким образом данный параметр будет использо-
ваться функцией. Это упрощает использование и документацию функций.
Например, прототип стандартной функции Cи для копирования строк
выглядит следующим образом:
char* strcpy(char* dest, const char* source);
Из имен параметров dest и source сразу становится ясно, что первый
параметр — это адрес строки-приемника, а второй — адрес строки-
источника (причем ключевое слово const говорит о том, что содержимое
246 Глава 8
источника менять не позволено). При отсутствии имен или неудачном
(бессодержательном) выборе имен параметров пришлось бы искать до-
полнительную информацию о назначении каждого параметра;
• если в функцию не передаются никакие аргументы, то список аргумен-
тов содержит ключевое слово void или пуст. Например:
double* MyFunc(void);
double* MyFunc();
􀂈 спецификатор — несет дополнительную информацию для компилятора:
• inline — о том, что программист хочет сделать эту функцию встроен-
ной (см. разд. 8.1.4);
• static — о том, что функция не подлежит внешней компоновке, т. е. ее
можно использовать только в данном файле;
􀂈 соглашения о вызове — предписывают компилятору по-разному генери-
ровать низкоуровневые инструкции для вызова функции (будут рассмот-
рены в разд. 8.1.5);
􀂈 точка с запятой (;), завершающая объявление функции, обязательна!
ЗАМЕ ЧАНИЕ
По умолчанию в языке С/С++ подразумевается, что все функции подлежат
внешней компоновке (если только при объявлении не фигурирует специфика-
тор static), т. е. объявлены как бы с ключевым словом extern (явно его ука-
зывать не нужно).
8.1.2. Определение функции (реализация)
Определение функции включает те же поля, что и прототип функции, плюс
тело функции, заключенное в фигурные скобки.
Тело функции — это инструкции, выполняемые при ее вызове.
Например, определим функцию, вычисляющую результат выражения:
A * x * x + B * x + C,
где:
􀂈 A, B и C — это коэффициенты, являющиеся константами;
􀂈 x — это параметр, который может принимать любое значение.
my.cpp
double MyFunc(double x) //список формальных параметров (задает
количество, типы и формальные имена).
Функции 247
С этими формальными именами компилятор будет
ассоциировать те фактические значения, которые
переданы в стеке при вызове
{//тело функции содержит последовательность инструкций, которые будут
осуществлять действия над фактическими значениями, переданными в стеке
const double A=5.5, B=6.6, C=7.7;
double result = A*x*x + B*x + C; //вычисление результата
return result; //формирование возвращаемого значения
}
Определение функции в некотором смысле аналогично записи формулы
в алгебре:
y = A * x * x + B * y + C; //это задание правила, по которому будут
производиться реальные вычисления
В формуле мы указываем, сколько переменных будет участвовать в вычисле-
ниях, какие действия с этими переменными следует производить. Само же
вычисление можно произвести только тогда, когда для каждой из перемен-
ных будет задано числовое значение. Формирование конкретных значений
для аргументов функции происходит при вызове функции.
При каждом вызове функции с аргументами компилятор добавляет в точ-
ке вызова машинные инструкции, которые записывают копии значений
аргументов в стек. Функция в процессе исполнения пользуется копиями
аргументов в стеке как локальными переменными, обращаясь к ним по
именам, приведенным в списке формальных аргументов. Копии аргумен-
тов в стеке, с которыми функция будет оперировать, называют фактиче-
скими аргументами.
ЗАМЕ ЧАНИЕ 1
Компилятор ассоциирует имена формальных аргументов со значениями факти-
ческих в стеке. А программист пользуется этими именами как локальными пе-
ременными, область видимости и время жизни которых ограничивается фигур-
ными скобками тела функции.
ЗАМЕ ЧАНИЕ 2
Имена формальных аргументов при определении функции вовсе не обязатель-
но должны быть такими же, как соответствующие имена в списке аргументов
при вызове и тем более при объявлении (где они вообще не обязательны).
ЗАМЕ ЧАНИЕ 3
Недопустимо в теле одной функции определять другую.
248 Глава 8
8.1.3. Вызов функции
Для эффективного и безопасного вызова функции, компилятор должен обес-
печить:
􀂈 связь по управлению:
• передачу управления на начало функции и возврат управления на сле-
дующую за вызовом функции инструкцию;
• сохранение и восстановление контекста вызывающей части. Так как ло-
кальные переменные и вызывающей, и вызываемой функции компилятор
располагает в одном и том же стеке, то он должен гарантировать моно-
польное использование каждой функцией своих локальных переменных.
Поэтому компилятор выделяет для локальных переменных каждой
функции область стека, которая называется стековым кадром (stack
frame). Обращение к локальным переменным компилятор формирует от-
носительно базового значения, которое хранится в регистре (в англоя-
зычной литературе обычно называемом термином frame pointer);
Рис. 8.5
Функции 249
􀂈 связь по данным — механизм, который позволяет передавать данные из
вызывающей функции в вызываемую (pass parameters) и возвращать ре-
зультат работы функции (return value) в вызывающую функцию.
Рассмотрим "анатомию" вызова функции (листинг 8.1), объявленной без спе-
цификатора inline и вызываемой в стиле Си (с соглашением по вызову
__cdecl — см. разд. 8.1.5). Соответствующие ассемблерные команды приве-
дены для процессора х86.
Последовательность действий компилятора помечена цифрами 1—11 (рис. 8.5).
Листинг 8.1. "Анатомия" вызова функции
// Файл sum.h должен содержать интерфейс, предоставляемый сервером
клиенту:
int Sum(int x, int y); //прототип функции
// Файл main.cpp (клиент, в котором осуществляется вызов функции)
#include “sum.h”
int main()
{
int a = 1, b = 5;
int sum = Sum(a, b); //1.Встречая в исходном тексте программы вызов
функции, компилятор использует ее прототип
для проверки количества и типов аргументов
и при необходимости делает преобразование
типов (например, вызов Sum(1, 5.1) будет
преобразован в Sum(1, 5). Если преобразование
с точки зрения компилятора некорректно, то
будет выдана соответствующая диагностика
2.Для формирования параметров компилятор
вставляет низкоуровневую последовательность
команд, в нашем случае: push b и push a.
В стеке оказываются значения 5 и 1
3.Для вызова функции компилятор генерирует
низкоуровневую команду call Sum.
При выполнении этой команды аппаратно в стеке
сохраняется адрес возврата, а затем управление
передается на первую команду функции
250 Глава 8
10.Восстановление стека
(в нашем случае add esp,8)
11.Прием возвращаемого значения (в нашем случае
результат будет сформирован функцией
в регистре: mov [sum],eax
…
}
// Файл sum.cpp (в котором находится реализация функции)
int Sum(int x, int y)
{//Открывающая скобка функции превращается компилятором в:
4.Сохранение контекста вызвавшей функции
(запоминание адреса ее стекового кадра),
в нашем случае — push ebp
5.Формирование контекста текущей функции
(стекового кадра для хранения локальных переменных
текущей функции), в нашем случае:
mov ebp,esp
sub esp,n
где n — количество байтов, необходимых для
хранения локальных переменных текущей функции
(в нашем случае 4)
[5а].В Debug-версии в некоторых реализациях
трансляторов фирмы Microsoft для процессоров х86
весь стековый кадр заполняется значениями 0xcc…c
int s=x+y; //6.Тело функции
return s; //7.Формирование возвращаемого значения (в нашем
случае mov eax,s) и передача управления на
закрывающую фигурную скобку функции
} //8.Восстановление контекста вызвавшей
функции:
mov esp,ebp
pop ebp
//9.Возврат управления – ret
Специфика реализации вызова функции компилятором:
􀂈 при формировании параметров компилятор вставляет в код вызывающей
функции последовательность машинных команд, которые, в свою очередь,
помещают в стек копии переменных, перечисленных в списке аргументов
Функции 251
справа налево. Вместо имен переменных в нашем случае можно было бы
указать непосредственно константы — Sum(1,5). В стеке были бы сфор-
мированы такие же значения.
Низкоуровневая команда push, с помощью которой компилятор формирует
значения параметров в стеке, умеет работать только с операндами, размер
которых равен размеру регистра, поэтому в следующем примере копии бай-
товых переменных c1 и c2 в стеке будут занимать каждая по 4 байта:
char c1=1, c2=2;
int n = sum(c1,c2);
􀂈 если программист в объявлении (и определении) описал функцию как воз-
вращающую значение, то в теле этой функции должна быть инструкция:
return <выражение>;
Если такой инструкции нет, компилятор С++ в большинстве случаев вы-
даст ошибку, а компилятор Си — предупреждение.
При выполнении инструкции return выполняются следующие действия:
• вычисляется выражение;
• формируется возвращаемое значение, при необходимости компилятор
приводит его к требуемому типу (способы формирования возвращае-
мых значений см. разд. 8.3.1);
• управление передается на закрывающую фигурную скобку функции, по
которой восстанавливается контекст вызывающей функции и возвра-
щается управление вызывающей функции;
􀂈 если функция ничего не возвращает (тип возвращаемого значения void),
то можно использовать инструкцию:
return; //без <выражения>
В этом месте компилятор просто передаст управление на закрывающую
фигурную скобку функции. В таком случае излишне завершать тело
функции инструкцией return;
􀂈 инструкция return в соответствующей форме (return; или return <выра-
жение>) может встречаться внутри функции много раз и в любом месте —
как только возникает необходимость возврата. При этом прерывается вы-
полнение функции, а управление передается на закрывающую фигурную
скобку, например:
void f()
{
…
252 Глава 8
if(условие) return;
…
}
􀂈 обычно один из регистров, называемый base frame pointer (в процессорах
архитектуры х86 для этого используется регистр ebp), используется ком-
пилятором для обращения к локальным переменным функции, поэтому
его значение всегда обязательно сохраняется при сохранении контекста и,
соответственно, восстанавливается при возврате из функции;
􀂈 рассмотренный механизм предполагает вызов функции в стиле Си. Если
предписать компилятору ту же самую функцию вызывать с другим согла-
шением по вызову, то последовательность действий тоже будет отличаться.
8.1.4. Вызов inline-функции
Функцию можно определить со спецификатором inline. Такие функции на-
зываются встроенными. Ключевое слова inline указывает компилятору, что
он должен пытаться каждый раз, встречая вызов функции, вместо последова-
тельности действий 1—11, описанной в предыдущем разделе, подставлять
тело функции (в отличие от обычных функций, для которых код существует
в единственном экземпляре, а в месте вызова туда передается управление).
При использовании встроенных функций имеются:
􀂈 положительные моменты:
• исключаются накладные расходы на вызов функции;
• сохраняется структурированность исходного текста программы;
􀂈 отрицательный момент — обычно увеличивается объем кода программы
(.exe-файла).
Специфика использования встроенных функций:
• реализация (тело) inline-функции должна быть в заголовочном файле,
потому что при вызове (чтобы подставить тело) компилятор должен
его видеть;
• ключевое слово inline является только вашим пожеланием компилятору
(inline делает функцию кандидатом на встраивание). Реально такую
вставку компилятор осуществляет только в том случае, если по его (ком-
пилятора) соображениям соотношение затраты/выигрыш (cost/benefit)
является выгодным. Если вы пользуетесь компилятором Microsoft — VC,
то можете заставить компилятор пренебречь такой оценкой и, независи-
мо от соотношения, заставить его встраивать функции, используя ключе-
вое слово __forceinline вместо inline;
Функции 253
􀂈 компилятор не может встроить следующие функции (даже если вы укаже-
те ему __forceinline):
• рекурсивные функции (хотя посредством директивы препроцессора
#pragma inline_recursion on все же можно заставить компилятор та-
кую функцию встроить с точностью до ограничений на количество ре-
курсий);
• функции, вызов которых осуществляется посредством указателя;
• функции с переменным числом параметров.
Пример встроенной функции:
//файл sum.h (в нем находится объявление встроенной функции, совмещенное
с определением)
inline int Sum(int x, int y) //встроенная функция
{
return (x+y);
}
//файл main.cpp (в нем находится вызов встроенной функции)
int main()
{
…
int z = Sum(x,y); //вместо вызова функции в этом месте компилятор
подставит ее тело
}
ЗАМЕ ЧАНИЕ 1
Не злоупотребляйте inline-функциями! Встроенными рекомендуется делать
только очень маленькие функции. При этом текст программы остается структу-
рированным, а накладных расходов на вызов функции удается избежать.
ЗАМЕ ЧАНИЕ 2
Используйте inline-функции вместо макросов (#define), тогда артефактов, ко-
торые не устранить даже скобками (см. разд. 5.2.1), удастся избежать.
Сравните два варианта реализации одного и того же действия: посредством
макроса с параметрами и посредством inline-функции (листинг 8.2).
Листинг 8.2. Использование встроенных функций вместо макроопределений
//1.
#define SQUARE(x) (x)*(x) //макроопределение
inline double Square(double x) { return x*x;} //встроенная функция
254 Глава 8
int main()
{
int x = 2.2;
double res1 = SQUARE(x++); //параметр макроса будет
инкрементирован дважды!
double res2 = Square (x++); //параметр функции компилятор
гарантированно модифицирует один раз!
}
//2.
#define F(x) (x)/2 //макроопределение
inline double f(double x) { return x/2;} //встроенная функция
int main()
{
double res1 = F(5); // res1=2, т. к. препроцессор сделает
макроподстановку, а затем компилятор
по своим правилам вычислит выражение
double res2 = f(5); // res2=2.5, т. к. прежде, чем вызывать
функцию, компилятор приведет тип
параметра к требуемому, а затем
подставит тело функции
}
8.1.5. Соглашения о вызове функции
Существуют разные способы кодирования вызова функций на низком уровне
(т. е. тех последовательностей низкоуровневых инструкций, в которые ком-
пилятор превращает вызов функции, написанный на языке высокого уровня).
Это важно знать при использовании библиотечных функций (например, при
использовании системных функций Windows, которые обычно используют
соглашение о вызове __stdcall) или при сопряжении вашего кода и кода,
возможно, написанного на другом языке программирования. Для указания
компилятору С/С++, во что превращать вызов, существуют следующие клю-
чевые слова, которые программист может использовать при объявлении
(и определении) функции:
__cdecl, __stdcall, __fastcall
ЗАМЕ ЧАНИЕ
Такие ключевые слова, как __pascal, __fortran, для 32-разрядных компиля-
торов считаются устаревшими.
Функции 255
Соглашения определяют следующие моменты:
􀂈 как передаются параметры — помещаются ли они в регистры процессора
(и в какие именно) либо в стек (если да, то в каком порядке);
􀂈 кто восстанавливает стек (вызывающая или вызываемая функция);
􀂈 как формирует компилятор внутреннее имя, т. е. в каком виде имена
функций хранятся в объектном модуле (для использования компоновщи-
ком).
Рассмотрим различия соглашений о вызове на примере (предполагая, что
программа оттранслирована для процессоров х86). Вызовем одну и ту же
функцию с разными соглашениями по вызову:
void calltype f(char c, short s, int i, double d); //где calltype может
иметь значение __cdecl, __fastcall или __stdcall
int main()
{
f('A', 10, 9999, 1.23); //вызов
}
Рассмотрим вызов этой функции с разными соглашениями о вызове.
Соглашение о вызове в стиле Си — __cdecl (табл. 8.1). Это соглашение
о вызове по умолчанию для С/С++-программ, поэтому явно его можно не
указывать (но программист может изменить это умолчание в опциях команд-
ной строки компилятору или задать опции в интегрированных средах с по-
мощью визуальных средств).
Таблица 8.1. Вызов функции с соглашением __cdecl
Характеристики
вызова
Реализация
Как осуществляется
возврат
Низкоуровневой командой ret. При этом управление аппа-
ратно передается на адрес возврата, а регистр ESP пере-
мещается на первый параметр
Кто корректирует
стек — вызывающая
или вызываемая
функция
Стек корректирует вызывающая функция.
В нашем примере — add ESP,20, (где 20 — это количество
байтов, занимаемых в стеке параметрами)
Как формируется
компилятором Си
внутреннее имя
(которое хранится
в объектном и ис-
полняемом модуле
и используется ком-
поновщиком)
_f
256 Глава 8
Таблица 8.1 (окончание)
Характеристики
вызова
Реализация
Как передаются
параметры
Параметры формируются справа налево в стеке низко-
уровневой командой push:
Замечание
Так как команда push умеет заносить в стек только значе-
ния, размер которых совпадает с размером регистра, то
короткие целые (char, short) при передаче в качестве
параметра функции в стеке будут занимать на 32-
разрядной платформе 4 байта. А для того чтобы передать
функции параметр типа double или long long, компилятор
просто два раза использует команду push
Как формируется
внутреннее декори-
рованное компиля-
тором С++ (VC) имя
?f@@YAXDFHN@Z
Здесь A означает соглашение о вызове __cdecl, а все
остальные символы означают количество и типы парамет-
ров и т. д.
Соглашение о вызове __stdcall (табл. 8.2). Может быть использовано в Си-
программе для уменьшения объема исполняемого файла, для вызова функ-
ций из динамически загружаемых библиотек, написанных на других языках,
а также при программировании под Windows при вызове системных
Win32API-функций.
Функции 257
Таблица 8.2. Вызов функции с соглашением __stdcall
Характеристики
вызова
Реализация
Как передаются па-
раметры
Так же, как и при соглашении по вызову __cdecl. Парамет-
ры формируются справа налево в стеке низкоуровневой
командой push:
Как осуществляется
возврат
Низкоуровневой командой ret n. При этом управление
аппаратно передается на адрес возврата, а регистр ESP
изменяет свое значение на n байт
Кто корректирует
стек — вызывающая
или вызываемая
функция
Стек корректирует вызываемая функция при возврате
управления (для чего используется команда процессора
х86 ret n, которая не только выполняет возврат из функ-
ции, но и увеличивает содержимое указателя стека на n бай-
тов, освобождая тем самым место, занятое параметрами)
Как формируется
внутреннее имя ком-
пилятором Си
_f@20
Здесь 20 — это количество байтов, занимаемых парамет-
рами в стеке
Как формируется
внутреннее декори-
рованное имя ком-
пилятором С++ (VC)
?f@@YGXDFHN@Z
Здесь G означает соглашение о вызове __stdcall
Соглашение о вызове __fastcall (табл. 8.3). Компилятор оптимизирует пе-
редачу параметров и, соответственно, время выполнения за счет того, что
часть параметров передается в регистрах.
258 Глава 8
Таблица 8.3. Вызов функции с соглашением __fastcall
Характеристики
вызова
Реализация
Как передаются па-
раметры
Часть параметров (первые два слева, размер которых не
превышает размера регистра) передаются в регистрах
ECX, EDX, остальные — в стеке справа налево низкоуров-
невой командой push:
Как осуществляется
возврат
Низкоуровневой командой ret n
Кто корректирует
стек — вызывающая
или вызываемая
функция
Стек корректирует вызываемая функция
Как формируется
внутреннее имя ком-
пилятором Си
@f@20
Как формируется
внутреннее декори-
рованное имя компи-
лятором С++ (VC)
?f@@YIXDFHN@Z
Здесь I означает соглашение о вызове __fastcall
Декорированные имена — это внутренние (служебные) имена, которые фор-
мируются компилятором, хранятся в объектных файлах и используются ком-
поновщиком для безопасной сборки исполняемого файла (см. разд. 3.6.1).
Схема декорирования зависит от конкретного компилятора. При формирова-
Функции 259
нии декорированного имени компилятор добавляет к имени, данному поль-
зователем, дополнительные символы, несущие информацию:
􀂈 о типах параметров, принимаемых функцией;
􀂈 о соглашении о вызове;
􀂈 об имени пространства имен;
􀂈 об имени класса, если функция является членом класса,
􀂈 и т. д.
8.2. Способы передачи параметров
в функцию
Существуют два способа передачи параметров функции (рис. 8.6): по значе-
нию, когда функции передается копия значения, и по адресу, когда в распо-
ряжение функции предоставляется адрес памяти, где находится оригинал па-
раметра. В свою очередь, адрес в С++ может быть представлен двумя
конструкциями — указателем и ссылкой.
Рис. 8.6
8.2.1. Передача параметров по значению
(Call-By-Value)
Передача параметров по значению (англоязычный эквивалент Call-By-Value) —
это простая передача копий переменных в стеке, не оставляющая никаких
возможностей для изменения значений самих переменных в вызывающей
функции. Пример приведен в листинге 8.3.
Листинг 8.3. Передача параметра по значению
double mypow(double x, int n) //возведение в целую положительную степень
{
if(n<0) return -1.; //проверка корректности параметра
260 Глава 8
double res=1; //здесь будем копить результат
for(; n>0;n--) //при модификации переменной цикла изменяется копия
второго параметра, помещенная в стек!
{ res*=x;}
return res;
}
int main(void)
{
double d= mypow(2.2,10); //в функцию передаются значения 2.2 и 10
//или
double y=2.2;
int m=10;
double d=mypow(y,m); //в функцию в стеке передаются копии значений
переменных y и m, поэтому, что бы мы
ни делали с копиями в вызываемой функции,
в вызывающей функции значения переменных
y и m не изменятся!
}
Передача параметров по значению применяется в тех случаях, когда:
􀂈 общий объем передаваемых аргументов невелик;
􀂈 вы намеренно предоставляете функции копию большого объекта для ис-
пользования (модификации), гарантируя неизменность оригинала в вызы-
вающей части программы.
8.2.2. Передача параметров по адресу
Этот способ предполагает, что в качестве аргументов функция получает не
копии объектов, а их адреса. Передача адреса объекта во многих случаях го-
раздо эффективнее (и одновременно потенциально опаснее) передачи копии
самого объекта, т. к. посредством адреса функция получает доступ к самому
объекту, а накладные расходы на передачу адреса обычно значительно
меньше, чем при передаче копии объекта. Но следует помнить, что, обладая
адресом объекта, программист получает возможность изменить значение
объекта по этому адресу (что не всегда желательно!).
Вызовы функций с передачей адреса объекта в языке С++ подразделяются на
вызовы с передачей по указателю и с передачей по ссылке. Такое деление
является условным, но имеет смысл, поскольку указатели и ссылки подчиня-
ются разным синтаксическим правилам (см. разд. 7.2).
Функции 261
Передача адреса посредством указателя
Такая передача используется для получения в функции доступа к массивам
и другим большим объектам.
Пример приведен в листинге 8.4.
Листинг 8.4. Передача параметров по указателю
//1. Функция подсчета символов в строке (эмуляция функции стандартной
библиотеки strlen)
int MyStrlen(const char* p) //в качестве параметра функция получает адрес
начала массива. Ключевое слово const не
разрешит компилятору внутри функции
посредством адреса модифицировать
содержимое строки
{
if(p==0) return -1; //защита от обращения по нулевому адресу
int n=0; //инициализация счетчика символов
while(*p) //пока с помощью указателя не дошли до конца строки
(признаком конца строки в С/С++ является нулевой байт)
{
p++; //перемещаем указатель на следующий элемент
n++; //учитываем очередной символ
}
return n;
}
//Вызов:
int main()
{
char ar[10]="QWERTY";
int count = MyStrlen(ar); //имя массива эквивалентно указателю
на нулевой элемент
count = MyStrlen("ABC"); //компилятор отправит в функцию адрес
строкового литерала
}
//2. Функция, выполняющая копирование строки (эмуляция функции
стандартной библиотеки strcpy):
int MyStrcpy(char* dest, const char* source) //при этом dest (приемник)
должен содержать достаточно места для копирования!
262 Глава 8
{
if(dest==0 || source==0) return 0; //защита от обращения по
нулевому адресу
int n=0; //счетчик символов
while(*source !=0) //пока не дошли до конца строки-источника
{
*dest = *source; //копируем в приемник очередной
байт источника
source++; //перемещаем указатель на следующий символ
dest++; //подготавливаем приемник для копирования
следующего символа
n++; //увеличиваем счетчик символов
}
*dest=0; //формируем в приемнике признак конца строки
return n;
}
//или:
int MyStrcpy(char* dest, const char* source)
{
if(dest==0 || source==0) return 0;
int n=0;
while(*dest=*source) //Сначала по адресу приемника будет
скопирован очередной байт источника,
а потом скопированное значение будет
использовано для формирования условия
(нулевое значение эквивалентно false)
{
source++;
dest++;
n++;
}
return n;
}
Передача параметров по ссылке
Если функция принимает ссылку на объект, то компилятор должен при вызо-
ве функции сформировать в стеке адрес объекта (см. разд. 7.2). Синтаксис
Функции 263
передачи параметра по ссылке на первый взгляд кажется странным, поэтому
попробуем сформулировать формальные правила:
􀂈 для того чтобы сформировать параметр-ссылку, при вызове следует ука-
зать имя объекта, адрес которого мы хотим таким образом передать. При
этом компилятор, видя прототип функции, где в качестве типа параметра
указана ссылка, сформирует в стеке адрес объекта;
􀂈 внутри функции синтаксически пользуемся ссылкой так же, как обраща-
лись бы к самому объекту (а компилятор, зная о том, что ссылка — это
замаскированный адрес, получает значение по этому адресу).
Пример.
Пусть функция должна сформировать несколько результатов: сумму, раз-
ность… (а возвращаемое значение только одно — в такой ситуации не помо-
жет!). Это означает, что следует передать в функцию адреса, по которым она
сформирует результаты. Для сравнения реализуем такую функцию двумя
способами (табл. 8.4). И в одном, и в другом случае в функцию передаются
адреса переменных, в которых требуется сформировать результаты, однако
синтаксически использование адресов выглядит по-разному.
Таблица 8.4. Сравнение передачи параметров по указателю и по ссылке
Передача параметров по указателю Передача параметров по ссылке
//Определение функции
void fPointer(int x, int y,
int* sum, int* sub)
{
*sum=x+y;
*sub=x-y;
}
//Вызов
int main()
{
int a=2,b=1,r1,r2;
fPointer(a,b,&r1,&r2);
}
//Определение функции
void fReference(int x, int y,
int& sum, int& sub)
{
sum=x+y;
sub=x-y;
}
//Вызов
int main()
{
int a=2,b=1,r1,r2;
fReference (a,b,r1,r2);
}
Если при передаче адреса требуется запретить функции модифицировать
значение по этому адресу, следует использовать ключевое слово const:
void f(const int& r)
{
264 Глава 8
//r++; //ошибка: запрещено модифицировать значение параметра
}
Здесь стоит вспомнить о таком понятии, как константная ссылка (разд. 7.2).
Например:
void f(int& r){}
int main()
{
f(5); //ошибка: компилятор не может сформировать адрес
константы
}
//Но!
void f(const int& r){}
int main()
{
f(5); //OK: компилятор создает фиктивную переменную,
заносит туда значение 5, а адрес переменной
отправляет в качестве параметра в функцию
}
8.2.3. Специфика передачи параметров
Выражения в качестве параметров
Язык С/С++ позволяет указывать в качестве параметров достаточно сложные
выражения (листинг 8.5).
РЕ К О МЕ Н Д А Ц И Я
Далеко не всегда следует усложнять текст своей программы только потому, что
язык программирования обладает такими возможностями. Пишите программы
как можно проще и элегантнее.
Листинг 8.5. Примеры использования выражений в качестве параметров
функции
//1. Если требуется передать в функцию адрес переменной, то совершенно
необязательно для этих целей определять вспомогательную переменную
(указатель или ссылку). Можно сформировать требуемый адрес
непосредственно при вызове:
void f(int*);
Функции 265
int main()
{
int x=1;
//Два варианта формирования в качестве параметра адреса переменной x
//для того чтобы в функцию отпра-
вить адрес объекта, можно завести
вспомогательную переменную-
указатель (компилятор отведет под
нее память)
int* p = &x;
f(p);
//можно не засорять программу та-
кими вспомогательными переменными,
а использовать выражение в качест-
ве параметра. Тогда компилятор
сразу в качестве параметра в стеке
сформирует адрес переменной
f(&x);
}
//2. Пусть в программе реализованы две функции:
int f1();
void f2(int,int);
int main()
{
int x=1, y=5;
//Параметры при вызове f2 можно формировать по-разному:
int z = f1();
int w = x+y;
f2(z, w); //понятнее
f2(f1(), x+y); //компактнее
}
//3. Использование оператора "," при формировании параметров:
void f(int);
int main()
{
int x;
//Пусть значение параметра функции f должен сформировать пользователь:
std::cin>>x;
f(x);
//f(cin>>x,x);//ошибка: указаны
два параметра, а функция принимает
один!
f((cin>>x,x)); OK!
}
Указатели на массивы в качестве параметров функции
Довольно часто возникает необходимость передать в функцию массив (лис-
тинг 8.6).
266 Глава 8
ВА Ж Н О!
Компилятор C/C++ никогда не передает массивы по значению (помещать в стек
копию мегабайтного массива было бы слишком неэффективно!) — передается
только указатель на массив.
Листинг 8.6. Передача массивов в функцию
#include "1.h"
int main()
{
//Даны три массива. Тип элементов массивов — любой (T):
T ar1[K];
T ar2[K][N];
T ar3[K][M][N];
//Требуется передать в функцию все три массива
F(ar1,ar2,ar3);
}
//Файл 1.h
const int N = 5, M=3, K = 2; //константы для размерностей рекомендуется
задавать в заголовочном файле
//Прототип функции:
void F(T* p1, T (*p2)[N], T (*p3)[M][N]);
//или void F(T p1[], T p2[][N], T p3[][M][N]); //поскольку в функцию
передается указатель, и старшая размерность массива
не участвует в вычислении адреса элемента, то можно
оставить самые левые [] пустыми или даже написать
там любое значение!
//Файл 1.cpp
#include "1.h" //необходимо подключить 1.h, т. к. в нем определены
значения размерностей массивов
void F(T* p1, T (*p2)[N], T (*p3)[M][N])
//или void F(T p1[], T p2[][N], T p3[][M][N])
//Замечание. Оба варианта задания типов параметров имеют для компилятора
один и тот же смысл. Как бы не был объявлен каждый параметр,
вы можете пользоваться именем параметра так же, как
пользовались бы именем соответствующего массива, указатель
на который получает функция
{
p1[i]. ..//или *(p1+i)
Функции 267
p2[i][j]. ..//или *(*(p2+i) +j)
p3[i][j][k]... //или *(*(*(p3+i) +j)+k)
//Но!
size_t n = sizeof(p1); //n=4 (количество байтов, занимаемых
указателем)
}
Подумайте, каким будет результат оператора sizeof в следующих выражениях?
size_t n1 = sizeof(p2);
size_t n2 = sizeof(p3);
Ссылки на массивы в качестве параметров
В языке С++ можно использовать ссылки на массив. Имя такой ссылки явля-
ется псевдонимом имени самого массива. Пример использования ссылки для
передачи массива в функцию в качестве параметра приведен в листинге 8.7.
Листинг 8.7. Передача ссылки на массив в функцию
void f(int (&ar)[5][10] )//а) выражение (&ar) должно быть заключено в
скобки, иначе компилятор решит,
что & относится к типу элемента массива
б) при передаче ссылки должны быть указаны
все размерности: int (&ar)[][10] – ошибка!
{
size_t n = sizeof(ar); //количество байтов, занимаемых массивом
равно 200
ar[0][0]=1; //синтаксически пользуемся ссылкой так же,
как именем массива
}
int main()
{
int ar[5][10];
f(ar);
}
Значения параметров по умолчанию (только в С++)
В языке С++ можно задавать значения параметров по умолчанию. Это озна-
чает, что если программист не указал значение одного или нескольких пара-
метров при вызове функции, то компилятор по умолчанию сам может под-
268 Глава 8
ставить эти значения (при условии соблюдения программистом определен-
ных правил).
Опишем эти правила:
􀂈 просто так компилятор ничего подставлять не будет. Если объявлена
функция с двумя параметрами:
void f(int, char);
то при попытке ее вызова с одним параметром:
f(1);
компилятор выдаст ошибку о несоответствии количества параметров (он
ожидает два).
Если же при объявлении функции программист укажет, что данная функ-
ция может иметь параметры по умолчанию и приведет их значения, на-
пример:
void f(int, char = 'A'); //таким образом задается значение
по умолчанию для второго параметра
то компилятор поймет, что в том случае, когда программист при вызове
указал один параметр, значение второго требуется сформировать по умол-
чанию.
Теперь такую функцию можно вызывать двумя способами:
f(1, 'B'); //компилятор сформирует в стеке значения, указанные
программистом (код символа 'B'и 1)
f(1); //а можно и так. Компилятор автоматически добавит значение
для второго параметра, заданное в прототипе, и в стеке будут
сформированы значения 'A' и 1
􀂈 при объявлении можно указать, что функция принимает несколько пара-
метров по умолчанию, но все они (обязательно!) должны располагаться
в конце списка аргументов, например:
//Объявлена функция, у которой два параметра имеют значения
по умолчанию
void f(char, int=2, double=1.1); //OK
//void f(char='A', int, double=1.1); //ошибка: не указано значение
по умолчанию для второго параметра
//Вызывать такую функцию можно следующими способами:
f('Q',1,2.2); //функции будут переданы значения 'Q', 1, 2.2
f('W',5); //'W', 5, 1.1
f('Z'); //'Z', 2, 1.1
//f(); //ошибка: несоответствие количества параметров
Функции 269
􀂈 при вызове функции, имеющей параметры по умолчанию, опускать (не
указывать) значения можно только подряд с конца списка параметров
(т. е. оставить умолчание в середине списка параметров нельзя):
//Объявлена функция, у которой все параметры имеют значения
по умолчанию:
void f(int n=1, const char* p="ABC", double d=1.1);
//Вызывать такую функцию можно следующими способами:
f(5, "QWERTY", 2.2);
f(5, "QWERTY");
f(5);
f();
//Но!
f("QWERTY", 2.2); //ошибка: компилятор пытается преобразовать тип
строкового литерала к типу первого
параметра int, но не может этого сделать
//поставить запятую вместо пропущенного по умолчанию параметра тоже
не допускается
//f(5, ,2.2); //ошибка: лишний символ , (запятая)
􀂈 значения по умолчанию обязательно должны быть указаны при объявле-
нии функции, т. к. компилятор видит только прототип функции, когда
формирует вызов функции (т. е. именно из прототипа он может взять зна-
чения по умолчанию). Лучше не дублировать эти значения при определе-
нии функции, т. к. в одних реализациях у компилятора возникнет двойст-
венность и он выдаст ошибку, а в других — компилятор просто
проигнорирует значение, указанное при определении!
Неиспользуемые параметры (Visual С++)
Бывают случаи, когда после модификации функции оказывается, что какой-
либо из параметров становится ненужным. В Visual С++ (для совместимости
со старыми версиями) оставляют объявления прежними, а в определении
опускают имя такого параметра.
Например:
void Func(int x, int y, char*) //отсутствие имени формального параметра —
это указание компилятору о том, что параметр
использоваться не будет (иначе компилятор выдаст
предупреждение (warning) о том, что данная
переменная не используется)
{
...
}
270 Глава 8
Параметры функции main
Функция main (головная функция программы) может иметь несколько форм
(см. разд. 1.2.2):
􀂈 в версии для ANSI-символов:
int main( void );
int main( int argc [ , char * argv [ ] [, char *envp[ ] ] ] );
􀂈 в версии для Unicode-символов:
int wmain( void );
int wmain( int argc [ , wchar_t * argv [ ] [, wchar_t *envp[ ] ] ]);
Расшифровка параметров для обеих версий ANSI и Unicode поясняется
рис. 8.7, где:
􀂈 argc — число параметров командной строки (формируемой при вызове
функции main в ходе запуска программы), указанных посредством argv.
Имя программы тоже является одним из параметров (поэтому значение
argc всегда >=1);
􀂈 argv — массив указателей на строки. Содержимое строк — это параметры
командной строки, разделенные пробелом (эту информацию может сфор-
мировать запускающая программа или указать пользователь при вызове
программы в командной строке). Каждый элемент массива argv содержит
указатель на строку, а строка содержит слово из командной строки и за-
вершающий ноль (0).
По соглашению:
• argv[0] — это спецификация запускаемого на выполнение исполняемо-
го файла (с полным путем);
• argv[1] — первый аргумент командной строки;
• argv[argc] — всегда 0.
Таким образом, первый аргумент командной строки всегда argv[1], а по-
следний — argv[argc – 1];
􀂈 envp — это массив указателей на строки, каждая из которых описывает
переменную операционной среды или операционного окружения (user environment).
Количество строк зависит от текущей конфигурации, а при-
знаком конца является нулевой указатель. Это специфика Microsoft —
расширение стандарта ANSI C. В качестве переменных окружения может
передаваться следующая информация:
• то, что связано с конкретным пользователем (различные пути): где на-
ходится профиль пользователя, папка Application Data…;
Функции 271
• имя компьютера;
• количество процессоров;
• тип ОС;
• местоположение системного и основного каталога ОС;
• многое другое (подробную информацию об операционном окружении
см. в справочной системе (MSDN Library) по ключевым словам: environment
variables).
Сами строки, передаваемые с помощью envp, — это копия текущего ок-
ружения (на момент запуска вашей программы). Поэтому если вы изме-
няете окружение с помощью соответствующих функций стандартной биб-
лиотеки (putenv() или _wputenv()) в процессе выполнения программы, то
содержимое блоков, на который указывает каждый указатель envp[i], не
изменяется, хотя текущее окружение реально изменяется. В такой ситуа-
ции получить информацию о реальном текущем окружении можно по-
средством вызова getenv()/_wgetenv().
Рис. 8.7
Листинг 8.8 демонстрирует, как можно распечатать параметры командной
строки (сформированные при запуске). Пусть программа имеет имя my.exe
и находится в текущем каталоге. Вызовем ее следующим образом:
my.exe one two three:
Листинг 8.8. Вывод параметров командной строки
int main(int argc, char* argv[])
{
//Параметры командной строки
for(int i=0;i<argc;i++)
272 Глава 8
{
std::cout<<argv[i]<<std::endl;
}
}
Если исполняемый файл my.exe находился, например, в каталоге c:\mydir,
то будет выведено:
c:\mydir\my.exe
one
two
three
Листинг 8.9 демонстрирует, как можно вывести информацию о переменных
окружения, полученную приложением посредством параметра envp.
Листинг 8.9. Вывод переменных окружения
int main(int argc, char* argv[], char *envp[] )
{
//Переменные среды программы
for(int i=0; envp[i]!=0; i++)
{
std::cout<< envp[i]<<std::endl;
}
}
8.2.4. Переменное число параметров
Язык С/С++ допускает использование переменного числа параметров.
ЗАМЕ ЧАНИЕ
Использование переменного числа параметров возможно только для функций
с соглашением по вызову в стиле Си (__cdecl), т. к. только при таком соглаше-
нии стек восстанавливает вызывающая функция. Генерируя вызов функции,
компилятор всегда знает, сколько параметров он сформировал в стеке, поэто-
му может в каждом случае организовать в вызывающей части программы кор-
рекцию стека на требуемую величину (эта величина для разных вызовов изме-
няется в зависимости от фактического числа параметров).
Специфика использования функций с переменным числом параметров:
􀂈 признаком функции с переменным числом аргументов является многоточие
(…) в списке параметров (как при объявлении, так и при определении);
Функции 273
􀂈 встретив многоточие в объявлении функции, компилятор прекращает кон-
троль соответствия типов параметров при вызове, поэтому за все осталь-
ные аргументы несет ответственность программист;
􀂈 у такой функции должен быть хотя бы один обязательный параметр;
􀂈 функция с переменным числом параметров должна иметь способ опреде-
ления точного их числа при каждом вызове (в каждом конкретном случае
разработчик такой функции придумывает способ, позволяющий опреде-
лить количество и типы параметров, а программист, вызывающий эту
функцию, должен следовать правилам разработчика).
Примеры объявления функции с переменным числом параметров:
􀂈 int Func1(int i, ...); //функцию можно вызывать с одним и более
параметрами
􀂈 int Func2(int i, char byte, ...); //функция должна иметь
не менее двух параметров при вызове
Листинг 8.10 иллюстрирует вызов функции с переменным числом парамет-
ров (пояснение — на рис. 8.8). В нем разработчик функции использовал
в качестве признака окончания списка параметров дополнительный параметр —
признак, всегда равный –1.
Листинг 8.10. Функция получает любое количество целых положительных
параметров типа int и возвращает их среднее значение
//файл 1.h
//прототип функции с переменным числом параметров
double Average( int nFirst, ... );
//файл main.cpp (вызов функции)
#include <iostream>
int main( void )
{
//вызов функции с тремя целыми параметрами (-1 — признак конца)
double aver = Average( 2, 3, 4, -1 ) //на рис. 8.8 показано,
каким образом компилятор
формирует стек при вызове
функции
std::cout<< "Average = "<< aver <<std::endl;
//вызов функции с четырьмя целыми параметрами
std::cout<< "Average = "<< Average( 2, 3, 4, 5,-1 ) <<std::endl;
274 Глава 8
//вызов функции только с признаком конца
std::cout<< "Average = "<< Average(-1) <<std::endl;
}
//файл 1.cpp (реализация функции).
//вариант 1 (без использования макросов стандартной библиотеки).
double Average( int first, ... )
{
int count = 0, sum=0;
int* p = &first; //установили вспомогательный указатель на первый
параметр
while(*p != -1)
{
sum += *p++; //суммируем значение по текущему адресу
p++; //перемещаем указатель на следующий параметр
count++;
}
}
Подумайте, как корректно сформировать возвращаемое значение, чтобы:
а) не потерять точность;
б) можно было бы вызвать такую функцию без единого содержательного
параметра, а только с признаком конца (–1)
return <возвращаемое_значение>;
Рис. 8.8
Функции 275
Приведенный в листинге 8.10 пример довольно простой, т. к. все необяза-
тельные параметры одного и того же типа — int. На самом деле задача ус-
ложняется, когда параметры разного типа, и нужно иметь возможность опре-
делять не только количество параметров, но и тип каждого, чтобы правильно
модифицировать указатель!
Рис. 8.9
Стандартная библиотека предоставляет несколько макрокоманд для манипу-
ляции параметрами такой функции (макросы определены в заголовочном
файле <cstdarg>): va_start, va_arg, va_end и va_list. Выполнение макроса
va_arg поясняется рис. 8.9.
typedef char * va_list; //используется для описания универсального
указателя (т. к. байт является наименьшей
адресуемой единицей, то в такой указатель
можно занести адрес объекта любого типа)
#define va_start(ap,v) ( ap = (va_list)&v + _INTSIZEOF(v) ) //где:
v-это имя последнего обязательного параметра,
ap — имя универсального указателя. Макрос
направляет универсальный указатель на первый
необязательный параметр
276 Глава 8
#define va_arg(ap,t) (*(t*)((ap += _INTSIZEOF(t))-_INTSIZEOF(t))) //
ap — универсальный указатель,
t — тип текущего параметра (который должен быть
известен). Макрос формирует значение текущего
параметра, а универсальный указатель сдвигает
на следующий аргумент (рис. 8.9).
Последовательность выполнения тела макроса
помечена цифрами 1—4
#define va_end(ap) ( ap = (va_list)0 ) //обнуляет универсальный
указатель
При перемещении указателя используется еще один вспомогательный макрос
_INTSIZEOF, который очень хитро вычисляет, сколько байтов в стеке занимает
переменная типа t:
#define _INTSIZEOF(t) ((sizeof(t)+sizeof(int)-1) & ~(sizeof(int)–1))
Используем перечисленные макросы для модификации предыдущего приме-
ра (листинг 8.11).
Листинг 8.11. Пример использования макросов стандартной библиотеки
//файл 1.cpp
#include <сstdarg>
double Average( int first, ... )
{
int count = 0, sum = 0;
int i = first; //значение обязательного параметра (в частности,
может быть –1)
va_list p; //универсальный указатель
va_start( p, first ); //направили универсальный указатель на
первый необязательный параметр
while( i != -1 )
{
sum += i;
count++;
i = va_arg( p, int); //получили значение текущего
параметра, а p переместили на
следующий
}
Функции 277
va_end( p ); //в данном случае обнулять универсальный указатель
необязательно, т. к. область видимости и время
жизни локальной переменной p заканчивается по
закрывающей скобке функции
return (count !=0 ) ? static_cast<double>(sum)/count : 0;
//подсказка для тех, кто выполнил предыдущее задание
}
Функции стандартной библиотеки printf, scanf
(процедурно-ориентированные потоковые
функции ввода/вывода)
Поток (stream) — это устоявшийся термин для обозначения программных
средств по организации ввода/вывода. А т. к. задачи ввода/вывода возникают
практически в каждой программе и достаточно сложны в реализации, то раз-
работчики стандартной библиотеки предоставляют прикладному программи-
сту эти возможности посредством функций и специальных структур данных.
При запуске программы в стартовом коде стандартной библиотеки создаются
и инициализируются структуры данных типа FILE (структуры рассматрива-
ются в гл. 9, тип FILE описан в справочной системе), которые по умолчанию
связываются с устройствами ввода/вывода (ввод осуществляется с клавиату-
ры, вывод — на экран). Поэтому эти структуры данных принято называть
стандартными потоками ввода/вывода. Именно стандартные потоки вво-
да/вывода по умолчанию используются функциями стандартной библиотеки
для вывода на экран консольного приложения (в частности, функцией printf)
и приема пользовательского ввода с клавиатуры (в частности, функцией
scanf). Для явного использования этих структур данных программисту пре-
доставляются соответствующие глобальные указатели типа FILE*:
􀂈 stdout — указатель на структуру данных, связанную с потоком вывода;
􀂈 stdin — аналогичный указатель для потока ввода.
Функции printf()и scanf() используются для форматированного вывода и
являются классическими примерами функций с переменным числом пара-
метров (объявлены в заголовочном файле <cstdio>).
Ôîðìàòèðîâàííûé âûâîä
Рассмотрим особенности функции printf() (и ее аналогов: fprintf() — для
файлового вывода и sprintf() — для форматирования строк в памяти).
Прототип:
int printf(const char *,…); //выводит данные на экран. При переводе
значений в строковое представление
278 Глава 8
использует однобайтовые символы
int wprintf(const wchar_t*,...); //при переводе значений в строковое
представление использует расширенные
символы (UNICODE)
int _tprintf(const TCHAR*,...); //макрос, который превращается
препроцессором в printf или wprintf
в зависимости от определенности
идентификатора _UNICODE. Это cпецифика
Microsoft
Специфика использования функции printf():
􀂈 функция выполняет два действия:
• исходя из указанных параметров, формирует результирующую строку;
• выводит ее на экран;
􀂈 программист, безусловно, может сам сформировать любую строку и вос-
пользоваться другой функцией стандартной библиотеки (например,
puts()) для ее вывода, но разработчики стандартной библиотеки решили
облегчить задачу форматирования строк и предложили посредством
printf() свой способ перевода в текстовый вид и форматирования любых
значений базового типа. Функция printf() принимает один обязательный
параметр — это строка, в которой программист может привести как текст,
который требуется распечатать, так и специальным образом (посредством
символа % и некоторой дополнительной информации) указать, что он хо-
чет включить в результирующий текст строковое представление значения
одной или нескольких переменных. А т. к. количество переменных в раз-
ных случаях разное, то список этих переменных задается посредством не-
обязательных параметров функции. Функция анализирует обязательный
параметр и, встретив символ %, вставляет вместо него в результирующий
текст значение очередного необязательного параметра, форматируя его
в соответствии с указаниями программиста. На рис. 8.10 представлена по-
добная ситуация. В результате будет выведено:
I want to print 1, A;
􀂈 наличие необязательного параметра обозначается символом % в единст-
венном обязательном параметре — строке. За символом % программист
должен указать, что он собирается выводить (целое, плавающее, строку
и т. д.), и может уточнить, каким образом он хотел бы, чтобы это значение
появилось на экране (сколько цифр после запятой, сколько знакомест от-
вести под значение, как позиционировать в поле вывода и т. д.);
Функции 279
Рис. 8.10
Рис. 8.11
􀂈 управлять выводом можно с помощью дополнительных элементов, кото-
рые помещаются за символом % (рис. 8.11):
• обязательное поле type, называемое спецификатором вывода (специ-
фикаторы указывают, какого типа очередной необязательный пара-
метр, а следовательно, как следует его преобразовывать в строковое
представление (табл. 8.5));
• совокупность необязательных полей, называемых модификаторами
вывода (указывают, как форматировать и позиционировать при выводе
(табл. 8.6)).
ЗАМЕ ЧАНИЕ 1
Если указанного посредством модификатора количества позиций для вывода
значения недостаточно, то функция выделяет большее количество позиций —
усечения не произойдет!
ЗАМЕ ЧАНИЕ 2
В табл. 8.6 даны далеко не все возможности форматирования — исчерпывающее
описание имеется в справочной системе MSDN Library. Некоторые наиболее
полезные возможности приведены в последующих примерах на стр. 282 и 283.
280 Глава 8
Таблица 8.5. Спецификаторы ввода/вывода
Спецификаторы Пример задания аргумента Будет выведено
%с char x='A',y = 'B';
printf("%c\n%c",x,y);
A
B
%d или %i int x=1,y=2;
printf("x=%d, y=%i", x, y);
x=1, y=2
%e или %E double x=1.1; float y=2.2;
printf("x=%e\ny=%E", x, y);
[-]m.nnnnnn[+-]kkk (поле nnn —
по умолчанию 6)
x=1.100000e+000
y=2.200000e+000
%f float y=2.2;
printf("y=%f",y);
[-]m.nnnnnn (поле nnn — по умол-
чанию 6)
y=2.200000
%g или %G используется наиболее подходящий
(короткий) из форматов e и f (незна-
чащие нули не печатаются)
double x=1.1, y=2.222e2;
printf("x=%g\ny=%G", x, y);
x=1.1
y=222.2
%o восьмеричное представление
int k = 10;
printf("k=%o",k);
k=12
%p значение адреса (указателя) в шест-
надцатеричном виде
printf("address=%p",&k);
address=значение_адр
еса
%s печать строки
char ar [] = "QWERTY";
printf("%s",ar);
QWERTY
%u преобразование аргумента к целому
беззнаковому в десятичном виде
int m = -1;
printf("%u",m);
4294967295
%x или %X шестнадцатеричное представление
int m = -1;
printf("%x",m);
ffffffff
Функции 281
Таблица 8.6. Модификаторы ввода/вывода
Модификаторы вывода Пример Будет выведено *
Для строки
%[+-n]s
отводит минимум n позиций и
в отведенном поле вывода
позиционирует строку в зави-
симости от знака:
минус — сдвигает влево,
плюс (или знак опущен) —
сдвигает вправо
char ar[] = "QWERTY";
printf("%10s",ar);
printf("%+10s",ar);
printf("%-10sW",ar);
^^^^QWERTY – в
указанном диапазоне
смещает вправо (вы-
равнивается по пра-
вому краю)
QWERTY^^^^W —
в указанном диапа-
зоне смещает влево
Для вещественного числа —
%[+-n.m]f
или
%[+-n.m]e
или
%[+-n.m]g
где:
n — общее количество знако-
мест для представления зна-
чения, включая точку,
m — количество цифр после
десятичной точки
double x=1.11111;
float y=2.2222;
printf("x=%10.2e,\ny=
%10.2f,", x, y);
printf("x=
%-10.2e,\ny=%-10.2f,",
x, y);
x=^1.11e+000,
y=^^^^^^2.22,
x=1.11e+000^,
y=2.22^^^^^^,
Для вещественного числа —
%[n]f
или
%[n]e
или
%[n]g
n — количество знакомест
для преобразованного значе-
ния, а количество цифр после
десятичной точки определя-
ется по умолчанию
double x=1.1;
float y=2.2;
printf("x=%4g\ny=%5G",
x, y);
printf("x=%4f\ny=%5f",
x, y);
x=^1.1
y=^^2.2
x=1.100000
y=2.200000
Для целого числа — количество
знакомест для расположения
преобразованного значения
%[+-n]d
или
%[+-n]i
int x = -1;
printf("%5d\n",x);
^^^-1
* — вместо пробела для демонстрации результата используем символ ^.
282 Глава 8
Пример 1.
Использование одного обязательного параметра функции printf():
printf("one\ntwo\nthree"); //будет выведено:
one
two
three
Пример 2.
Использование спецификаторов вывода (листинг 8.12).
Листинг 8.12. Использование спецификаторов для преобразования значений
{
int x=1;
double y = 2.22;
char ar[] = "ABC";
//Функция принимает три необязательных параметра: x,y,ar
printf("x=%d\ny=%f\nar=%s",x,y,ar); //вывод:
x=1
y=2.220000 – по умолчанию 6 символов после точки
ar=ABC
}
Пример 3.
Использование модификаторов вывода.
Без применения позиционирования текста столбцы таблицы съезжали бы
в сторону в зависимости от значения. Красивый вывод таблицы целых чисел
представлен в листинге 8.13.
Листинг 8.13. Использование модификаторов для позиционирования значений
int ar[3][4] = {1,35000,4,5000000,6};
for(int i=0; i<3; i++)
{
for (int j=0; j<4; j++)
{
printf("ar[%d][%d]=%-7d ",i,j,ar[i][j]);
}
printf("\n");
}
Функции 283
Пример 4.
Использование функции sprintf() для форматирования текста в памяти.
Эта функция имеет два обязательных параметра:
􀂈 адрес зарезервированной области памяти, куда будет помещена результи-
рующая строка;
􀂈 строку, содержащую ключи форматирования (листинг 8.14).
Листинг 8.14. Форматирование строки в памяти
{
char ar[100]; //место для результирующей строки
char name[] = "Betty";
int age = 13;
sprintf( ar, "My dog %s is %d years old", name ,age);
//в массиве ar будет сформирована строка: My dog Betty is 13 years old
}
Пример 5.
Использование функции fprintf() для форматированного вывода в файл.
Функция принимает два обязательных параметра:
􀂈 указатель на структуру типа FILE (FILE — это структура, которую предос-
тавляет стандартная библиотека для обмена данными с устройством);
􀂈 строку, содержащую ключи форматирования.
Если для вывода на экран программист мог использовать по умолчанию
стандартный поток вывода (stdout), то при записи в файл требуется явно ука-
зать, с каким файлом должен быть связан поток вывода и каким образом про-
граммист собирается этим файлом пользоваться (читать/писать). Ассоцииро-
вать поток вывода с файлом можно с помощью функции стандартной
библиотеки fopen()(листинг 8.15).
Листинг 8.15. Форматированный вывод в файл
{
FILE* f = fopen("my.txt","w"); //открываем файл my.txt
для записи ("w")
if(f) //если файл удалось открыть, будет возвращен
ненулевой указатель
{
284 Глава 8
int x=1;
char ar[] = "QWERTY";
fprintf(f,"x:%d string:%s",x,ar); //пробел обязателен
fclose(f);
//содержимое файла: x:1 string:QWERTY
}else …//иначе файл открыть не удалось
}
Ôîðìàòèðîâàííûé ââîä
Семейство функций scanf предназначено для преобразований из строкового
представления в значение, указанное программистом посредством специфи-
катора ввода.
int scanf(const char *,…); //вариант для однобайтовых символов
int wscanf(const wchar_t*,...); //аналог для расширенных символов UNICODE
int _tscanf(const TCHAR*,...); //макрос, предоставляемый Visual C++,
который превращается в scanf()
или wscanf() в зависимости от
определенности имени _UNICODE
Специфика:
􀂈 функция scanf() принимает пользовательский ввод с клавиатуры и ис-
пользует для ввода стандартный поток ввода — stdin;
􀂈 scanf() принимает один обязательный параметр — строку, посредством
которой интерпретируются вводимые значения, и любое количество не-
обязательных параметров. Символ % в форматной строке говорит о том,
что нужно считать очередное значение.
Спецификация формата:
%[*][width][{h || l || I || I32 || I64}] type
􀂈 разделителями при вводе являются: пробел, табуляция, перевод строки;
􀂈 при задании необязательных параметров принципиальным является ука-
зание адреса переменной, по которому будет помещен результат перевода
из строкового представления! Так как компилятор не может проконтроли-
ровать тип необязательного параметра, то сообщения об ошибке в случае
некорректного значения он не выдаст, зато, скорее всего, возникнет
ошибка во время выполнения;
􀂈 с помощью спецификатора формата * можно предписать функции проиг-
норировать очередное введенное значение. В таком случае в списке необя-
зательных параметров соответствующий параметр просто отсутствует.
Функции 285
Пример 1.
Использование спецификаторов ввода для преобразования из строкового
представления в значение требуемого типа (листинг 8.16).
Листинг 8.16. Использование спецификаторов ввода
int x;
float y ;
double z ;
char ar[5] ;
scanf("%d %f %lf %s",&x,&y,&z,ar); //введенный пользователем текст будет
преобразован в соответствии с
указанным после % спецификатором
ввода, а полученное значение будет
записано по указанному в качестве
необязательного параметра адресу
Пример 2.
Использование спецификатора формата *:
scanf("%d %*f %s",&x,ar); //* указывает, что соответствующее значение
нужно считать из потока ввода, но не
сохранять в переменной (поэтому
соответствующий адрес в списке
необязательных параметров отсутствует)
Пример 3.
Если пользователь набрал: <n=1>, то n= нужно считать и проигнорировать, а 1
перевести в целое представление. Для этого нужно явно в строке формата
привести тот текст, который функция должна проигнорировать:
int n;
scanf("n=%d",&n); //если набираем n=1, то n= игнорируется, а 1 вводится
в переменную n
Пример 4.
Если пользователь вводит строку, то всегда есть шанс, что он введет больше
символов, чем программист зарезервировал памяти. Поэтому нужно уметь
защищаться от таких ситуаций с помощью модификаторов ввода:
char ar[5]; //зарезервировано только 5 байтов!
int n=scanf("%4s ",ar); //поэтому позволяем ввести только 5 символов,
включая завершающий 0
286 Глава 8
fflush(stdin); //а если строка оказывается длиннее, то не считанный
остаток остается в буфере и будет считан при следующем
вызове scanf(), поэтому нужно очистить буфер потока
ввода функцией fflush()
Пример 5.
Файловый ввод с помощью функции fscanf().
Считаем из файла my.txt ту информацию, которую записали туда в листин-
ге 8.15. Листинг 8.17 демонстрирует считывание текстовой информации из
файла и преобразование значащей информации в требуемый вид.
Листинг 8.17. Форматированный файловый ввод
{
FILE* f = fopen("my.txt","r"); //открываем файл для чтения
if(f) //если удалось открыть файл
{
//резервируем память для вводимых значений
int x;
char ar[10];
//считываем те данные, которые нас интересуют, а
вспомогательную информацию игнорируем
fscanf(f,"x:%d string:%s",&x,ar); //x: считывается, но
игнорируется, аналогично
string: считывается, но
игнорируется
//в результате: x=1, ar = “QWERTY”
fclose(f);
} else…//иначе файл открыть не удалось
}
Пример 6.
Форматирование строк в памяти посредством функции sscanf() (листинг 8.18).
Листинг 8.18. Считывание данных из строки в памяти
{
char s[] = "1 2 3 4"; //строка, из которой будем считывать очередную
порцию текста до разделителя (пробела) и
преобразовывать в указанные нами значения
Функции 287
char buf[10];
char c;
int i;
float f;
sscanf( s, "%s %c %d %f", buf,&c,&i,&f );
//В результате: buf="1", c='2', i=3, f=4.0
}
8.3. Возвращаемое значение
8.3.1. Виды возвращаемых значений и механизмы
их формирования
Функция может возвращать (рис. 8.12):
а) значение одного из базовых типов,
б) объект пользовательского типа;
в) адрес.
Рис. 8.12
Данные разного типа возвращаются по-разному:
􀂈 значения из а) и в), помещающиеся в регистр, возвращаются на регистре
(для x86 процессоров используется регистр EAX);
􀂈 длинные целые (long long) возвращаются на паре регистров (EAX, EDX);
􀂈 значения типа float и double возвращаются в стеке плавающей точки по-
средством низкоуровневых команд: fld (load real — занести в стек пла-
вающей точки), fstp (store real — извлечь из стека);
288 Глава 8
􀂈 массивы по значению не возвращаются, можно вернуть только адрес на-
чала массива;
􀂈 механизм возвращения структур, объединений или классов более сложен
и будет рассмотрен в разд. 9.12.2.
Пример 1.
Возвращаемое функцией значение можно присвоить переменной подходяще-
го типа или использовать другими способами.
bool Func();
int main()
{
bool b = Func(); //возвращаемое функцией значение будет присвоено
переменной b
//или
if(Func()){…}//возвращаемое значение используется для формирования
условия
}
Пример 2.
Поиск минимального значения в массиве (листинг 8.19).
Листинг 8.19. Возвращение указателя
//файл 1.cpp
int* Min(int ar[ ], unsigned int n)
{
int* p = ar; //предполагаем, что минимальным является нулевой
элемент массива и направляем на него указатель
for(int i = 0; i<n; i++)
{
if(ar[i]<*p) //а если i-тое значение оказалось меньше
{
p = &ar[i]; //перенаправляем на него указатель
}
return p; //в результате в переменной p будет адрес элемента
массива с самым маленьким значением
}
//файл 1.h
int* Min(int ar[ ], unsigned int n);
Функции 289
//файл main.cpp
#include <cstdio>
#include “1.h”
int main()
{
int mas[] = {3, 6, -1, 0, -10, 55};
int* pMin = Min(mas, sizeof(mas)/sizeof(mas[0]));
printf("min=%d",*pMin);
return 0;
}
Бывают случаи, когда вы не используете возвращаемое функцией значение
(вам достаточно действий, которые осуществляет функция), тогда совершен-
но не обязательно заводить переменную, которая будет ненужное возвра-
щаемое значение принимать. В этом случае в вызываемой функции возвра-
щаемое значение формируется, а в вызывающей не принимается. Например:
bool Func();
int main()
{
Func();
}
Если функция возвращает адрес, то ее вызов можно использовать как lvalue
(например, слева от присваивания), в этом случае значение rvalue будет по-
мещено в память по адресу, возвращенному функцией:
int& f1()
{
static int n;
return n;
}
int* f1()
{
static int n;
return &n;
}
int main()
{
f1() = 1; //по возвращаемому адресу занести новое значение
*f2() = 1; //аналогично
}
290 Глава 8
Подумайте, почему в функциях f1 и f2 переменная n объявлена с ключе-
вым словом static, и сверьте ваши предположения с предостережением
в разд. 8.3.2.
8.3.2. Проблемы при возвращении ссылки
или указателя
При возвращении ссылки или указателя из функции объект, на который ука-
зывает возвращаемое значение, должен существовать после возврата из
функции. Пример, приведенный в листинге 8.19, корректен, т. к. возвращает-
ся адрес элемента массива, который, безусловно, существует после возврата
из функции. При написании функций, возвращающих указатель или ссылку,
начинающий программист часто допускает ошибки, продемонстрированные
в листинге 8.20.
Листинг 8.20. Примеры некорректных возвращаемых значений
int* f1(int n)
{
int nN = n*5;
...
return &nN; //никогда так не делайте! Ваша функция вернет
указатель на область памяти в стеке, которая после
возвращения из функции может быть задействована
компилятором для других целей
}
int& f2(int n)
{
int nN=n*5;
...
return nN; //и так тоже никогда не делайте! Ваша функция
по-прежнему возвращает адрес временной переменной!
}
int main()
{
int z = f2(3); //переменной z будет присвоено значение по адресу,
возвращенному из функции. На первый взгляд
проблем нет, и в данном примере z=15,
как и ожидалось
}
Функции 291
Попробуйте спрогнозировать и объяснить результат вычисления выраже-
ния:
z = f2(1) + f2(2) + f2(3);
А сейчас рассмотрим подробнее пример, в котором станет очевидным, поче-
му нельзя возвращать адреса локальных (временных) объектов (листинг 8.21
и рис. 8.13).
Листинг 8.21. Пример, из которого вполне очевидно, что так делать не годится
char* f1()
{
char ar[] = "ABC"; //это локальный массив, для него компилятор
выделяет память в стековом кадре функции
только на время ее выполнения
...
return ar; //возвращается адрес локального массива!
}
void f2() //функция ничего не возвращает
{
int tmp = 0x44332211; //но использует локальную переменную,
для которой компилятор выделяет память
в стековом кадре
...
}
int main()
{
char* p = f1(); //при вызове функции компилятор сформировал
стековый кадр, как показано на рис. 8.13.
Возвращенный адрес запомнили в переменной p.
После возврата из функции компилятор считает,
что эта область стека свободна и использует
ее при вызове следующей функции
f2(); //вызываем другую функцию. Для ее локальных переменных
компилятор использует ту же самую область стека и
располагает в этой области совершенно другое значение
}
292 Глава 8
А теперь попробуем воспользоваться указателем p, рассчитывая, что он
указывает на нужную нам строку. Попробуйте догадаться, что будет напе-
чатано?
printf("%c", p[0]);
Рис. 8.13
ПР Е ДО СТ Е Р Е Ж Е НИ Е
Нельзя возвращать адреса локальных объектов! Ситуация будет еще хуже,
если локальный объект — пользовательского типа (класса) (по закрывающей
скобке функции для такого объекта компилятор будет автоматически вызывать
деструктор).
Возвращать можно адреса таких объектов, которые гарантированно сущест-
вуют после возврата из функции:
􀂈 указатель или ссылку на объект, который располагается в стековом кадре
вызвавшей функции (см. листинг 8.19);
􀂈 указатель или ссылку на объект со статическим временем существования;
􀂈 указатель на строковый литерал (для него память будет выделена на все
время выполнения программы);
􀂈 указатель на динамически созданный объект. Следует отметить, что в этом
случае возникает другая проблема — вызывающая функция должна освобо-
дить память, т. е. программист должен, как минимум, знать о том, что функ-
ция возвращает указатель на динамически захваченный блок памяти.
8.4. Ключевое слово const и функции
Применительно к функциям ключевое слово const может относиться как
к принимаемым функцией параметрам, так и к возвращаемому значению.
Функции 293
8.4.1. Передача функции константных параметров
Если параметр объявлен с ключевым словом const, то это является гарантией
того, что компилятор не позволит модифицировать такой параметр в теле
функции. Обычно константные параметры используют в тех случаях, когда
речь идет о передаче в функцию адреса объекта, например:
void SomeFunc(const int* pn);
Такое объявление параметра pn обеспечивает неизменяемость объекта, на
который указывает pn, функцией SomeFunc(). Объявление функций с кон-
стантными параметрами позволяет компилятору блокировать нежелательные
побочные эффекты вызова функций (когда модификация значения по пере-
даваемому адресу не желательна). Пример приведен в листинге 8.22.
Листинг 8.22. Передача функции константных параметров
void Func(const char* pc) //объявление параметра const гарантирует, что
в области видимости функции значение самого
объекта не изменится
{
//*pc = 'A'; //ошибка: запрещено модифицировать константу
}
int main()
{
Func("1234");
}
ЗАМЕ ЧАНИЕ
При объявлении константных параметров ключевое слово const должно фигу-
рировать как в объявлении функции, так и при определении. Иначе компилятор
решит, что это две разные функции и на этапе компоновки будет выдана ошибка.
Например:
//1.h
void f(const int* k); //прототип функции
//1.cpp
void f(int* k) //определение функции (ключевое слово const опущено)
{
…
}
//main.cpp
294 Глава 8
int main() {
int n = 1;
f(&n);
}
Компоновщиком будет выдано сообщение об ошибке: не найдена реализация
функции void f(const int* k);
Нет необходимости объявлять с модификатором const параметры, которые
передаются по значению, т. к. функция получает только копии исходных пе-
ременных (см. разд. 8.2.1), а вызывающей функции все равно — модифици-
рует вызванная функция свою копию или нет.
void f(const int n) //необязательно объявлять такой параметр const
{…}
8.4.2. Возвращение функцией константных
значений
Возвращение константных значений, пожалуй, имеет смысл только при воз-
врате адреса, т. к. если функция возвращает просто значение, то вызов функ-
ции в любом случае можно использовать лишь справа от знака равенства.
Пример использования ключевого слова const приведен в листинге 8.23.
Листинг 8.23. Возвращение константных значений
char* GetName1() //тип возвращаемого значения задан некорректно, т. к.
посредством возвращаемого адреса компилятор позволит
модифицировать значение, что скорее всего приведет к
ошибке времени выполнения (см. разд. 3.2.4)
{return "Name1";}
const char* GetName2() //корректное возвращаемое значение, т. к.
компилятор предотвратит модификацию значения по
возвращаемому адресу
{return "Name2";}
int main()
{
char* p1 = GetName1();
p1[2] = 'A'; //компилятор сообщения об ошибке не выдаст, т. к.
синтаксически все корректно, но при выполнении
Функции 295
программы в защищенном режиме произойдет ошибка
времени выполнения
char tmp = GetName1()[0]; //OK – получили код символа N
GetName1()[0]='A'; //ошибка времени выполнения
//но!
//char* p2 = GetName2(); //ошибка: см. разд. 6.1.8
const char* pc2 = GetName2(); //OK
//pс2[2] = 'A'; //ошибка: указываемое значение - константа
char tmp = GetName2()[0]; //OK – получили код символа N
//GetName2()[0]='A'; //ошибка: возвращается указатель на константу
}
Подумайте, имеет ли смысл и корректно ли объявлена такая функция?
char* const GetName3()
{return "Name3";} //функция возвращает константный указатель
8.5. Перегрузка имен функций
Одной из особенностей С++ является возможность перегрузки имен функ-
ций, т. е. использования одного и того же имени для нескольких разных
функций. Техника перегрузки неявно используется компилятором для базо-
вых операций С/С++. Например, существует только одно имя для операции
сложения (+), но вы используете это имя для сложения целых чисел, чисел
с плавающей точкой, прибавляете целое к указателю, может быть, даже не
задумываясь о том, что компилятор при этом генерирует совершенно разные
машинные инструкции.
Идея перегрузки операций легко распространяется на функции, определяе-
мые пользователем. Иногда такой подход бывает очень удобен, когда функ-
ции выполняют аналогичные по семантике действия (например, сложение).
Компилятор различает такие функции по числу и/или типу параметров. При
каждом конкретном вызове перегруженной функции компилятор должен оп-
ределить, какую из функций с данным именем вызвать. Цель компилятора
состоит в том, чтобы использовать функцию с наиболее подходящими ар-
гументами или выдать сообщение об ошибке, если подходящей функции не
найдено.
ЗАМЕ ЧАНИЕ
Механизм перегрузки имен функций возможен ввиду того, что функции с одним
и тем же именем, но с разным количеством и/или разными типами параметров
компилятор декорирует по-разному (см. разд. 3.6.1 и 8.1.5).
296 Глава 8
Пример 1.
Если такой возможности, как перегрузка имен функций, нет (например,
в языке ANSI Си), то программист должен давать функциям, выполняющим
близкие по смыслу действия, уникальные имена (листинг 8.24).
Листинг 8.24. Без перегрузки имен функций все функции должны иметь
уникальные имена
int MaxInt(int x, int y) //функция находит максимальное значение из двух
параметров типа int
{ return (x>y) ? x : y; }
double MaxDouble(double x, double y) //тоже находит максимум, только
принимает параметры другого типа, а это означает,
что компилятор должен сгенерировать совершенно
разные низкоуровневые инструкции при действиях
с этими значениями (несмотря на то, что текст
на языке высокого уровня выглядит одинаково)
{ return (x>y) ? x : y; }
int main()
{
int i = MaxInt( 12, 8 );
double d = MaxDouble( 32.9, 17.4 );
}
Пример 2.
В языке С++ программист может давать разным функциям одно и то же имя.
В зависимости от количества и/или типа аргументов компилятор сам сгене-
рирует вызов нужной функции (листинг 8.25).
Листинг 8.25. Перегрузка имен функций
int Max(int x, int y)
{ return (x>y) ? x : y; }
double Max(double x, double y)
{ return (x>y) ? x : y; }
//Следующая функция по смыслу тоже претендует на имя Max:
int Max(int ar[], int n) //функция находит максимальный из элементов
массива
{
Функции 297
int max = ar[0];
for(int i=1; i<n; i++)
{
if(ar[i]>max) max=ar[i];
}
return max;
}
int main()
{
int m = Max( 12, 8 ); //вызов Max(int, int)
double d = Max( 32.9, 17.4 ); //вызов Max(double, double)
//double dd = Max( 1.1 , 2 ); //ошибка: компилятор считает, что
не может найти однозначного
соответствия
int array[] = {5,-3,0,10,2};
m = Max(array, sizeof(array)/sizeof(array[0]) );
//вызов Max(int [], int)
}
При перегрузке имен функций действуют следующие ограничения:
􀂈 не могут перегружаться функции, имеющие совпадающие тип и число ар-
гументов, но разные типы возвращаемых значений. Например:
void f(int);
double f(int);
int main()
{
f(5); //компилятор не понимает, какую функцию хочет вызвать
программист, т. к. возвращаемое значение принимать
необязательно (см. разд. 8.3.1)
}
􀂈 не могут перегружаться функции, имеющие неявно совпадающие типы
аргументов, т. к. компилятор при синтаксическом анализе не сможет разо-
браться по указанному параметру, какую вызывать. Например:
void f(int);
void f(int&);
int main()
{
int n=5;
298 Глава 8
f(n); //компилятор не понимает, какую функцию хочет вызвать
программист, т. к. использование ссылки в качестве
параметра синтаксически выглядит так же, как передача
параметра по значению (см. разд. 8.2.2)
}
Механизм перегрузки основывается на относительно сложном наборе правил
для неявного преобразования типов аргументов, поэтому в некоторых случа-
ях (даже если компилятор не выдает ошибки) на первый взгляд неочевидно,
какая из функций будет вызвана. Если есть сомнения, то чтобы избежать
ошибок при компиляции или неприятностей при неявном преобразовании
типов аргументов, пользуйтесь явным преобразованием для точного соответ-
ствия типов параметров:
double dd = Max( 1.1 , static_cast<double>(2) );
//вызов Max(double, double)
8.5.1. Возможные конфликты при использовании
параметров по умолчанию
При перегрузке имен функций и одновременном использовании значений
параметров по умолчанию может возникнуть неоднозначная ситуация (лис-
тинг 8.26).
Листинг 8.26. Пример появления неоднозначности при использовании пара-
метров по умолчанию
void f(int x, int y=0);
void f(int);
int main()
{
а(1, 2); //OK – компилятор однозначно понимает, что нужно
вызвать функцию f, которая принимает два параметра
f(5); //ошибка: компилятор не может определить, какую
из функций следует вызвать
}
8.6. Рекурсивные функции
Рекурсивные функции — это функции, вызывающие сами себя. Рекурсивные
вычисления выполняются повторным выполнением одного и того же кода
с разными наборами данных. Каждое выполнение тела функции имеет свою
область стека (стековый кадр stack frame) для параметров и локальных пере-
Функции 299
менных. Поэтому каждое вхождение в функцию можно рассматривать как
абсолютно не зависящее от других вхождений.
Достоинством рекурсивных функций является возможность создания ком-
пактного кода (особенно при использовании сложных типов данных).
Недостатками рекурсивных вычислений являются: затраты времени на вызов
функции и передачу ей копий параметров, а также затраты памяти (стека) для
организации каждого вложенного вызова.
ВА Ж Н О!
Рекурсия возможна, т. к. каждый вызов работает со своей копией данных!
Специфика рекурсивных функций:
􀂈 программист должен обеспечить внутри рекурсивной функции не только
анализ, но и обязательное выполнение условия, при котором произойдет
выход из рекурсии (иначе случится бесконечная рекурсия, т. е. зависание
программы);
􀂈 по мере возможности следует избегать использования в рекурсивной
функции локальных переменных, т. к. это увеличивает размер стекового
кадра для каждого вложенного вызова.
Без рекурсии в большинстве случаев можно обойтись.
Пример — вычисление факториала без использования рекурсии:
{
int n=5;
int res=1;
for(int i=n;i>1;i--) res*=i;
}
В листинге 8.27 приведен классический пример использования рекурсии для
вычисления факториала. Хотя код выполняется один и тот же, но каждый
вложенный вызов использует свою область стека (рис. 8.14).
Листинг 8.27. Использование рекурсии при вычислении факториала
//Вариант 1. Используется вспомогательная локальная переменная x
int F(int n)
{
if(n<=1)return 1; //обеспечили выход из рекурсии
else
{
int x = F(n-1); //рекурсивный вызов функции
с параметром (n-1)
300 Глава 8
return n*x;
}
}
int main()
{
int n=5;
int res = F(n);
}
//Вариант 2. на рис. 8.14 очевидно, что при каждом вызове функции
компилятор должен отвести в стековом кадре память под
локальную переменную x. Это как раз тот случай, когда
без этой локальной переменной можно обойтись
int F(int n)
{
if(n<=1)return 1; //обеспечили выход из рекурсии
else
{
return n * F(n-1);
}
}
Рис. 8.14
Функции 301
ЗАМЕ ЧАНИЕ
Несмотря на большие затраты, преимущество использования рекурсивных
функций начинает сказываться при работе со сложными структурами данных —
деревьями, стеками. Есть мнение, что рекурсия — это краеугольный камень
сложных алгоритмов.
8.7. Указатель на функцию
Сочетая основные типы данных в языке С/С++, можно образовать неограни-
ченное число более сложных производных типов. В частности, одним из та-
ких производных типов является указатель на функцию. Указатели на функ-
ции можно использовать как аргументы при вызове других функций, хранить
в массиве и находить им применение другим способом.
8.7.1. Определение указателя на функцию
Тип указателя на функцию зависит от количества и типа параметров, а также
от типа возвращаемого значения. Пусть требуется определить указатель на
функцию, которая принимает один параметр типа double и возвращает значе-
ние типа int. На рис. 8.15 приведено определение переменной с именем Func,
которая является указателем требуемого типа. Компилятор, встречая такое
определение, выделяет память для переменной-указателя и по общим прави-
лам может такую переменную неявно проинициализировать нулем в зависи-
мости от контекста определения.
Рис. 8.15
ЗАМЕ ЧАНИЕ
Скобки вокруг (*Func) обязательны, поскольку объявление int *Func(double);
означает прототип функции, возвращающей указатель int*.
302 Глава 8
Если функция принимает несколько параметров, то их типы указываются
в скобках через запятую так же, как при объявлении функции:
char* (*pf)(char*, int); //указатель на функцию, которая принимает два
параметра (указатель char* и целое)
и возвращает указатель char*
8.7.2. Инициализация указателя на функцию
Пусть в программе определено несколько функций, прототипы которых выгля-
дят одинаково. Требуется определить указатель на функцию такого вида и на-
править указатель на одну из реально существующих функций (листинг 8.28).
Листинг 8.28. Инициализация указателя на функцию
int RealFunc(void);
int OtherFunc(void);
int main()
{
...
int (*pf1)(void)= &RealFunc; //определение и инициализация.
Компилятор заносит в переменную-указатель
адрес начала функции
//Так как в языке Си имя функции эквивалентно указателю, то можно и так:
int (*pf2)(void)= RealFunc; //выражения эквивалентны
//А теперь ничто не мешает перенаправить указатель на
другую подходящую функцию:
pf1 = OtherFunc; //компилятор занесет в ту же переменную
другой адрес
}
8.7.3. Вызов функции посредством указателя
Пусть в программе используется функция, прототип которой:
int f(const char*, double);
Определим указатель подходящего типа и вызовем посредством этого указа-
теля функцию f(). Вызвать функцию посредством указателя можно двумя
способами:
􀂈 синтаксически любой указатель можно разыменовать. Формально разы-
менованный указатель на функцию является синонимом имени функции.
Функции 303
Последовательность, в которой компилятор разбирает выражение, пред-
ставлена на рис. 8.16.
{
int (*pf)(const char*, double) = &f;
int res = (*pf)( "ABC", 1.1);
}
􀂈 вспомнив о том, что в C/C++ имя функции эквивалентно указателю, можно
написать и так:
pf("ABC", 1.1);
Рис. 8.16
8.7.4. Использование указателей на функции
в качестве параметров
Этот прием довольно часто используется как стандартной библиотекой, так
и системными функциями Windows для передачи библиотечной функции
указателя на вашу пользовательскую функцию. Таким образом, библиотечная
функция посредством полученного указателя может выполнять специфиче-
ские для вашей программы действия. Например, функция стандартной биб-
лиотеки qsort() способна сортировать массивы элементов любого типа, т. к.
в качестве одного из параметров она принимает указатель на пользователь-
скую функцию, в которой программист объясняет, каким образом следует
сравнивать два элемента своего массива, а qsort() в соответствующие мо-
менты просто вызывает по указателю пользовательскую функцию:
//Прототип библиотечной функции qsort() находится в заголовочном
файле <cstdlib>
void qsort(
void *base, //указатель на начало массива
size_t num, //количество элементов в массиве
304 Глава 8
size_t width, //размер элемента массива в байтах
int (__cdecl *compare )(const void *, const void *) //пользовательская
функция сравнения двух элементов массива
);
Пример использования библиотечной функции qsort() для сортировки объ-
ектов любого типа представлен в листинге 8.29.
Листинг 8.29. Пример использования библиотечной функции qsort()
#include <cstdlib> //прототип функции qsort()
#include <cstring> //прототип функции strcmp()
//функции сравнения, предоставляемые программистом, должны принимать
два const void * указателя и возвращать значение:
>0 — если *p1>*p2,
=0 — если *p1=*p2,
<0 — если *p1<*p2
//функция сравнения двух значений типа int предназначена для сортировки
по возрастанию значений
int cmp_int_accended(const void* p1, const void* p2)
{
const int* ptmp1 = static_cast<const int*>(p1); //программист знает,
что функция на самом деле принимает
два адреса типа int*, поэтому приводим
тип void*-указателя к требуемому типу
const int* ptmp2 = static_cast<const int*>(p2);
return (*ptmp1 - *ptmp2);
}
//функция сравнения двух значений типа int предназначена для сортировки
по убыванию значений
int cmp_int_descended(const void* p1, const void* p2)
{
const int* ptmp1 = static_cast<const int*>(p1);
const int* ptmp2 = static_cast<const int*>(p2);
return (*ptmp2 - *ptmp1);
}
//функция сравнения двух значений типа char* предназначена для сортировки
строк по возрастанию в лексиграфическом порядке
int cmp_str(const void* p1, const void* p2)
Функции 305
{
const char** ptmp1 = static_cast<const char**>(const_cast<void*>(p1));
//в этом случае преобразование хитрее, т. к. привести
непосредственно const void*-указатель к const char**
компилятор не позволит, поэтому сначала нужно снять
константность с void*-указателя
const char** ptmp2 = static_cast<const char**>(const_cast<void*>(p2));
return strcmp(*ptmp1,*ptmp2); //теперь строки можно лексиграфически
сравнивать с помощью функции стандартной
библиотеки – strcmp()
}
int main()
{
int arn[] = {5, -6, 10, 0, -1};
//сортируем массив по возрастанию
qsort(arn,sizeof(arn)/sizeof(int),sizeof(int), cmp_int_accended);
//теперь тот же самый массив по убыванию
qsort(arn,sizeof(arn)/sizeof(int),sizeof(int), cmp_int_descended);
//а теперь массив указателей на строки в лексиграфическом порядке по
возрастанию
const char* arstr[] = {"ten", "green", "bottles", "hanging", "on",
"the", "wall"};
qsort(arstr,sizeof(arstr)/sizeof(char*),sizeof(char*), cmp_str);
//в результате указатели на строки будут располагаться в массиве в
следующем порядке: "bottles", "green", "hanging", "on", "ten", "the",
"wall"
}
ЗАМЕ ЧАНИЕ
Использование указателей на функции в качестве параметров не является
прерогативой библиотечных функций. Программист может применять этот при-
ем при разработке собственных универсальных функций.
8.7.5. Использование указателя на функцию
в качестве возвращаемого значения
Этот прием также часто используется библиотечными функциями (например, при
подмене библиотечных обработчиков аварийных ситуаций — _set_new_hadler()).
Приведем более простой пример (листинг 8.30). Пусть в зависимости от об-
стоятельств нужно вызывать с одним и тем же параметром одну из функций
306 Глава 8
cos(), sin() и т. д. Причем выяснение того, какую функцию следует вызвать,
находится в одной функции — f(), а вызов должен быть в другой функ-
ции — main().
Листинг 8.30. Пример использования указателя на функцию в качестве
возвращаемого значения
#include <cmath> //прототипы всех тригонометрических функций.
Все тригонометрические функции типа sin(), cos()
принимают один параметр типа double и возвращают
значение типа double
double (* f(void)) (double) //f — это функция, которая не принимает
параметров, а возвращает указатель на
функцию, принимающую параметр типа double
и возвращающую значение типа double
{
if(условие) return sin;
else return cos;
}
int main()
{
double (*pf)(double) = f(); //объявили подходящий указатель
и проинициализировали его
возвращаемым функцией значением:
это может быть адрес функции sin()
или адрес функции cos()
double res = pf(.9); //а теперь вызвали посредством указателя
одну из функций
}
8.7.6. Массивы указателей на функции
Совокупность указателей на функции одного вида можно объединить и хра-
нить (например, в массиве). Используем для примера тригонометрические
функции стандартной библиотеки sin(), cos(), tan() и т. д. Прототипы таких
функций по своей структуре выглядят одинаково, поэтому указатели на них
можно сгруппировать в массиве. Пример приведен в листинге 8.31, сложное
объявление поясняется рис. 8.17.
Функции 307
Рис. 8.17
Листинг 8.31. Использование массива указателей на функции
#include <cmath> //прототипы тригонометрических функций
#include <cstdio> //прототипы функций printf() и scanf()
int main()
{
double (*FuncAr[])(double) = {sin, cos, tan}; //FuncAr — это
массив указателей на функции (рис. 8.17),
которые принимают double и возвращают double.
По общим правилам при использовании списка
инициализаторов, размерность массива можно
оставить открытой, компилятор сам подсчитает,
сколько нужно зарезервировать памяти
int n; //в этой переменной пользователь сформирует свой выбор:
какую из функций он хочет вызвать
double res=0; //здесь получим результат выбранной пользователем
операции
printf("sin (0), cos (1), tan (2)\n"); //выводим пользователю
приглашение
scanf("%d", &n); //принимаем пользовательский ввод
if( (n>=0) && (n<sizeof(ar)/sizeof(double (*)(double)) ) ) //а
если пользователь несмотря на подсказку ввел что-нибудь
другое, ставим защиту
{
res=FuncAr[n](0.5); //вызов требуемой функции
308 Глава 8
//или так:
// res=(* FuncAr [n])(0.5);
}
…
}
8.8. Ключевое слово typedef
и сложные указатели
Как вы уже могли заметить, далеко не сразу можно догадаться, каким обра-
зом следует объявлять сложные указатели. В таких ситуациях программисту
достаточно вспомнить про ключевое слово typedef (см. разд. 3.5.1) и ввести
полезный псевдоним типа.
8.8.1. Ключевое слово typedef и указатели
на функции
Введем псевдоним типа для указателя на функцию, которая принимает double
и возвращает double:
typedef double (*PF)(double); //с этого момента PF является псевдонимом
типа для указателя на функцию требуемого вида
Теперь объявление и использование указателей такого типа выглядит проще
и привычнее:
PF f[] = { sin, cos, tan }; //PF – тип элемента массива
8.8.2. Функции, возвращающие сложные указатели
В зависимости от типа возвращаемого значения такие функции подразделя-
ются на два вида:
􀂈 функции, у которых возвращаемое значение является указателем на массив;
􀂈 функции, у которых возвращаемое значение является указателем на функцию.
Возвращаемое значение является указателем на массив
Если внутри функции создается одномерный массив, то тип возвращаемого
значения указать просто:
int* f()
{
static int ar[10]; //хотя область видимости у такого массива
Функции 309
локальная, время жизни — статическое, поэтому
возвращать адрес такого массива можно
(см. разд. 8.3.2)
…
return ar;
}
Гораздо сложнее выглядит объявление функции, которая возвращает указа-
тель на многомерный массив (листинг 8.32). Пояснение к такому сложному
объявлению дано на рис. 8.18.
Листинг 8.32. Функция, возвращающая указатель на многомерный массив
int (* f(void))[20]
{
static int ar[10][20];
…
return ar;
}
int main()
{
int (* p)[20] = f();
p[1][1] = 1; //помня о связи массивов и указателей, пользоваться
возвращенным значением можно точно так же, как
именем двухмерного массива
}
Рис. 8.18
310 Глава 8
Поскольку возвращаемое значение имеет достаточно сложный для интерпре-
тации тип, то можно ввести псевдоним, который сделает объявление проще
для понимания (листинг 8.33).
Листинг 8.33. Использование псевдонима для указателя на многомерный массив
typedef int (*PAR)[20]; //PAR – это псевдоним указателя на одномерный
массив из 20 элементов типа int
PAR f() //используем псевдоним в качестве типа возвращаемого значения
{
static int ar[10][20];
return ar;
}
int main()
{
PAR p = f(); //используем псевдоним для объявления переменной для
приема возвращаемого значения
p[1][1] = 1;
…
}
Возвращаемое значение является указателем на функцию
Встречаются задачи, в которых требуется в качестве возвращаемого значения
сформировать указатель на функцию (листинг 8.34).
Листинг 8.34. Функция, возвращающая указатель на другую функцию
int f1() //это функция, указатель на которую требуется вернуть
{
return 1;
}
int (*f2(int))() //функция f2 принимает параметр типа int и возвращает
указатель на функцию, которая не принимает
параметров, а возвращает int
{
return f1;
}
int main()
Функции 311
{
int (*pf)() = f2(5);
int res = (*pf)(); //теперь можем вызвать функцию f1 посредством
указателя pf
}
Перепишем пример, используя псевдоним типа указатель на функцию (лис-
тинг 8.35).
Листинг 8.35. Использование typedef для указателя на функцию
int f1()
{
return 1;
}
typedef int (*PF)(void); //PF – псевдоним типа указатель на функцию,
которая не принимает параметров и
возвращает int
PF f2(int) //используем псевдоним для типа возвращаемого значения
{
return f1;
}
int main()
{
PF pf = f2(5); //используем псевдоним для объявления переменной,
которая принимает возвращаемое значение
int res = (*pf)();
}
Глава 9
Структуры
В этой главе речь пойдет в основном о структурах языка Си, так как структу-
ры языка С++ не имеют принципиальных отличий от классов, а рассмотрение
классов выходит за рамки данной книги. Классы —это одно из основных по-
нятий объектно-ориентированного программирования.
9.1. Зачем нужны структуры
В некоторых задачах удобно оперировать совокупностью переменных как
одним программным объектом. Например, мы разрабатываем программу,
которая содержит информацию о группе людей. О каждом человеке требует-
ся хранить следующие данные: имя, пол, год рождения, рост, вес и т. д. Если
бы такого понятия, как структуры, не было, то решение задачи выглядело бы
примерно так, как показано в листинге 9.1.
Листинг 9.1. Без использования структур
{
enum SEX{MALE, FEMALE}; //пол может быть мужским или женским,
поэтому удобно для обозначения пола
ввести перечисление
//Для формирования информации о каждом человеке требуется определить
набор переменных
//Для Васи:
char name1[30] = "Вася";
enum SEX sex1 = MALE; //использование ключевого слова enum при
определении переменной перечислимого типа
обязательно в языке Си,
314 Глава 9
в С++ его можно опустить
int age1 = 30;
…
//Для Мани:
char name100[30] = "Маня";
enum SEX sex100 = FEMALE;
int age100 = 2;
}
А если таких наборов данных много? Программист должен все время пом-
нить, какие данные относятся к одному и тому же конкретному человеку, по-
этому логично отдельные характеристики, относящиеся к одному объекту,
объединить в составном элементе данных так, чтобы:
􀂈 хранить совокупность характеристик как единое целое;
􀂈 манипулировать этой совокупностью как единым целым;
􀂈 иметь возможность обращаться к характеристикам по отдельности.
Структуры языка Си как раз и предоставляют программисту возможность
формирования таких новых составных (агрегатных — aggregate) типов дан-
ных, которые строятся на базе уже существующих (определенных ранее) ти-
пов. Структура может включать в свой состав произвольное количество типов
данных, которые в дальнейшем будем называть полями структуры. В качестве
поля можно использовать любой из ранее определенных типов данных, как
базовых, так и более сложных: указатели, строки, массивы, другие структуры.
Разные типы структур могут различаться:
􀂈 количеством полей;
􀂈 их типами;
􀂈 порядком расположения полей в структуре.
ЗАМЕ ЧАНИЕ
Структуры языка Си — это удобное средство для укрупнения (агрегации) дан-
ных (ничего более!), в то время, как структуры языка С++ обладают гораздо
большими возможностями.
9.2. Объявление структуры
Компилятор сам знает без дополнительных указаний программиста, как об-
ращаться с переменными базового типа. Программисту нужно лишь объявить
переменную требуемого (базового) типа. Однако только программист знает,
Структуры 315
сколько и каких полей должен содержать агрегатный пользовательский тип.
Поэтому программист должен описать компилятору свойства своего нового
пользовательского типа данных, т. е. объявить структуру.
Объявление структуры — это описание внутреннего устройства нового агре-
гатного типа данных (количества, типа и порядка расположения полей), ис-
ходя из которого, компилятор будет создавать экземпляры пользовательского
типа и манипулировать ими.
НА П О МИ Н А Н И Е 1
При объявлении структуры, равно как и любого другого программного объекта,
никакой памяти не резервируется! Это только описание, исходя из которого,
компилятор будет резервировать память при создании каждого экземпляра пе-
ременной структурного типа.
НА П О МИ Н А Н И Е 2
Обычно объявления помещают в заголовочный файл (рис. 9.1).
Рис. 9.1
Синтаксис объявления структуры:
struct имя_пользовательского_типа{//ключевое слово struct означает, что
вводится новый пользовательский
агрегатный тип данных с указанным
именем
список_полей_структуры (типы и имена переменных, которые будут
присутствовать в каждом создаваемом
экземпляре такой структуры)
}; //после закрывающей фигурной скобки точка с запятой обязательна!
316 Глава 9
Пример.
Спроектируем структуру human для описания свойств любого человека (эту
стуктуру будем использовать в последующих примерах). Поместим ее объяв-
ление в заголовочный файл human.h, здесь же зададим перечисление для
обозначения пола:
//файл human.h
enum SEX {MALE, FEMALE};
struct human{//ввели свой пользовательский агрегатный тип human,
в котором сгруппировали все нужные поля данных
enum SEX sex; //в С++ ключевое слово enum можно опустить
int age;
char name[30];
…
};
9.3. Создание экземпляров структуры
и присваивание значений полям структуры
Создание объекта пользовательского типа выглядит так же, как создание пе-
ременной базового типа (листинг 9.2). Компилятор резервирует для перемен-
ной типа human sizeof(human) байтов:
Листинг 9.2. Создание экземпляров структуры
#include "human.h"
int main()
{
//Создание переменной пользовательского типа:
//В языке ANSI Си
struct human man1; //тип переменной - struct human,
имя переменной - man1. Ключевое
слово struct обязательно в языке Си,
но не обязательно в С++, где достаточно
написать так:
//В С++
human woman1; //тип переменной - human, имя переменной - woman1,
а о том, что human – это структура, компилятор
помнит сам
}
Структуры 317
ЗАМЕ ЧАНИЕ
Компилятор размещает и неявно инициализирует такие переменные по общим
правилам (так же, как переменные базовых типов, см. разд. 3.7 и 3.9.2). В зави-
симости от контекста определения такие переменные могут быть: глобальны-
ми, заключенными в пространства имен, статическими или динамическими. Для
глобальных структурных переменных, переменных в пространстве имен и ста-
тических переменных компилятор неявно инициализирует все поля нулями.
Поля локальных и динамических переменных не инициализируются.
Если в распоряжении программиста есть переменная структурного типа или
ссылка (только в С++) на такую переменную, то обратиться к полю структу-
ры программист может посредством селектора поля структуры (. — точка).
Синтаксически обращение выглядит следующим образом:
имя_переменной.имя_поля
или
имя_ссылки_на_переменную.имя_поля
Пример обращения к полям структурной переменной приведен в листинге 9.3.
Листинг 9.3. Присваивание значений полям структуры посредством имени
переменной или ссылки и селектора поля структуры (.)
#include "human.h"
int main()
{
struct human man1;
man1.sex = MALE; //встречая такое выражение, компилятор вычисляет
адрес (куда нужно занести значение MALE) следующим образом:
&man1+смещение_поля_sex_относительно_начала_экземпляра
в нашем случае (&man1 + 0байт)
man1.age = 30; //(&man1 + 4байта)
//В С++ можно определить ссылку на структуру, при этом ключевое слово
struct можно опустить, т. к. в С++ оно необязательно
human& rman1 = man1; //ссылка rman1 является псевдонимом
структурной переменной man1
rman1.age++; //man1 "повзрослел" на год
//Но!
//man1.name = "Вася"; //ошибка, т. к. name – это имя массива
(см. разд. 6.3.1)
strcpy(man1.name, "Вася"); //т. к. поле name – это массив,
содержащий строку, требуемое значение
318 Глава 9
проще скопировать с помощью функции
strcpy() стандартной библиотеки
…
//Можно для описания группы людей создать массив структур:
struct human people[10]; //определен массив из 10 элементов
типа human. Так как массив локальный,
то его поля компилятором не
инициализируются
//Предоставим пользователю возможность ввести значения:
for(int i=0; i < sizeof(people)/sizeof(human); i++)
{
printf("Name=");
scanf("%29s",people[i].name); //ограничили количество
принимаемых символов размером массива
fflush(stdin); //если пользователь ввел строку длиннее, чем
размер массива, нужно очистить буфер ввода
printf("Input sex: male (0), female (1)");
scanf("%d", &people[i].sex);
printf("age=");
scanf("%d", &people[i].age);
}
}
9.4. Ключевое слово typedef и структуры
Если вы программируете на языке Си, то при любом использовании имени
типа human, должны уточнять компилятору тип с помощью ключевого слова
struct (т. е. везде должны писать struct human). Для того чтобы можно было
при использовании структуры в языке Си опускать ключевое слово struct,
вводят псевдонимы посредством ключевого слова typedef (см. разд. 3.5.1).
Например:
typedef struct { //имя пользовательского типа опущено
SEX sex;
int age;
char name[30];
…
} human; //анонимной структуре с перечисленными полями
сопоставляется псевдоним human
Структуры 319
Теперь при программировании на Си можно везде, где требуется struct
имя_пользовательского_типа, использовать псевдоним, а компилятор под
псевдонимом будет подразумевать структуру с перечисленными полями,
например:
human man;
ЗАМЕ ЧАНИЕ 1
Если вам придется программировать на уровне Win32 API, то увидите, что вве-
дение псевдонимов — это прием, который часто используется разработчиками
для структур Windows.
ЗАМЕ ЧАНИЕ 2
В С++ ключевое слово struct при использовании структур необязательно, по-
этому и применение typedef для обозначения псевдонима пользовательского типа
тоже неактуально.
9.5. Совмещение объявления и определения.
Анонимные структуры
Иногда для локального использования совмещают объявление структуры
и создание переменных структурного типа. Например:
// Файл 1.cpp
struct human{ //ввели свой пользовательский агрегатный тип human
SEX sex;
int age;
char name[30];
…
} man1, woman1, *phuman, people[10]; //создали две переменных типа
human - man1, woman1,
указатель типа human* - phuman
и массив из 10 элементов
типа human – people
Синтаксис языка Си позволяет объявить структуру, не указывая имени типа.
При этом очевидно, что в дальнейшем использовать такую структуру невоз-
можно. Поэтому целесообразность имеет место лишь в том случае, если
такая структура нужна единожды для создания нескольких экземпляров,
а в дальнейшем имя типа больше не потребуется (листинг 9.4).
320 Глава 9
Листинг 9.4. Использование анонимных структур
int main()
{
//Создание переменных структурного типа:
struct { //имя пользовательского типа опущено
SEX sex;
int age;
char name[30];
…
} man1, woman1, *phuman, people[10];
//Использование переменных man1, woman1, phuman, people
}
ЗАМЕ ЧАНИЕ
Злоупотреблять таким способом создания переменных вряд ли стоит, т. к. это
нарушает принципы структурного подхода (хотя синтаксически допустимо).
9.6. Инициализация
структурных переменных
При определении структуры, ее поля можно проинициализировать явно, как
и при определении переменной базового типа. Инициализация структур по-
хожа на инициализацию массивов. Инициализаторы в фигурных скобках ука-
зываются в том же порядке, в котором в структуре объявлены соответствую-
щие поля:
struct human man1 = {MALE, 30, ”Вася”}; //определена структурная
переменная с именем man1 и ее
поля проинициализированы при
создании указанными значениями
Инициализация массивов структур похожа на инициализацию многомерных
массивов:
struct human people[100] = {
{MALE, 30, ”Вася”},
{FEMALE, 20, ”Маша”},
…
};
Структуры 321
Для структур справедливы правила неполной инициализации (так же, как
и для массивов):
struct human man2 = {MALE}; //все остальные поля компилятор
проинициализирует нулевыми значениями
struct human man3 = {0}; //компилятор обнулит все поля структуры
Так же, как и для массивов, проинициализировать поля структуры можно
только при создании, поэтому попытка использовать список инициализато-
ров для уже существующей структурной переменной вызовет ошибку. На-
пример:
man2 = {MALE, 30, "Вася"}; //ошибка: список инициализации можно
использовать только при определении
9.7. Действия со структурами
Компилятор умеет создавать копии существующих структурных переменных
(это определение, совмещенное с инициализацией) и копировать поля одного
(уже существующего экземпляра структуры) в поля другого (тоже уже суще-
ствующего) экземпляра структуры того же типа (это присваивание). Дейст-
вия компилятора при выполнении этих двух операций в языке Си отличаются
только тем, что при инициализации компилятор выделяет память под новый
объект. В С++ это две принципиально разные операции.
Например:
{
struct human man1 = {"Вася", MALE, 30};
struct human man2 = man1; //создание нового объекта и инициализация.
Компилятор выделяет память для man2 и
копирует значения всех полей экземпляра
man1 в соответствующие поля экземпляра
man2. Таким образом, man2 становится
копией man1
man1 = man2; //присваивание: значения полей одного существующего
экземпляра заменяются значениями полей другого
существующего
}
ЗАМЕ ЧАНИЕ
В обоих случаях компилятор переписывает содержимое одной структурной пе-
ременной в другую очень эффективно — как копирование последовательности
байтов (без разделения на поля). Для структур С++ и классов механизм копи-
рования информации гораздо сложнее.
322 Глава 9
9.8. Поля структуры пользовательского типа
Поле структуры может быть:
􀂈 базового типа — int age;
􀂈 указателем на базовый тип — int* p;
􀂈 массивом элементов базового типа — char name[30];
􀂈 пользовательского типа.
Пример приведен в листинге 9.5.
Листинг 9.5. Поля структуры пользовательского типа
//Файл point.h
#if !defined _POINT //защита от вложенных подключений point.h
(см. разд. 5.6.6)
#define _POINT
struct Point{ //в этой структуре поля базового типа
int x, y; //координаты точки
};
#endif
//Файл line.h
#include "point.h"
struct Line{ //отрезок линии, который задается двумя точками
struct Point point1, point2; //а в этой структуре тип полей задан
программистом
};
//Файл main.cpp
#include "point.h"
#include "line.h"
int main()
{
struct Point a = {1,1}, b = {5,5}, с = {-1,-2};
//Инициализировать переменные типа Line можно следующими
способами:
struct Line l1 = {a,b};
struct Line l2 = {-1,-2,2,3};
Структуры 323
struct Line l3={0};
//Обращаться к полям можно:
l3.point1 = c;
l3.point1.x = 1;
}
9.9. Вложенные (nested) структуры
Объявление структуры может включать в свой состав объявления других
вспомогательных пользовательских типов. Пример приведен в листинге 9.6.
Листинг 9.6. Вложенные объявления в структурах
//Файл line.h
struct Line
{
struct Point //вложенное объявление
{
int x, y;
} point1, point2; //объявление полей структуры Line типа Point
};
В С++ область видимости всех объявлений внутри структуры ограничена,
в то время как в языке Си таких ограничений нет. В С++ все поля структуры
как бы заключены в пространство имен с именем структуры. Для обращения
к таким вложенным объявлениям требуется указание типа структуры и опера-
тора разрешения области видимости — в нашем случае — Line: (листинг 9.7).
Листинг 9.7. Спецификатор разрешения области видимости применительно
к структурам С++
//Файл main.cpp
#include "line.h"
int main()
{
//В языке Си:
struct Point a; //OK
//В языке С++:
//Point a; //ошибка: компилятор не знает, что такое Point
324 Глава 9
Line::Point b = {1,2}; //теперь создавать переменные типа
Point можно только посредством указания
типа структуры и оператора разрешения
области видимости – Line::
}
Вспомогательные вложенные структуры можно сделать анонимными (лис-
тинг 9.8).
Листинг 9.8. Анонимные вложенные структуры
//Файл line.h
struct Line
{
struct //объявление анонимной структуры
{
int x, y;
} point1, point2; //объявление полей
};
//Теперь можно обращаться к полям point1 и point2 следующим образом:
int main()
{
struct Line l = {1,2,3,4};
l.point1.x = -1;
}
9.10. Указатели и структуры
Иногда бывает удобно (а иногда это просто необходимо) манипулировать
структурной переменной посредством указателя. В основном необходимость
в указателе возникает в тех случаях, когда адрес структурной переменной
передается в функцию в виде указателя или память под такую перемен-
ную/массив выделяется динамически. Для обращения к полям структуры по-
средством указателя используется селектор -> (стрелка вправо). Пример
приведен в листинге 9.9.
Листинг 9.9. Обращение к полям структуры посредством указателя
#include <malloc.h> //прототипы функций malloc и free
#include "human.h"
int main()
Структуры 325
{
//Создание одиночной динамической структурной переменной
//В языке Си
struct human* pman = (struct human*) malloc(sizeof(struct human));
//В языке С++
human* pman1 = new human;
pman->sex = MALE; //обращение к полю структуры посредством
указателя
pman->age = 30;
strcpy(pman->name, "Вася");
…
//Попользовавшись динамическим объектом, не забудьте
освободить память:
//В языке Си
free(pman);
//В языке С++
delete pman1;
//Создание динамического массива:
int n = … //вычисление размерности массива
//В языке Си
struct human* people = (struct human*) malloc(n*sizeof(struct human));
//В языке С++
human* people1 = new human[n];
//Формирование полей элементов массива
//Вывод информации о каждом человеке:
for(int i=0; i<n; i++)
{
cout<<people1[i].name<<
" age: "<< people1[i].age<<
(" sex: "<< (people1[i].sex==MALE)? "male" : "female")<< endl;
}
…
//В языке Си
free(people);
//В языке С++
delete[] people1;
}
326 Глава 9
9.11. Упаковка полей структуры
компилятором. Оператор sizeof
применительно к структурам
При выделении памяти под структурную переменную (независимо от того,
в какой конкретно области выделяется память: в стеке, в статической области
или в куче) компилятор гарантированно делает следующее:
􀂈 выделяет количество байтов, большее или равное сумме всех полей струк-
туры;
􀂈 выделяет память для каждого поля в том порядке, в котором поля объяв-
лены в структуре.
Количество выделяемой для структурной переменной памяти и смещения
полей относительно начального адреса структуры зависят от:
􀂈 оптимизирующих возможностей конкретного компилятора;
􀂈 опций командной строки компилятору.
В общем случае трудно сделать предположение о том, сколько памяти будет
выделено под структурную переменную и с каким смещением данные будут
располагаться относительно начала структурной переменной (об этом знает
компилятор).
СЛ Е ДСТ ВИЕ
Если программист обращается к полю структуры по имени, то компилятор все-
гда вычисляет адрес корректно. Если же программист самостоятельно пытает-
ся задать смещение интересующего его поля относительно начала структуры,
то вероятность ошибки велика. Не имеет смысла выполнять работу компилятора!
Оптимизирующий компилятор (например, VC) при выделении памяти под
каждое поле структуры может минимизировать время обращения к любому
полю структуры следующим образом: он располагает данные так, чтобы лю-
бое из них можно было прочитать из памяти за минимальное количество ка-
нальных циклов. Это означает, что любой элемент данных (чтобы его не
нужно было считывать по кускам) должен быть размещен по адресу, кратно-
му длине элемента. Эти правила следует учитывать для более эффективного
использования памяти.
Например, требуется объявить в структуре с именем A поля типа char,
double, bool, int. Если программист не знает правил упаковки и объявляет
поля структуры в произвольном порядке (листинг 9.10), компилятор VC по
умолчанию запаковывает поля структуры так, как показано на рис. 9.2.
Структуры 327
Листинг 9.10. Неэффективный порядок объявления полей в структуре
//файл A.h
struct A{
char c;
double d;
bool b;
int n;
};
//файл main.cpp
#include "A.h"
int main()
{
size_t n = sizeof(A); //n=24
}
Рис. 9.2
328 Глава 9
А для того, чтобы эффективнее использовать память, достаточно было про-
сто объявить поля структуры в другом порядке с учетом опций оптимизации
компилятора VC (листинг 9.11, рис. 9.3).
Листинг 9.11. Как программист может учесть правила запаковки полей
//файл A.h
struct A{
double d;
int n;
char c;
bool b;
};
//файл main.cpp
#include "A.h"
int main()
{
size_t n = sizeof(A); //в этом случае VC: n=16
}
Рис. 9.3
Структуры 329
9.12. Cтруктуры и функции
Основным преимуществом структур является возможность манипулирования
совокупностью данных как единым целым, в частности, это проявляется при
передаче данных в функцию и при получении из функции результата.
9.12.1. Передача структуры
в функцию в качестве параметра
Большое количество параметров, передаваемых в функцию, затрудняет ее
использование. Например, требуется реализовать функцию, которая выводит
на экран сведения о человеке. Без использования структур, функция выгля-
дела бы примерно так:
void Print(const char* name, unsigned int age, SEX sex); //список
параметров можно расширить другими интересующими
нас данными о человеке
Структуры значительно упрощают передачу данных функциям, т. к. вместо
трех отдельных параметров можно в данном случае использовать только
один укрупненный — структуру human, содержащую три поля:
void Print(struct human any);
Данные, укрупненные посредством структуры, можно передавать в функцию
как по значению, так и по адресу (аналогично параметрам базового типа —
см. разд. 8.2).
Передача структуры в функцию по значению
Если структурная переменная передается по значению, то при вызове функ-
ции компилятор должен сформировать в стеке ее копию. Это вызывает до-
полнительные затраты:
􀂈 памяти (в стеке) для копии;
􀂈 времени на формирование копии.
А так как обычно посредством структур программист объединяет значитель-
ное количество полей, то передавать такие агрегатные данные по значению
неэффективно (листинг 9.12).
Листинг 9.12. Передача структуры в качестве параметра по значению
#include <stdio.h> //прототип функции printf() для языка Си
void Print(struct human h) //функция принимает параметр структурного типа
по значению
330 Глава 9
{
printf("%s age: %d sex: %s", h.name, h.age,
((h.sex==MALE)? "male" : "female"));
}
int main()
{
struct human people[10];
…//Формирование полей элементов массива
//Вывод информации о каждом человеке:
for(int i=0; i<10; i++)
{
Print(people[i]); //на каждой итерации цикла компилятор
формирует в стеке копию очередного
элемента массива. Неэффективно!
}
}
РЕ К О МЕ Н Д А Ц И Я
Передавать такие большие объекты по значению стоит только в тех случаях,
когда программист намеренно предоставляет функции копию для модификации
(чтобы изменения никак не затронули оригинал).
Передача структуры в функцию по адресу
Гораздо эффективнее передавать функции адрес структурной переменной
посредством указателя или ссылки (листинги 9.13 и 9.14). Если при этом тре-
буется защитить оригинал от модификации, то при передаче такого адреса
следует использовать ключевое слово const (см. разд. 8.4.1).
Листинг 9.13. Передача адреса структурной переменной посредством указателя
void Print(const struct human* ph) //функция принимает адрес структурной
переменной. При наличии ключевого
слова const такой адрес допустимо
использовать только для чтения
{
printf("%s age: %d sex: %s", ph->name, ph->age,
((ph->sex==MALE)? "male" : "female"));
}
int main()
{
Структуры 331
struct human people[10];
… //Формирование полей элементов массива
//Вывод информации о каждом человеке:
for(int i=0; i<n; i++)
{
Print(&people[i]); //на каждой итерации цикла компилятор
формирует в стеке в качестве
передаваемого параметра адрес
экземпляра структуры human,
являющегося очередным элементом
массива people
}
}
Листинг 9.14. Передача адреса структурной переменной посредством ссылки
(только С++)
#include <iostream>
void Print(const human& rh)
{
std::cout<< rh.name<<
" age: "<< rh.age<<
(" sex: "<< (rh.sex==MALE)? "male" : "female")<< std::endl;
}
int main()
{
human people[10];
… //Формирование полей элементов массива
//Вывод информации о каждом человеке:
for(int i=0; i<n; i++)
{
Print(people[i]); //синтаксически ссылкой пользуемся
так же, как и самим объектом, а
компилятор, исходя из объявления
функции, на каждой итерации цикла
формирует в стеке в качестве
передаваемого параметра адрес
очередного элемента массива
}
}
332 Глава 9
Передача в функцию массива структур
Передача массива структур в функцию аналогична передаче массива базово-
го типа, при этом компилятор передает в функцию адрес начала массива (см.
разд. 8.2.3). Например, реализуем функцию, которая ищет в массиве с эле-
ментами типа human человека с указанным именем (листинг 9.15).
Листинг 9.15. Передача в функцию массива структур
struct human* find(const struct human* ar, const char* p, int n)
//или const struct human ar[]
{
for(int i=0; i<n; i++)
{
if(strcmp(ar[i].name,p) return ar+i; //или return &ar[i];
}
return 0; //человека с таким именем в массиве не оказалось
}
int main()
{
struct human people[100] = {
{"Вася", MALE, 30, …},
{"Маша", FEMALE, 20, …},
…
};
struct human* p = find(people, "Вася",sizeof(people)/
sizeof(struct human));
if(p)… //такой человек в массиве есть
}
9.12.2. Возврат структуры по значению
Для того чтобы принять возвращаемое значение структурного типа, компиля-
тор формирует вызов такой функции специфическим образом (листинг 9.16).
Листинг 9.16. Возврат структуры по значению
struct human f(void) //функция, которая возвращает объект типа human
по значению
{
Структуры 333
struct human tmp; //локальная переменная (компилятор отводит для
нее память в стековом кадре текущей функции)
//формирование полей
return tmp; //для формирования возвращаемого значения компилятор
копирует поля локальной переменной по тому адресу,
который предоставила вызывающая функция
}
int main()
{
human res;
res = f(); //на первый взгляд эта функция не принимает никаких
параметров, но т. к. она возвращает объект
агрегатного типа по значению, то компилятор
формирует вызов следующим образом:
а) компилятор резервирует в стеке место для
возвращаемого значения и передает адрес
зарезервированной области в функцию (VC передает
этот адрес на регистре). Можно интерпретировать
вызов такой функции следующим образом: компилятор
вызывает функцию с невидимым параметром:
f(адрес_для_возвращаемого_значения);
б) после возврата управления компилятор копирует
поля возвращаемого значения в поля переменной res
}
9.13. Что можно использовать
в качестве поля структуры
Посредством структуры программист группирует данные разного типа. Поля
структуры могут быть предназначены как для хранения той информации, ко-
торая в конечном итоге нужна пользователю, так и для формирования слу-
жебной (вспомогательной) информации, которая позволяет программисту
группировать данные в сложные совокупности — списки, стеки, деревья и т. д.
Поля структуры могут быть следующего типа:
􀂈 переменные базового типа. Например:
struct A{int a; double d;…};
􀂈 встроенные массивы базового типа. Например:
struct A{int a[10]; char c[20];…};
334 Глава 9
􀂈 указатели базовых типов. Например:
struct A{int* a; char* c;…};
􀂈 переменные пользовательского типа (структуры и объединения). На-
пример:
struct A{…};
struct B{A a;…};
􀂈 встроенные массивы пользовательского типа. Например:
struct A{…};
struct B{A a[10];…};
􀂈 указатели другого или того же пользовательского типа (используются,
в частности, при создании сложных структур данных — списков, деревьев
и т. д). Например:
struct A{…};
struct B{A* pa; B* pB;…};
9.14. Поля битов
Для некоторых элементов данных диапазон изменения значений мал (напри-
мер, месяцев в году всего 12, дней в месяце не может быть больше 31 и т. д.).
Иногда хочется для хранения таких данных отвести памяти не больше, чем
это необходимо (для хранения месяца хватило бы 4 разряда, а для хранения
дня в месяце хватило бы 5 разрядов). Но таких коротких встроенных типов
данных в С/С++ нет (наименьшей адресуемой единицей является байт).
Пусть программа интенсивно оперирует датами, и требуется для хранения
данных отвести как можно меньше памяти. Рассмотрим, каким образом мож-
но минимизировать использование памяти.
Первый способ.
Очевидный вариант хранения даты.
Заводим для каждого из элементов данных свою переменную одного из базо-
вых типов, стараясь занять минимум памяти (листинг 9.17):
􀂈 unsigned short — для года;
􀂈 unsigned char — для месяца;
􀂈 unsigned char — для дня
􀂈 и т. д.
Структуры 335
Листинг 9.17. Использование подходящих коротких целых типов
//Файл date.h содержит объявление структуры Date и вспомогательные
объявления:
enum WEEKDAY{MONDAY, TUESDAY, …}; //для обозначения дня недели удобно
ввести перечисление
struct Date{
//год
unsigned short year; //а на самом деле диапазон изменения значений
1-3000, поэтому достаточно 12 битов
//месяц
unsigned char month; //а на самом деле диапазон изменения значений
1-12, поэтому достаточно 4 битов
//день в месяце
unsigned char day; //а на самом деле диапазон изменения значений
1-31, поэтому достаточно 5 битов
//день недели
WEEKDAY wday; //т. к. перечисление – это эквивалент int,
то компилятор выделит под такое поле sizeof(int)
байтов, а на самом деле диапазон изменения
значений 0-6, поэтому достаточно 3 бита
//признак праздник/будний день
bool isHoliday; //встроенный тип С++ bool занимает 1 байт, а в
языке Си BOOL является псевдонимом int
(см. разд. 3.4.7) и занимает sizeof(int) байтов,
а на самом деле для хранения признака
достаточно 1 бита
//и, возможно, еще какую-нибудь специфическую информацию, относящуюся
к конкретной дате
…
};
Размер экземпляра такой структуры равен суммарному размеру полей или боль-
ше (с учетом выравнивания полей структуры компилятором) (см. разд. 9.11).
Поэтому даже несмотря на то что, зная эту особенность, мы постарались рас-
положить поля оптимально, компилятор VC выделит для экземпляра такой
структуры 12 байтов, из которых только 25 битов используются для хранения
полезной информации:
size_t n = sizeof(Date); //12 байтов
336 Глава 9
Очевидными недостатками такого варианта хранения данных являются:
􀂈 неоптимальное использование памяти (при создании каждого экземпляра
компилятор резервирует неиспользуемые биты, и даже байты);
􀂈 большие затраты при копировании экземпляров такой структуры (наряду
с полезной информацией копируется также и неиспользуемый резерв).
Но у такого подхода есть также и неоспоримое достоинство — обработка
отдельных компонент даты выглядит просто с точки зрения программиста
и легко реализуется компилятором. Например:
Date d = {2007, 9, 1, SATURDAY, true};
d.year++; //компилятор модифицирует содержимое по вычисленному
адресу, используя малое количество простых действий
Поэтому если в программе используются несколько экземпляров структуры
Date, то, скорее всего, именно этим способом и стоит воспользоваться, т. к.
потери памяти будут не существенны, и ими можно пренебречь ради просто-
ты обработки.
А если таких наборов данных в программе миллионы? Тогда стоит подумать
над альтернативным решением.
Второй способ.
Для хранения каждого элемента данных выделяем ровно столько разрядов,
сколько требуется. Зная, что все наши данные помещаются в 25 разрядов,
объявляем в структуре одно поле типа int или unsigned int (рис. 9.4):
//файл date.h
struct Date{
unsigned int date; //в эту переменную запакуем те данные,
для каждого из которых в предыдущем варианте
отводилось отдельное поле, и сами распределим
в нем биты таким образом, как показано
на рис. 9.4.
};
Рис. 9.4
Структуры 337
Теперь каждый экземпляр структуры вместо 12 будет занимать 4 байта:
size_t n = sizeof(Date); //4 байта
Достоинствами этого варианта являются:
􀂈 плотная упаковка данных, в результате чего практически всегда получает-
ся выигрыш по занимаемой памяти;
􀂈 уменьшение затрат времени на манипулирование такой составной едини-
цей данных как единым целым (например, при копировании или при од-
новременной переустановке всех компонентов даты).
Но появились существенные недостатки:
􀂈 программисту нужно все время помнить, какие биты для чего им отведены
(компилятор об этом ничего не знает);
􀂈 резко усложняются действия с отдельными компонентами. Например,
требуется задать новое или модифицировать текущее значение месяца.
Это действие, очень просто реализуемое первым способом, в данном ва-
рианте требует выполнения трех шагов (листинг 9.18):
• распаковка — преобразование из упакованного формата (соответст-
вующих битов поля date) в естественный (число от 1 до 12) — иллю-
стрируется рис. 9.5;
• выполнение действия со значением месяца (с проверкой того, находит-
ся ли результат действия в том же диапазоне);
• упаковка — внедрение на свое место в поле date .
В результате получаем проигрыш по скорости, и увеличивается время вы-
полнения.
Листинг 9.18. Ручная запаковка/распаковка значений (если бы такого понятия,
как поля битов, не было)
#include "date.h"
int main()
{
Date d;
//запаковываем исходные значения (17.08.2007, пятница, не праздник)
в поле структуры посредством побитовых операторов
d.date = 2007 | //год располагается в младших разрядах,
поэтому значение никуда двигать не нужно
(8<<12) | //а значение месяца должно располагаться
с 12 по 16 бит, поэтому прежде чем
338 Глава 9
поразрядно складывать, ставим значение
на свое место
(17<<16) | //день месяца аналогично
(FRIDAY<<21); //день недели аналогично, а бит признака
останется в результате нулевым (false)
…
//Требуется увеличить номер месяца на единицу:
unsigned int m = (d.date >> 12) & 0xf; //для этого значение нужно
сначала распаковать
(рис. 9.5)
m++; //произвести действие
if(m <= 12) //проверить: находится ли новое значение в требуемом
диапазоне
{//и в этом случае запаковать новое значение обратно
d.date = (d.date & 0xffff0fff) //обнулили предыдущее
значение месяца в поле date
| m; //и внедрили на это место новое значение
}
}
Рис. 9.5
Третий способ.
Использование битовых полей.
Альтернативой приведенным способам (первому и второму) является исполь-
зование битовых полей (bitfields). Для компактной упаковки данных в памяти
(с одной стороны) и для упрощения операций с такими короткими данными
Структуры 339
(с другой), языки С/С++ предоставляют программисту особый тип данных,
который можно использовать в качестве поля структуры или класса (только!).
Особенности использования битовых полей:
􀂈 под полем имеется в виду отдельно каждая короткая переменная;
􀂈 для каждой переменной отводится не больше битов, чем заказал програм-
мист (не больше, чем минимально необходимо);
􀂈 несколько таких логически разных переменных хранятся в одной физиче-
ской переменной подходящей длины;
􀂈 компилятор за программиста, во-первых, выделяет нужное количество
битов, а во-вторых — осуществляет побитовые операции и сдвиги, извле-
кая или запаковывая значения.
Использование таких полей (листинг 9.19) делает доступ к совокупностям
битов удобным и легким для программиста. При этом очевидным преимуще-
ством является экономия памяти.
Синтаксис объявления битового поля:
целый_тип [идентификатор] : размер_поля_в_битах;
Правила:
􀂈 целый тип может быть signed или unsigned. Таким образом вы сообщаете
компилятору, как интерпретировать указанный диапазон. Знаковость
влияет только на распаковку значения;
􀂈 в качестве целого типа могут быть использованы: char, short, int или
long;
􀂈 в качестве целого типа может быть использован enum (интерпретируется
компилятором как signed int);
􀂈 в С++ в качестве целого типа может быть также использован bool;
􀂈 если идентификатор опущен, то объявляется анонимное битовое поле, ко-
торое используется для выравнивания (padding).
Листинг 9.19. Использование битовых полей в структурах
//Файл date.h
enum WEEKDAY{MONDAY, TUESDAY,…}; //посредством перечисления будем хранить
в экземпляре структуры день недели
struct Date
{
unsigned int year:12; //12 битов
340 Глава 9
unsigned int month:4; //4 бита
unsigned int day:5; //5 битов
WEEKDAY nWeekDay:4; //на первый взгляд кажется, что для представления
значения, диапазон изменения которого 0-7,
хватило бы и трех битов. Вспоминаем о том, что
enum – это эквивалент signed int. Это означает:
для того, чтобы при распаковке поля не получать
отрицательных значений, следует зарезервировать
один дополнительный бит, который всегда должен
содержать ноль
unsigned int isHoliday:1; //1 бит
};
//Файл main.cpp
#include "date.h"
int main()
{
//Во всех приведенных ниже примерах мы пользуемся битовыми полями как
обычными полями структуры, а компилятор сам осуществляет
запаковку/распаковку значений с помощью побитовых операторов и
операторов сдвига
Date d = {2007, 8, 17, FRIDAY}; //для инициализации битовых полей
можно использовать список
инициализаторов так же, как
и для обычных полей структуры
d.month = 9; //при работе с одним полем содержимое остальных полей
не модифицируется
unsigned int m = d.month;
d.nWeekDay=MONDAY;
WEEKDAY wday = d.nWeekDay;
…
}
Рассмотрим специфику использования битовых полей.
􀂈 Разные компиляторы могут запаковывать битовые поля по-разному. Ком-
пилятор VC выделяет биты в порядке объявления, начиная с младшего,
так же, как мы распределили их вручную вторым способом (см. рис. 9.4).
􀂈 Иногда для каких-либо специфических целей программист посредством
анонимного битового поля может предписать компилятору просто заре-
Структуры 341
зервировать указанное количество битов, т. е. следующее именованное
битовое поле располагать после указанного резерва (рис. 9.6). Например:
struct A{
short x:1;
short y:2;
short :1; //анонимное битовое поле - резерв
short z:3;
short :1; //анонимное битовое поле - резерв
short w:4;
};
Рис. 9.6
Рис. 9.7
􀂈 Анонимное поле нулевой длины используется для указания компилятору —
разместить следующую группу битовых полей, начиная с границы типа
(рис. 9.7). В приведенном ниже примере нулевое анонимное поле предпи-
сывает компилятору размещать следующее битовое поле z, начиная с бай-
товой границы:
struct A{
char x:1;
char y:2;
342 Глава 9
char :0; //анонимное битовое поле нулевой длины
char z:3;
char w:4;
};
􀂈 Перед запаковкой битового поля компилятор обеспечивает требуемый
диапазон путем обнуления всех разрядов, выходящих за пределы заданной
программистом разрядности (листинг 9.20).
Листинг 9.20. Ограничение разрядности поля при запаковке
struct A{
unsigned int x:3; //беззнаковое поле может принимать значения
от 0 до 7
};
int main()
{
A a;
int n=255; //это значение выходит за пределы диапазона изменения
поля (шестнадцатеричное представление - 0xff)
a.x = n; //при этом последовательность команд, которую генерирует
компилятор, состоит из трех шагов (см. разд. П1.12):
а)посредством побитовой конъюнкции обнулить все разряды
операнда-источника за пределами разрядности битового
поля – (n&7),
б)обнулить битовое поле в операнде-приемнике, –
(a.x&0xfffffff8),
в)вставить операнд-источник в операнд-приемник
посредством побитовой операции | -
a.x = (n&7) | (a.x&0xfffffff8)
//в результате присваивания поле a.x примет значение 7.
􀂈 Знаковость битового поля влияет только на процесс распаковки значения
компилятором — компилятор генерирует разные последовательности низ-
коуровневых команд (листинг 9.21).
Листинг 9.21. Распаковка битовых полей с учетом знаковости
struct A{
unsigned int x:3; //беззнаковое поле может принимать значения
от 0 до 7
Структуры 343
};
struct B{
int x:3; //знаковое поле может принимать значения от -4 до 3
};
int main()
{
A a;
B b;
int n=255; //0xff
// запаковываются знаковые и беззнаковые поля одинаково:
a.x = n; //в результате присваивания поле a.x примет значение 7
(см. предыдущий пример), в двоичном виде 111
b.x = n; //b.x=-1 (в двоичном представлении - 111).
//при распаковке знаковых и беззнаковых полей компилятор генерирует
разные низкоуровневые последовательности команд, т. к. при одном и том
же внутреннем представлении битового поля результат распаковки должен
получиться разным:
int tmp1 = a.x; //tmp1=7 (двоичное представление – 000…0111)
tmp1 = date&7;
int tmp2 = b.x; //tmp1=-1 (двоичное представление – 111…1111)
tmp2 = (date<<29)>>29;
}
􀂈 Если целый тип битовых полей отличается только знаковостью (signed
int/unsigned int), то компилятор запаковывает их подряд (рис. 9.8),
а знаковость влияет только на распаковку значений:
struct A{
signed int x:1;
unsigned int y:2;
…
};
Рис. 9.8
344 Глава 9
􀂈 Если у битовых полей целый тип разный (int, char), то компилятор начи-
нает запаковывать следующее битовое поле с границы типа (рис. 9.9).
struct A{
unsigned int x:1;
unsigned char y:2;
…
};
Рис. 9.9
􀂈 Для поля битов нельзя:
• получить адрес:
int* p = &a.x; //ошибка;
• объявить ссылку и проинициализировать ее битовым полем:
int& r = a.x; //ошибка;
• оператор sizeof с ними тоже не работает:
size_t n = sizeof(a.x); //ошибка.
Глава 10
Объединения (union)
Назначение объединений в языках Си и С++ одинаково, однако объединения
С++ (так же, как структуры С++) обладают большими возможностями по
сравнению с объединениями языка Си. В данной главе речь пойдет в основ-
ном о возможностях объединений языка Си.
10.1. Понятие объединения
Объединение (union) — это еще один агрегатный тип данных, который про-
граммист формирует из совокупности других типов — базовых или ранее
определенных пользовательских. Основные действия с объединениями (объ-
явление объединения, копирование экземпляров, передача в качестве пара-
метра в функцию и т. д.) внешне выглядят так же, как аналогичные действия
со структурами.
Например, объявление объединения выглядит следующим образом:
union B{ //ключевое слово union говорит компилятору о том, что далее
следует объявление пользовательского типа данных,
этот тип назван именем B
список_полей_объединения
};
Назначение и внутренняя реализация объединений принципиально отличает-
ся от структур. При создании экземпляра структуры все перечисленные
в объявлении поля одновременно присутствуют в памяти (компилятор под
каждое поле отводит память). В экземпляре объединения компилятор распо-
лагает все поля, начиная с одного и того же адреса. Это означает, что, обра-
щаясь к содержимому объединения посредством разных полей, можно одним
и тем же содержимым пользоваться, как данными разного типа (см. примеры
346 Глава 10
использования в разд. 10.2). На рис. 10.1 приведены два варианта организа-
ции данных — посредством структуры и посредством объединения.
Рис. 10.1
10.2. Использование объединений
Рассмотрим, в каких случаях может понадобиться такой тип данных.
Если программа работает в условиях дефицита памяти (в однокристальных
микроЭВМ с очень маленькой памятью, используемых во встраиваемых
применениях), то имеет смысл один и тот же участок памяти использовать на
разных этапах исполнения программы для хранения разных переменных
(листинг 10.1).
Листинг 10.1. Использование объединения для экономии памяти
//Файл Any.h
union Any{ //объявление объединения
char c;
Объединения (union) 347
int n;
double d;
};
//Файл main.cpp
#include <cstdio>
#include "Any.h"
int main()
{
//В языке Си
union Any x; //создали экземпляр объединения
//В С++
Any x; //ключевое слово union не обязательно
x.c = 'A';
//используем выделенную компилятором область памяти
как переменную типа char
…
//байтовая переменная больше не нужна, можно
использовать ту же область памяти для других целей,
например, теперь нужна переменная типа int
x.n = 1;
//используем ту же область памяти для переменной
типа int
…
//а теперь для переменной типа double
x.d = 2.2;
}
Объединение — это возможность интерпретировать одну и ту же область па-
мяти (т. е. ее содержимое) по-разному. Этот прием удобно использовать, на-
пример, в ситуации, когда приложение получает данные от внешнего устрой-
ства как последовательность байтов, а смысл эти данные имеют только как
четырехбайтовые целые, поэтому принимать их удобно в байтовый массив,
а обрабатывать — как четырехбайтовые целые. Такую задачу можно было бы
решить с помощью двух указателей разного типа: char* и int* (см.
разд. 6.1.9), но более удобным может быть использование объединения вида,
представленного в листинге 10.2.
348 Глава 10
Листинг 10.2. Использование объединения для интерпретации одной и той же
области памяти по-разному
//Файл CharInt.h
union CharInt{ //объявление объединения
char ar[4];
int n;
};
//Файл main.cpp
#include <cstdio>
#include "CharInt.h"
int main()
{
union CharInt x; //создали экземпляр объединения
//получаем данные с внешнего устройства как
последовательность байтов:
for(int i=0; i<4; i++)
{
x.ar[i] = <значение_очередного_байта>
}
//а используем полученные данные как int:
printf("value= %d", x.n);
}
Объединения используют для унификации обмена данными разного типа
между функциями или приложениями. В этом случае обычно "заворачивают"
объединение, которое может содержать данное любого из перечисленных
при объявлении типов, в структуру (листинг 10.3).
Листинг 10.3. Использование объединения для унификации передачи данных
разного типа в функцию
//Файл uni.h содержит объявление унифицированной структуры
и вспомогательные объявления:
enum WHAT{CHAR, INT, DOUBLE}; //с помощью перечисления будем задавать
тип, передаваемого посредством
объединения данного
struct Uni{
WHAT what;
union { //имя можно опустить, т. к. в других местах программы
Объединения (union) 349
таким объединением пользоваться не будем
char c;
int i;
double d;
} data;
};
//Файл func.cpp
#include "uni.h"
void f(Uni* p)
{
switch(p->what)
{
case CHAR:
//пользуемся полем p->data.c
break;
case INT:
//пользуемся полем p->data.n
break;
case DOUBLE:
//пользуемся полем p->data.d
}
}
10.3. Размер объединения
Размер объединения (сколько памяти компилятор выделит под переменную
такого типа) определяется размером его наибольшего поля:
union B{
double x;
int y;
char z;
};
size_t n = sizeof(B); //8, так как sizeof(double)=8
ЗАМЕ ЧАНИЕ
Оптимизирующие компиляторы могут увеличивать размер объединения для
выравнивания адресов элементов данных по границам, равным степени двойки.
350 Глава 10
Например:
union С{
double d;
char ar[11];
};
size_t n = sizof(C); //VC: 16 байтов
10.4. Инициализация объединений
При создании переменной-объединения можно применять список инициали-
заторов (листинг 10.4). При этом компилятор использует для присваивания
значения первое из объявленных в объединении полей.
Листинг 10.4. Инициализация объединений
//Вариант 1.
union U{
int n;
char ch[4];
};
int main()
{
union U ob = {0x44332211}; //для инициализации компилятор
использует поле n
}
//Вариант 2.
union U{
char ch[4];
int n;
};
int main()
{
union U ob = {0x11, 0x22, 0x33, 0x 44}; // для инициализации
компилятор использует массив ch
//Содержимое памяти, отведенной под объединение U, в обоих случаях
будет идентичным.
}
Объединения (union) 351
10.5. Анонимные объединения
(специфика Microsoft)
Иногда просто требуется сообщить компилятору, что необходимо разместить
несколько переменных по одному и тому же адресу. Для этого можно ис-
пользовать анонимное объединение.
Специфика: обращение к членам объединения происходит не посредством
экземпляра, а просто по имени поля объединения (листинг 10.5).
Листинг 10.5. Использование анонимных объединений
int main()
{
…
{
union{ //это определение, поэтому компилятор выделит
память, исходя из наибольшего поля объединения
int n;
char ch[4];
};
//до конца блока можно пользоваться полями объединения просто по имени
n=10;
ch[3] = 33;
}
…
}
ПРИЛОЖЕНИЯ
Приложение 1
Представление данных
Перед тем как использовать переменные в выражениях, программист должен
описать их свойства, чтобы компилятор смог:
􀂈 выделить требуемый объем памяти для хранения значения каждой пере-
менной;
􀂈 правильно выбрать команды процессора для действий с разными пере-
менными.
Знание того, как представляются данные разных типов в памяти и в регист-
рах процессора, каковы особенности выполнения действий с этими данными,
позволит программисту избежать некоторых ошибок, а также повысить эф-
фективность разрабатываемой программы.
П1.1. О системах счисления
и изображении количеств
У меня на днях был день рождения —
23 года исполнилось.
Торт был со свечками, с пятью, все го-
рели кроме второй.
Вот так! 10111
Для кодирования количеств (чисел) люди в своей повседневной практике ис-
пользуют так называемые системы счисления. В любой системе счисления
для изображения количеств служат комбинации цифр.
Любая система счисления должна позволять человеку (а также и техниче-
скому устройству):
􀂈 записывать количества, используя минимум места (на бумаге, в памяти
компьютера);
356 Приложения
􀂈 выполнять действия с количествами, придерживаясь максимально просто-
го набора правил.
Как раз этими двумя свойствами и различаются системы счисления.
Система счисления (СС) — это способ изображения чисел. В ходе своего
развития человечество изобрело весьма много различных систем счисления.
Привычная для нас десятичная СС, а также СС, которые используются
в цифровой технике — двоичная и шестнадцатеричная — это системы со
следующими свойствами:
􀂈 позиционные — вес единицы разряда числа зависит от позиции разряда
(пример непозиционной системы — римская);
􀂈 с постоянным основанием системы счисления — количество различных
цифр одинаково для любого разряда числа (пример системы с перемен-
ным основанием — система исчисления времени);
􀂈 с естественным порядком следования весов — вес единицы следующего
разряда на 1 больше максимального числа, представимого всеми преды-
дущими разрядами;
􀂈 с естественным представлением цифр в разрядах (не кодированным) —
для каждого разряда используется количество цифр, равное основанию
системы счисления (пример системы с кодированным представлением
цифр — система исчисления времени, где для 60 различных значений се-
кунд и минут используется не 60 разных знаков, а десятичное представле-
ние чисел от 0 до 59).
Важное преимущество СС, обладающих перечисленным набором свойств,
заключается в простоте правил, по которым выполняются арифметические
действия. Например, m-разрядное число (где di — это обозначение цифры
в записи числа) в любой СС (с упомянутым набором свойств и с основанием
системы счисления) связано количеством N, изображаемым этим числом вот
такой простой формулой (1):
N = dm–1 * Bm–1 + dm–2 * Bm–2 + dm–3 * Bm–3 +…+ d2 * B2 + d1* B1 + d0 * B0 (1)
В этой формуле:
􀂈 B — основание системы счисления;
􀂈 (dm-1 dm-2…d1 d0)(B) — цифры в записи числа (нижний индекс в скобках
здесь и далее означает основание системы счисления).
Десятичная система счисления имеет основание 10:
(1056)(10) = (1 * 103 + 0 * 102 + 5 * 101 + 6 * 100)(10) (1а)
Приложение 1. Представление данных 357
Двоичная система счисления имеет основание 2 (значения цифр — 0 и 1):
(101011)(2) = (1 * 25 + 0 * 24 + 1 * 23 + 0 * 22 + 1 * 21 + 1 * 20)(10) = 43(10) (1б)
ЗАМЕ ЧАНИЕ
Обратите внимание, что формулу (1) можно использовать для перевода в де-
сятичную систему из любой другой, все действия при этом переводе придется
выполнять только в привычной десятичной СС.
П1.2. Перевод чисел из одной системы
счисления в другую
Перевод в систему счисления с основанием B можно выполнить по схеме,
которую легко получить, преобразовав формулу (1).
N = ((((……+ di)B + di–1)B +…+ d2)B + d1)B + d0 (2)
Из формулы (2) видно, что при делении на основание системы счисления
сначала исходного числа, а затем предыдущих частных, остатки от целочис-
ленного деления будут давать значения цифр, начиная с младшей.
Пример 1.
Пусть необходимо перевести число 79 в двоичную систему счисления.
Начинаем действия справа (табл. П1.1).
Первый шаг: делим заданное число (79) на основание системы счисления, в
которую переводим (2). Записываем частное (39) и остаток от деления (он
может быть только 0 или 1, в данном случае остаток = 1).
Второй шаг: делим полученное частное (39) на 2, записываем частное (19) и
остаток от деления (1).
Третий шаг: в результате деления 19 на 2 получаем частное (9) и остаток (1).
Следующие шаги выполняются по аналогичной схеме до тех пор, пока на
очередном шаге (в нашем случае — на 7-ом) не получим частного, равного 0.
Это признак окончания процесса.
Цепочка остатков (слева направо — 1001111) дает последовательность цифр
числа для записи в требуемой системе счисления (в нашем примере — в дво-
ичной).
358 Приложения
Таблица П1.1. Перевод числа 79 в двоичную систему счисления
7 6 5 4 3 2 1 Номер шага
1 / 2 2 / 2 4 / 2 9 / 2 19 / 2 39 / 2 79 / 2 Действие
0 1 2 4 9 19 39 Частное от деления на 2
←
1 0 0 1 1 1 1 Остаток
←
Проверим правильность результата:
(1001111)(2) =
= (1*26 + 0*25 + 0*24 + 1*23 + 1*22 + 1*21 + 1*20)(10) =
= (64 + 0 + 0 + 8 + 4 + 2 + 1)(10) = 79(10)
ЗАМЕ ЧАНИЕ
Мы выполнили преобразование, оперируя с количеством, исходно записанным
в десятичной системе. Для того чтобы преобразовать число из любой системы
счисления, необходимо уметь делить в исходной СС. Поскольку люди уверенно
выполняют действия лишь в десятичной системе счисления, то перевод из
какой-нибудь СС в любую другую обычно выполняют в два этапа: сначала из
исходной СС переводят в десятичную по формуле (1), а затем из десятичной —
в требуемую.
Пример 2.
Выполним перевод того же самого числа (79) в троичную систему (табл. П1.2)
и тоже проверим правильность результата:
(2221)(3) =
= (2 * 33 + 2 * 32 + 2 * 31 + 1 * 30) =
= (54 + 18 + 6 + 1)(10) = 79(10)
Таблица П1.2. Перевод числа 79 в троичную систему счисления
4 3 2 1 Номер шага
2 / 3 8 / 3 26 / 3 79 / 3 Действие
0 2 8 26 Частное от деления на 3
←
2 2 2 1 Остаток
←
Приложение 1. Представление данных 359
Пример 3.
Рассмотрим более подробно шестнадцатеричную систему счисления.
Эта система имеет основание 16. Для изображения шестнадцати цифр ис-
пользуются:
􀂈 привычные цифры: 0,…9;
􀂈 буквы латинского алфавита: A(10), B(11), C(12), D(13), E(14), F(15).
Шестнадцатеричная (далее — hex) система используется в вычислительной
технике в основном для компактного изображения двоичных чисел (напри-
мер, при отображении содержимого внутренних элементов процессора в окне
экранного отладчика — регистров и элементов памяти).
Популярность шестнадцатеричной системы объясняется тем, что одна цифра
в шестнадцатеричной записи однозначно соответствует четырехразрядной
комбинации цифр в двоичной записи того же числа.
Это несложно увидеть из формулы (3), где каждая скобка соответствует од-
ной шестнадцатеричной цифре.
N =…+ 27 ∗ b7 + 26 ∗ b6 + 25 ∗ b5 + 24 ∗ b4 + 23 ∗ b3 + 22 ∗ b2 + 21 ∗ b1 + 20 ∗ b0 =
=…+ (23 ∗ b7 + 22 ∗ b6 + 21 ∗ b5 + 20 ∗ b4) ∗ 24 + (23 ∗ b3 + 22 ∗ b2 + 21 ∗ b1 + 20 ∗ b0) =
=…+ (23 ∗ b7 + 22 ∗ b6 + 21 ∗ b5 + 20 ∗ b4) ∗ 161 + (23 ∗ b3 + 22 ∗ b2 + 21 ∗ b1 + 20 ∗ b0) ∗160=
=…+ h1∗161 + h0∗160 (3)
Условные обозначения в формуле:
􀂈 N — изображаемое количество;
􀂈 bi — двоичные цифры;
􀂈 hi — шестнадцатеричные цифры.
В табл. П1.3 приведено соотношение между шестнадцатеричными, двоичны-
ми и десятичными числами от 0 до 16. Таблицу соответствия между шестна-
дцатеричными цифрами от 0 до 0F(16) и их двоичными и десятичными экви-
валентами следует выучить наизусть.
Пример перевода числа из шестнадцатеричной системы в десятичную:
7EA(16) = (7 * 162 + 14 * 161 + 10 * 160) =
= 7 * 256 + 14 * 16 + 10 =
= 1792 + 224 + 10 = 2026
360 Приложения
Таблица П1.3. Соотношение между шестнадцатеричными,
двоичными и десятичными числами
Hex
(шестнадцатеричные)
Dec
(десятичные)
Bin
(двоичные)
00 00 0 0000
01 01 0 0001
02 02 0 0010
03 03 0 0011
04 04 0 0100
05 05 0 0101
06 06 0 0110
07 07 0 0111
08 08 0 1000
09 09 0 1001
0A 10 0 1010
0B 11 0 1011
0C 12 0 1100
0D 13 0 1101
0E 14 0 1110
0F 15 0 1111
10 16 1 0000
Теперь обсудим действия над многоразрядными числами. Перечень дейст-
вий, которые могут потребоваться при выполнении вычислений, достаточно
велик, но более сложные действия (такие, как умножение, деление, вычисле-
ние элементарных функций) можно свести к некоторой (может быть, длин-
ной) последовательности более простых действий. Поэтому далее в основном
будем обсуждать только сложение и вычитание.
Вспомним правило сложения (вычитания) многоразрядных чисел, которому
учили в школе.
ПР А В И Л О
Для сложения/вычитания многоразрядных чисел A и B следует склады-
вать/вычитать отдельно цифры в каждом из разрядов, пользуясь таблицей
сложения/вычитания, с учетом возможного переноса (заема) из предыдущего
(младшего) разряда.
Приложение 1. Представление данных 361
Сложение одноразрядных чисел выполняют, используя таблицу сложения.
Для десятичной СС ее называют таблицей Архимеда и учат наизусть в пер-
вом классе школы (она обычно изображена на задней стороне обложки тет-
радей в клетку). Таблица для десятичной СС содержит 100 (с учетом симмет-
рии — 55 различающихся) клеток для различных сочетаний одноразрядных
слагаемых. Для каждой пары одноразрядных слагаемых в таблице указано
значение суммы и значение переноса в следующий разряд.
Аналогично можно составить таблицу вычитания для одноразрядных чисел.
Правило и таблицу используют при разработке схемотехники арифметико-
логического устройства в процессорах.
П1.3. Использование различных систем
счисления при технической реализации
средств цифровой вычислительной техники
В электронных цифровых устройствах разные цифры чаще всего изображают
различными значениями электрического напряжения. В ходе развития электрон-
ных цифровых устройств инженеры быстро пришли к выводу, что в этих устрой-
ствах наиболее выгодно изображать числа в двоичной системе счисления.
Один из наиболее распространенных в настоящее время стандартов предпи-
сывает изображать:
􀂈 двоичную цифру 0 — напряжением в интервале от 0 В до +0,4 В;
􀂈 двоичную цифру 1 — напряжением в интервале от +2,4 В до 5,0 В.
Обратите внимание, что между этими диапазонами оставлен значительный
промежуток в 2,0 В (от 0,4 В до 2,4 В). Это сделано для того, чтобы затруд-
нить искажение логического сигнала под действием разнообразных помех.
Если бы использовалась не двоичная, а десятичная система счисления, то тот
же интервал напряжений от 0 до 5,0 В пришлось бы разбить на 10 несмеж-
ных диапазонов для изображения десяти цифр, при этом промежутки между
диапазонами соседних цифр были бы гораздо меньше, и соответственно, ис-
кажения значений цифр происходили бы под действием помех гораздо
меньшей величины.
Человек привык к десятичной системе счисления, в которой даже большие
величины изображаются числами с обозримым количеством цифр (разрядов).
Напротив, двоичная система счисления требует для изображения той же ве-
личины гораздо большего (приблизительно в три с половиной раза) количе-
ства разрядов. Например, текущий 2007 год в двоичной системе счисления
изображается числом 11111010111, содержащим 11 разрядов.
362 Приложения
Визуальное восприятие и быстрая оценка на глаз значений многоразрядных
двоичных чисел для человека затруднительны. Быстрый перевод из двоичной
системы счисления в десятичную и обратно человеку также затруднительно
выполнять в уме.
По этой причине в цифровой вычислительной технике используют шестна-
дцатеричную и (реже) восьмеричную системы счисления. Числа в этих сис-
темах счисления обозримы (содержат небольшое, по сравнению с двоичной,
количество цифр), и из этих систем счисления легко преобразовать числа
в двоичную систему (и обратно).
П1.4. Особенности выполнения
арифметических операций
в ограниченной разрядной сетке
Арифметико-логическое устройство (АЛУ) в цифровом процессоре может
выполнять действия только с числами определенной (ограниченной) разряд-
ности. В зависимости от значения этой разрядности различают процессоры:
􀂈 8-разрядные;
􀂈 16-разрядные;
􀂈 32-разрядные;
􀂈 64-разрядные.
При сложении формируется значение суммы, разрядность которой равна раз-
рядности слагаемых. Это означает, что даже при выполнении такого просто-
го действия, как сложение, некоторые комбинации операндов могут дать ре-
зультат, не умещающийся в данном количестве разрядов (перенос за границу
разрядной сетки).
Некоторые процессоры способны выполнять действия с целыми числами
различной разрядности. Например, представители семейства Intel x86 (моде-
ли i386 или старше) могут работать с операндами длиной в 1 байт, либо 2 байта,
либо 4 байта. Другие процессоры всегда выполняют действия с целыми опе-
рандами одной разрядности (например, в RISC-процессорах с архитектурой
ARM — только с четырехбайтовыми). Это не значит, что в таких процессо-
рах не используются операнды с меньшей (или с большей) разрядностью.
Просто перед выполнением действия операнды меньшей длины преобразу-
ются к четырехбайтовым.
В табл. П1.4 приведены значения, которые может принимать число, изобра-
жаемое в ограниченной разрядной сетке. Обратите внимание, что каждое
Приложение 1. Представление данных 363
последующее число можно получить из предыдущего в результате прибавле-
ния единицы. Однако если это проделать с максимальным числом (содержа-
щим единицы во всех разрядах), то в n-разрядной сетке будет получено (не-
верное) значение: 000….000.
Таблица П1.4. Диапазон беззнаковых значений, представимых в n-битовой сетке
HEX BIN DEC К следующему
значению
00...01 000...001 ?
00...00 000...000 ? +1
...FFF 111...111 2
n
– 1 +1
...FFE 111...110 2
n
– 2 +1
...FFD 111...101 2
n
– 3 +1
….. …… …… …..
00...02 000...010 2 +1
00...01 000...001 1 +1
00...00 000...000 0 +1
Представление чисел оказывается циклически повторяющимся (в табл. П1.4
граница цикла обозначена двойной линией). Цикличность представления
и ограниченность диапазона приводят к тому, что итогом операции может
быть либо правильный результат, либо выход за границу диапазона предста-
вимых значений (этот выход называют переполнением разрядной сетки).
Факт возникновения переполнения никак не отмечается в сформированном
результате — он просто оказывается неверным! Однако переполнение реги-
стрируется схемотехникой процессора: в любом процессоре имеется спе-
циальный регистр, называемый регистром состояний или регистром флагов.
В этом регистре при возникновении переполнения устанавливается в 1 один
из разрядов — флаг переноса (беззнакового переполнения). По-английски его
называют С-flag (от Carry — перенос).
П1.5. Изображение знакопеременных величин
Теперь рассмотрим, как изображают целые знакопеременные числа.
Естественный способ представления отрицательных чисел можно получить,
последовательно вычитая единицу из нуля. Такое представление (табл. П1.5)
364 Приложения
называется дополнительным кодом (английский эквивалент — two’s complement).
Представление чисел со знаком в дополнительном коде также будет цикли-
ческим.
Таблица П1.5. Диапазон знакопеременных значений,
представимых в n-битовой разрядной сетке
HEX BIN DEC К предыдущему
значению
Примечание
0..FFF 011...111 2n-1-1 Наибольшее положи-
тельное число
+1
00...02 000...010 2 +1
00...01 000...001 1 +1
00...00 000...000 0 ±1 Нуль
F..FFF 111...111 -1 -1
F..FFE 111...110 -2 -1
... ... -1
80..00 100...000 -2n-1 Наименьшее отрица-
тельное число
Из таблицы видно, что положительные числа получаются последовательным
прибавлением единицы к предыдущему (меньшему) значению (начиная с нуля),
а отрицательные — вычитанием единицы из предыдущего (большего) значе-
ния, также начиная с нуля.
Обратите внимание на то, что в представлении знакопеременных чисел кодо-
вые комбинации от 100...000 до 111...111 переехали вниз таблицы,
и теперь используются для изображения отрицательных количеств. Макси-
мальное положительное число, которое можно представить, используя n-
разрядный дополнительный код, приблизительно вдвое меньше того, которое
было в представлении знакопостоянных величин в той же n-разрядной сетке.
Таблица П1.6 демонстрирует, как одни и те же кодовые комбинации исполь-
зуются для изображения различных диапазонов значений. Средние столбцы
содержат граничные значения величин в общем виде и для байтовой разряд-
ной сетки, т. е. для n = 8.
Приложение 1. Представление данных 365
Таблица П1.6. Дополнительный код: соотношение между представлением
беззнаковых и знакопеременных величин
Беззнаковые
величины
Знакопеременные
Двоичные
комбинации
Граничные
значения
Для байтовой
разрядной
сетки
Двоичные комбинации
111...111 2n–1 +255
100...001 +129
100...000 +128
Не представимы
011...111 2n–1–1 +127 011...111
... ... ...
000...000 0 0 000...000
–1 –1 111...111
–2n–1–1 –127 100...001
Не представимы
–2n–1 –128 100...000
Обратите внимание на то, что одна и та же кодовая комбинация может обо-
значать различные количества, в зависимости от того, как ее интерпретиро-
вать — как знаковую либо как беззнаковую.
Например, комбинация 10000001 означает:
􀂈 +129 — при беззнаковой интерпретации;
􀂈 –127 — при знаковой интерпретации.
Комбинация 11111111 это:
􀂈 –1 — при знаковой интерпретации;
􀂈 +255 — при беззнаковой интерпретации (в таблице соответствующие зна-
чения подчеркнуты).
Интерпретацию кодов определяет программист и сообщает об этом компиля-
тору, когда указывает в описаниях тип переменных. Компилятор же при
трансляции использует соответствующие (различные) процессорные коман-
ды для обработки переменных разных типов.
366 Приложения
Примеры таких ситуаций:
􀂈 знаковое и беззнаковое целочисленное умножение;
􀂈 команды преобразования коротких целочисленных форматов в длинные;
􀂈 деление целочисленных переменных на степень двойки путем сдвига (см.
разд. П1.9, П1.10, П1.12).
Отметим некоторые особенности кодирования знакопеременных количеств
дополнительным кодом:
􀂈 все неотрицательные числа содержат подряд один или более нулей в стар-
шей (левой) части двоичного кода. При этом: чем меньше модуль числа,
тем больше нулей там будет (в частности, число +1 содержит в n-битовом
коде (n–1) старших нулей);
􀂈 все отрицательные числа содержат подряд одну или более единиц в стар-
шей (левой) части двоичного кода. При этом: чем меньше модуль числа,
тем больше единиц там будет (в частности, число –2 содержит в n-битовом
коде (n–1) старших единиц, а число –1 содержит n старших единиц, т. е.
просто все до единой);
􀂈 старший бит знакопеременного целочисленного операнда можно рассмат-
ривать как знаковый (0 означает плюс, а 1 — минус);
􀂈 одни и те же кодовые комбинации в интервале от 100...000 до 111...111
при кодировании беззнаковых величин и при кодировании величин со
знаком представляют различные количества, в то время как кодовые ком-
бинации от 000...000 до 011...111 — одни и те же количества, независимо
от типа величины;
􀂈 для представления чисел используются все кодовые комбинации, возмож-
ные в данной разрядной сетке, т. е. любой последовательности единиц и
нулей в коде соответствует какое-то числовое значение (при представле-
нии чисел в форматах плавающей точки это будет не так!);
􀂈 замечательное свойство дополнительного кода для изображения знакопе-
ременных чисел состоит в том, что действия сложения и вычитания с до-
полнительным кодом можно выполнять по правилу "в столбик", безотно-
сительно к знакам операндов. При этом лишь следует учитывать
возможность того, что результат действия (иногда) может выйти за грани-
цы представимого диапазона значений.
Дополнительный код используется для изображения знакопеременных вели-
чин во всех современных процессорах. Однако встречаются случаи, когда
в отдельных специальных случаях знакопеременные величины кодируются
двоичными словами по-иному (пример см. в разд. П1.11.2).
Приложение 1. Представление данных 367
П1.6. Выявление переполнений при
выполнении сложения и вычитания
Цикличность представления и ограниченность диапазона приводят к тому,
что итогом операции может быть либо правильный результат, либо выход за
границу диапазона представимых значений, т. е. переполнение разрядной
сетки.
Цикличность представления целых чисел в ограниченной разрядной сетке
можно изобразить с помощью круговой диаграммы (рис. П1.1 и П1.2). Эта
диаграмма наглядно иллюстрирует переход к следующему числу путем при-
бавления единицы, переход к предыдущему — путем вычитания единицы,
сложение чисел — как сложение эквивалентных углов, а также хорошо вид-
ны явления переполнения для беззнаковых чисел и чисел со знаком.
Рис. П1.1
368 Приложения
Для выявления выхода за границы представимого диапазона используется
флаг — бит переноса в регистре состояний процессора (обозначается cf или
C — от Carry). При выполнении действий АЛУ устанавливает этот бит в 1,
если при интерпретации операндов как беззнаковых, результат операции
выйдет за границы представимого диапазона.
Другая диаграмма (рис. П1.2) иллюстрирует кодирование знакопеременных
величин.
Для выявления выхода результата операции за границы представимого диа-
пазона в регистре состояний имеется еще один флаг — бит арифметического
переполнения (обозначается of или V — от oVerflow). При выполнении дей-
ствий АЛУ устанавливает этот бит в 1, если при интерпретации операндов
как знакопеременных, результат операции выйдет за границы представимого
диапазона.
Рис. П1.2
Приложение 1. Представление данных 369
ЗА П О МН И Т Е!
По внешнему виду операндов невозможно заключить, изображают ли кодовые
комбинации положительные (беззнаковые) числа или знакопеременные. Об этом
знает только программист, когда он объявляет типы переменных. Получив объ-
явления переменных, о них узнает компилятор и учтет при генерации машин-
ных команд.
Одна и та же пара кодов при выполнении действия (например, сложения)
может дать в результате переполнение, если эти коды изображают беззнако-
вые числа, и напротив — дать верный результат, если коды изображают чис-
ла со знаком. О том, произошло ли переполнение, можно узнать, проверив
значение соответствующего флага после выполнения операции.
Пример.
Допустим, в байтовой разрядной сетке выполняется сложение кодов:
1111 1101 и 0000 0101.
Сложение столбиком:
1111 1101
0000 0101
———————————
0000 0010 — результат (при этом возникает перенос
за границу разрядной сетки)
При выполнении этого действия схемотехника АЛУ устанавливает флаг cf
в 1 и сбрасывает флаг of в 0.
Если слагаемые интерпретируются как беззнаковые (unsigned char), то они
изображают количества 253 и 5, а их сумма равна 258, что превышает макси-
мальное значение 255, которое можно представить в байтовой разрядной сет-
ке. Это означает, что произошло (беззнаковое) переполнение, о чем сигнали-
зирует установившийся флаг cf (флаг беззнакового переполнения).
Если же коды изображают знакопеременные операнды, то первому коду со-
ответствует значение –3, а второму — по-прежнему 5. Сумма этих двух зна-
чений равна +2, выход за границу представимого диапазона значений
(–128…+127) отсутствует, о чем свидетельствует сброшенный флаг of (флаг
знакового переполнения).
Для учета состояния флагов в системах команд процессоров всегда имеются
команды с условным исполнением. Такая команда выполняет действие, если
имеет место указанная в ней комбинация флагов, или же она ведет себя как
пустая команда, если состояния флагов не соответствуют заданным.
В большинстве процессоров условное исполнение реализовано только для
команд перехода (команды условного перехода). В семействе x86 имеется
370 Приложения
также группа команд условного копирования CMOVcc (Conditional MOVe).
Однако в некоторых процессорах команд с условным исполнением может
быть гораздо больше (например, в процессорах с архитектурой ARM боль-
шинство команд являются командами с условным исполнением).
П1.7. Смена знака
целого знакопеременного числа
Как поменять знак числа, изображенного в дополнительном коде? Для полу-
чения правила (алгоритма) проделаем простые преобразования, взяв за ис-
ходное некоторое число k:
– k = (1 – 1) – k = (–1 – k) +1
Теперь учтем, что –1 изображается кодом 111...11.
Действие (–1 – k) всегда возможно, и при его выполнении ни в одном из раз-
рядов не происходит заема. Его можно реализовать инвертированием всех
битов кода k. Это легко увидеть, выполнив вычитание столбиком:
_1 1 1 1 . . . 1 1 — код числа (–1)
1 0 0 1 . . . 0 1 — код вычитаемого (число k)
————————————
0 1 1 0 . . . 1 0 — результат (инверсия вычитаемого)
Таким образом, правило получения кода для числа с противоположным зна-
ком выглядит так: проинвертировать (заменить противоположными значе-
ниями) все биты исходного двоичного числа, а затем прибавить к результату
единицу (по правилу в столбик).
В наборе процессорных команд обычно имеется специальная команда для
выполнения этого действия. Отметим, что если процессор умеет выполнять
вычитание, то смену знака можно выполнить вычитанием из нуля.
Обратите внимание на то, что смена знака наименьшего отрицательного чис-
ла 100...00 даст неверный результат. Это следствие того факта, что диапазон
представимых значений в дополнительном коде несимметричен относитель-
но нуля (отрицательных чисел на одно больше, нежели положительных).
П1.8. Действия с повышенной разрядностью
Стандарт языка Си предусматривает четыре разновидности длин целочис-
ленных операндов:
􀂈 один байт (char);
􀂈 два байта (short или int);
Приложение 1. Представление данных 371
􀂈 четыре байта (int или long);
􀂈 восемь байтов (long long).
Исторически так сложилось, что тип int был привязан к разрядности процес-
сора, т. е. имел длину, совпадающую с длиной машинного слова (операнда,
с которым АЛУ данного процессора могло справиться в рамках одной команды).
В то же время требуется, чтобы можно было проводить вычисления с пере-
менными любого допустимого стандартом целого типа на любых процессо-
рах (в т. ч. и на малоразрядных). Это оказывается всегда возможным, по-
скольку действия с длинными переменными можно выполнять, используя
несколько коротких процессорных команд, которые формируют значение ре-
зультата по частям. Например, для сложения длинных операндов можно ис-
пользовать несколько процессорных команд сложения, причем первая команда
складывает младшие части операндов, а все остальные команды сложения
должны учитывать и возможные переносы, возникшие при сложении млад-
ших частей.
Такая возможность (и в частности, учет переносов) поддерживается во всех
процессорах на аппаратном уровне, а соответствующая техника программи-
рования носит название — операции с повышенной разрядностью.
П1.9. Особенности умножения и деления
целых двоичных чисел
При умножении разрядность получаемого результата может превысить (оди-
наковые) разрядности сомножителей вдвое. Это означает, что (возможно)
придется для результата использовать переменную удвоенной длины. Обыч-
но команды умножения в процессоре реализованы именно по такой схеме,
когда на выходе блока умножения формируется результат удвоенной (по
сравнению с сомножителями) длины. К сожалению, при использовании до-
полнительного кода замечательное свойство инвариантности результата опе-
рации к знаковости операндов имеет место только для действий сложения
и вычитания. Умножение одних и тех же двоичных кодов сомножителей дает
различные результаты в зависимости от того, являются сомножители беззна-
ковыми либо знакопеременными.
Пример.
Пусть умножаются два байтовых сомножителя: 1111 1010 и 0000 0011.
Если эти коды изображают беззнаковые величины, то они равны соответственно
250 и 3, а их произведение равно 750 (в двоичном виде 0000 0010 1110 1110).
372 Приложения
Если те же коды изображают знакопеременные величины, то они равны –6
и 3, а их произведение равно –18 (в двоичном виде 1111 1111 1110 1110).
Как видим, результат умножения изображается различными кодовыми ком-
бинациями в зависимости от знаковости операндов, хотя коды сомножителей
одинаковы. Этим фактом объясняется наличие в процессорах двух вариантов
команды целочисленного умножения (знакового и беззнакового). Одновре-
менно отметим тот факт, что если результат умножения имеет удвоенную
длину, то в ней переполнение не может возникнуть ни при каких комбинаци-
ях значений сомножителей.
Однако при использовании такого умножения только программист может
решить, что делать с результатом удвоенной длины (ведь нельзя же каждый
раз при выполнении умножения удваивать длину используемых операндов).
Если сравнить результаты знакового и беззнакового умножения в приведен-
ном примере, то можно отметить, что они различаются только в старших час-
тях, в то время как младшие — идентичны. Это не случайное совпадение для
приведенного примера, а общая закономерность выполнения умножения при
использовании дополнительного кода. Этим объясняется тот факт, что наря-
ду с командами умножения, формирующими результат удвоенной длины,
в некоторых процессорах имеются и команды, которые дают результат ум-
ножения с той же длиной, что и сомножители. При использовании таких ко-
манд гораздо выше шансы на возникновение переполнения, но зато можно
применять одну и ту же команду, как для знаковых, так и для беззнаковых
операндов.
И снова подчеркнем, что контроль переполнения при любых арифметических
действиях является исключительно заботой программиста.
П1.10. Приведение типов данных
В языке Си (как, впрочем, и в других) используется несколько целых типов
данных, различающихся размером:
􀂈 char — один байт;
􀂈 short — два байта;
􀂈 int — два либо четыре байта (зависит от разрядности процессора);
􀂈 long — четыре байта;
􀂈 long long — восемь байтов.
Рассмотрим на примерах, как будет выглядеть двоичный код одного и того
же числа в различных типах данных.
Приложение 1. Представление данных 373
Пример 1.
Число +6 будет выглядеть:
􀂈 в байтовой разрядной сетке (signed или unsigned char) — 0000 0110;
􀂈 в двухбайтовой (signed или unsigned short) — 0000 0000 0000 0110;
􀂈 в четырехбайтовой — 0000 0000 0000 0000 0000 0000 0000 0110.
Пример 2.
Число –3 будет выглядеть:
􀂈 в байтовой разрядной сетке (signed или unsigned char) — 1111 1101;
􀂈 в двухбайтовой (signed или unsigned short) — 1111 1111 1111 1101;
􀂈 в четырехбайтовой — 1111 1111 1111 1111 1111 1111 1111 1101.
Вы можете легко убедиться в правильности последних трех строк, если при-
бавите (в столбик, со всеми переносами!) к любому из приведенных чисел
число +3 (его код — ... ...0011).
Во всех случаях у вас (в той же разрядной сетке) получится 0 (так и должно
быть, поскольку (–3) + (+3) = 0).
Из приведенных примеров нетрудно по индукции вывести правило приведе-
ния более короткого типа к более длинному:
􀂈 для беззнаковых (unsigned) типов надо заполнить левую часть более
длинного типа нулями;
􀂈 для знакопеременных надо заполнить левую часть более длинного типа
значением старшего (знакового) бита исходного, более короткого типа.
Именно так работает оператор преобразования типа языка Си (cast
operator).
Например:
􀂈 (short) 0001 0111 = 0000 0000 0001 0111 (результат — со знаком);
􀂈 (int) 1100 1101 = 1111 1111 1111 1111 1111 1111 1100 1101 (результат —
со знаком);
􀂈 (unsigned int) 1100 1101 = 0000 0000 0000 0000 0000 0000 1100 1101 (ре-
зультат — без знака).
Правомерно задать обратный вопрос — а что, если начнем приводить более
длинный тип к более короткому?
Компилятор просто усечет (отбросит) старшую часть более длинного операнда,
но при этом программист должен быть уверен в том, что во-первых — отбрасы-
374 Приложения
ваемая часть содержит только одинаковые цифры (все нули либо все едини-
цы), и во-вторых — что после усечения знакового операнда знак числа не
изменился, т. е. в результирующем коротком типе старший бит имеет то же
значение, что и биты в отброшенной левой (старшей) части. Если это не
так, то значит, что значение исходной переменной не представимо (не по-
мещается) в короткой разрядной сетке — приведение выполнить невоз-
можно!
Приведем фрагмент кода, в котором такая проверка делается. Производится
сравнение длинного операнда с границами, в которых тот должен находить-
ся, чтобы была возможность привести к короткому типу.
int x = значение;
char c;
if(x>=-128 && x<=127) c=x; //можно присвоить без возникновения ошибки
Еще одно желание, которое может возникнуть — привести беззнаковый тип
к знаковому (или наоборот) без изменения разрядности. Такое приведение
тоже не всегда будет выполнено компилятором верно (см. разд. П1.12).
Прежде всего, отметим, что приведение, безусловно, возможно лишь в том
случае, если диапазон значений приводимого типа целиком содержится
в (большем) диапазоне типа, к которому выполняется приведение. Это имеет
место лишь в случае, когда более короткий беззнаковый тип приводится
к более длинному знакопеременному. Во всех остальных случаях возможно
возникновение ошибки.
Например, приведение знакового типа к (сколь угодно длинному) беззнако-
вому невозможно, если исходная переменная отрицательна. Точно так же,
приведение беззнакового типа к знакопеременному той же разрядности при-
ведет к ошибке в половине случаев, т. к. диапазон положительных значений
для знакового типа вдвое уже, чем у беззнакового той же длины.
Следует помнить, что компилятор не контролирует возможность возник-
новения ошибок при приведении типов — это целиком обязанность про-
граммиста.
Общая рекомендация может состоять в том, что не следует ни в каких опера-
циях смешивать беззнаковые и знакопеременные операнды, если нет твердой
уверенности в том, что компилятор верно выберет эквивалентные процессор-
ные команды при трансляции. А твердая уверенность может быть лишь то-
гда, когда программист отчетливо понимает возможности и ограничения
уровня процессорных команд.
Приложение 1. Представление данных 375
П1.11. Числа с плавающей точкой
Еще раз отметим некоторые свойства целочисленного формата представле-
ния величин:
􀂈 разрешающая способность (минимальное изменение величины, которое
можно отобразить), равна 1 (при любом числе разрядов n);
􀂈 диапазон представимых значений однозначно определяется количеством
разрядов n в разрядной сетке — 2n, т. е. разрешающая способность и диа-
пазон связаны однозначно при данном количестве битов в представлении
числа.
Целочисленное представление хорошо подходит для таких задач, в которых
величины подсчитываются в штуках (хороший пример — задача учета пер-
сонала или посетителей в учреждении).
Во многих других случаях необходимо иметь разрешающую способность,
отличную от единицы. Например, контроль координаты, когда разрешающая
способность определяется необходимой точностью контроля (скажем —
0,01 мм в металлорежущем станке). В таких случаях часто используют при-
ем, называемый масштабированием, когда единице двоичного кода сопос-
тавляют величину, соответствующую требуемой разрешающей способности
(в нашем примере — 0,01 мм, при 16-битовой разрядной сетке диапазон
представимых значений от 0 до 65535 ∗ 0,01 = 625,35 мм). Масштабирование
в данном случае — это действие, которое выполняется только в голове у про-
граммиста.
Почти эквивалентный прием: можно сместить положение разделителя целой
и дробной части так, что часть двоичного слова (левее разделителя) будет
представлять целую часть числа, а другая часть справа от разделителя — дроб-
ную. Для такого представления можно расширить уже приведенное разложе-
ние количества (см. формулу 1б) по степеням основания системы счисления:
N = dm–1 * 2m–1 + dm–2 * 2m–2 + dm–3 * 2m–3+…
+ d2 * 22 +d1 * 21 + d0 * 20 + d–1 * 2–1+ d–2 * 2–2+…
Здесь: d-1, d-2,… — цифры в дробной части числа.
В этом случае вес единицы младшего разряда кода составит отрицательную
степень двойки: 2-k.
зн … … d1 d0 d–1 d–2 d–3 … d–k
Этот прием можно реализовать не только в голове, но и в аппаратуре (в част-
ности, в АЛУ). Для действий умножения АЛУ можно спроектировать так,
376 Приложения
что при формировании результата положение разделителя в нем будет оста-
ваться на принятом фиксированном месте. Отметим, что действия сложения
и вычитания чисел в дополнительном коде будут выполняться правильно для
произвольного положения разделителя.
Пока еще точность и диапазон по-прежнему связаны.
Такое представление дробных чисел (его называют форматом с фиксирован-
ной точкой) подходит только для узкого класса задач, где требуется пред-
ставление величин с данной определенной разрешающей способностью.
Следующий шаг в направлении повышения универсальности формата пред-
ставления чисел — сделать положение разделителя переменным и где-то это
положение указывать (необходимо для каждого числа отдельно). Часть двоич-
ного слова, изображающую значащие цифры, принято называть мантиссой,
а другую часть, задающую положение разделителя — порядком. Точность и
диапазон после этого становятся при этом не зависимыми друг от друга.
Значение числа можно представить следующим образом:
Знак Мантисса Порядок
Точность — задается количеством знаков (битов) в поле мантиссы.
Диапазон — задается количеством битов в поле порядка (оно определяет,
насколько можем сдвигать разделитель).
Действия над такими числами выполнять сложнее.
П1.11.1. Неоднозначность представления
и нормализованная форма
Число в формате плавающей точки (ПТ) можно представить так:
±Мантисса ∗ Основание±Порядок
Однако такое представление неоднозначно:
1.2345 ∗ 102 = 12.345 ∗ 101 = 0.12345 ∗ 100
Выбирают одно из представлений, как стандартное — такое представление
называют нормализованным.
Например, во многих инженерных калькуляторах в качестве нормализован-
ного выбирается представление, у которого мантисса содержит ровно один
ненулевой десятичный разряд в целой части мантиссы:
±х.ххххххх ±хх . — так это выглядит на дисплее калькулятора
мантисса порядок
Приложение 1. Представление данных 377
Двоичное представление чисел в формате ПТ.
Нормализация
Если определенным образом выбрано нормализованное представление, то
при записи в двоичном виде старший разряд мантиссы — всегда двоичная 1
(ее можно не запоминать — сэкономим бит).
Процедура нормализации состоит в следующем: сдвигаем мантиссу так, что-
бы получить нормализованное представление, и при этом корректируем по-
рядок, чтобы сохранить величину числа неизменной.
Пример выполнения нормализации:
Исходное число:
101101.110001000 ∗ 101001 (в этой записи все числа двоичные).
Пусть выбрано нормализованное представление, в котором мантисса содер-
жит один значащий разряд в целой части (его значение всегда равно 1).
При нормализации сдвигаем мантиссу вправо на 5 разрядов (это эквивалент-
но делению мантиссы на 25 = 32) и корректируем порядок (увеличиваем его
на 5(10) = 101(2)).
Нормализованное представление:
1.011011100010... ∗101110 (все числа двоичные).
Опуская неявный бит, получим мантиссу:
011011100010...
и порядок:
..01110.
Уточним некоторые понятия.
Нормализованное число содержит в мантиссе ровно один разряд в целой час-
ти, он отличен от нуля, а порядок находится в допустимых пределах, опреде-
ляемых (ограниченной) разрядностью поля порядка.
Ненормализованное число может содержать в целой части мантиссы более
одного (или ни одного) разряда, отличного от нуля. Если выполнить опера-
цию нормализации, то оно, возможно, превратится в нормализованное. Такое
число часто (но не всегда) получается как результат выполнения операций
над числами ПТ.
Денормализованное число — это число, которое в данных разрядностях ман-
тиссы и порядка невозможно нормализовать (поскольку величина числа
слишком мала).
378 Приложения
ВА Ж Н О Е З А МЕ Ч А Н И Е 1
При нормализации, когда приходится сдвигать мантиссу вправо, возможна по-
теря точности при выходе младших битов мантиссы вправо за границу ее раз-
рядной сетки.
ВА Ж Н О Е З А МЕ Ч А Н И Е 2
Нормализация не всегда возможна, если при коррекции порядка происходит
выход за границу его разрядной сетки. Если число слишком велико, его просто
нельзя представить в выбранном формате ПТ (не хватает поля порядка). Если
число слишком мало, то его можно представить, но лишь в денормализованной
форме.
НЕ О Ч Е НЬ В А Ж Н О Е З А МЕ Ч А Н И Е
Кодовые комбинации, соответствующие ненормализованным числам, не ис-
пользуются для внешнего представления результатов действий (но получаются
в ходе выполнения действий).
Нормализация нужна для представления мантиссы с максимально возможной
в выбранной разрядной сетке точностью. Неявный бит возможен только
в нормализованном представлении.
Действия с числами ПТ
Рассмотрим особенности выполнения действий в формате ПТ, вызванные
ограниченностью разрядной сетки для представления мантиссы и порядка.
Последующие примеры выполняются в десятичной системе счисления. Для
обозримости чисел в примерах использована разрядная сетка, в которой ман-
тисса имеет четыре десятичных разряда, а для порядка отведен лишь один
десятичный разряд.
Для сложения/вычитания чисел ПТ следует:
1) Выровнять порядки.
2) Сложить/вычесть мантиссы.
3) Нормализовать результат (если необходимо).
Пример выполнения операции сложения в формате ПТ представлен на рис. П1.3.
При выравнивании порядков и при нормализации результата произошла по-
теря точности из-за того, что некоторые значащие цифры не помещаются
в выбранную разрядную сетку. При выполнении сложения мантисс результат
выходит за выбранную разрядную сетку влево. Чтобы можно было выпол-
нить это действие без потери левой значащей цифры, вычислитель ПТ дол-
жен иметь более широкую внутреннюю разрядность. Кроме того, это вызы-
вает необходимость последующей нормализации результата.
Приложение 1. Представление данных 379
9.876∗102 + 5.432∗101 = 9.876 ∗102 +
+ 0.543 2 ∗102 = ← выравнивание порядков – денормализация
произошла потеря точности
= 1 0.419 2 ∗102 = ← результат ненормализованный
= 1.041 92 ∗103 = ← результат нормализован, снова потеря точности
= 1.042 ← результат после округления
границы выбранной разрядной сетки
Рис. П1.3
Пример выполнения вычитания приведен на рис. П1.4. При выравнивании
порядков и здесь происходит потеря точности — значащая цифра выходит за
границу выбранной разрядной сетки. Однако если вычислитель ПТ имеет
более широкую внутреннюю разрядность, то младшие разряды при
нормализации могут "вернуться".
1.003∗10-8 - 9.982∗10-9 = 1.003 ∗10-8 -
- 0.998 2 ∗10-8 = ← выравнивание порядков – денормализация
произошла потеря точности
= 0.004 8 ∗10-8 = ← результат ненормализованный
= 0.048 ∗10-9 = ← результат не удается нормализовать, т. к.
порядок достиг предельного значения
в выбранной разрядной сетке
границы выбранной разрядной сетки мантиссы
Рис. П1.4
Для умножения (деления) чисел в формате ПТ следует:
1. Перемножить (поделить) мантиссы.
2. Сложить (вычесть) порядки.
Пример выполнения умножения чисел ПТ приведен на рис. П1.5. В данном
примере сомножители имеют такие (большие) значения, что результат не
удается нормализовать, этому препятствует достигший своего наибольшего
значения порядок. Это означает, что произошло арифметическое переполне-
ние, результат невозможно выразить в выбранной разрядной сетке.
И наконец, рассмотрим два примера деления чисел ПТ (рис. П1.6).
В случае а) порядок ненормализованного результата деления находится в до-
пустимых пределах, но его невозможно нормализовать, поскольку значение
порядка — минимально возможное в выбранной разрядной сетке.
380 Приложения
(5.500∗104)∗(2.000∗105)=1 1.000 ∗109 ← результат ненормализованный
и нормализовать его невозможно, т. к.
порядок достиг наибольшего возможного значения
в выбранной разрядной сетке
границы выбранной разрядной сетки мантиссы
Рис. П1.5
а)
(3.300∗10-7)/(6.600∗102)= 0.500 ∗10-9 ← результат ненормализованный
и нормализовать его невозможно.
б)
(3.300∗10-7)/(6.600∗102)= 0.500 ∗10-13= ← результат ненормализованный
= 0.000 05∗10-9 ← нормализованный результат не равен нулю,
но настолько мал, что поле мантиссы не содержит
ненулевых цифр (псевдонуль)
границы выбранной разрядной сетки мантиссы
Рис. П1.6
В случае б) результат деления также получается ненормализованным, при этом
значение порядка имеет недопустимое в данной разрядной сетке значение –13.
Результат деления можно нормализовать, но в ходе нормализации сдвиг ман-
тиссы вправо приводит к выходу всех ее ненулевых разрядов за границу раз-
рядной сетки. Такой (ненулевой) результат невозможно изобразить в выбран-
ной разрядной сетке как отличный от нуля. Подобный результат операции ПТ
в ограниченной разрядной сетке называют термином псевдонуль.
П1.11.2. Форматы представления чисел ПТ
двоичным кодом
Знак числа, поле порядка и поле мантиссы располагаются в двоичном коде
числа следующим образом:
Знак
Порядок
в формате
со смещением
Мантисса
всегда в прямом коде
(с опущенным неявным битом)
Знак относится ко всему числу.
Поле порядка содержит сумму истинного порядка и константы, называемой
смещением.
Приложение 1. Представление данных 381
Поле мантиссы содержит ее значение в прямом (не в дополнительном) коде
с опущенным неявным битом.
До 1985 года на разных вычислительных платформах использовали форматы
плавающей точки с разными размерами полей. Основной недостаток такой
ситуации состоял в том, что при вычислениях на разных компьютерах сте-
пень потери точности была различной. Как следствие, одна и та же програм-
ма на одном компьютере (с большой длиной полей чисел ПТ) давала резуль-
тат с малой (допустимой) ошибкой. На других машинах (где длина полей
чисел ПТ была меньше) ошибка была недопустимо большой. Наконец, на
третьих ЭВМ (длины полей еще короче) программа могла аварийно остано-
виться, в частности — из-за возникновения нуля в знаменателе выражения,
который вычислялся как малая разность больших чисел (например, при ре-
шении систем линейных уравнений).
Такая неодинаковость результатов была совершенно недопустимой, и в 1985 го-
ду в США был принят стандарт на форматы чисел с плавающей точкой, ко-
торому с тех пор следуют все разработчики вычислителей ПТ (реализован-
ных как аппаратно, так и программно).
При выборе формата плавающей точки разработчики стандарта выбирали:
􀂈 разрядность мантиссы и порядка;
􀂈 формат (с явным или неявным битом);
􀂈 вид нормализованного представления;
􀂈 величину смещения при изображении порядка;
􀂈 расположение полей в коде числа с плавающей точкой (оно выбрано та-
ким, как указано в разд. П1.11.2).
П1.11.3. Стандарт на числа ПТ ANSI/IEEE 754-1985
Стандарт предусматривает три формата чисел ПТ (табл. П1.7):
􀂈 короткое вещественное (КВ) — соответствует типу float языка Си;
􀂈 длинное вещественное (ДВ) — соответствует типу double языка Си;
􀂈 временное вещественное (ВВ).
Формат временного вещественного (ВВ) стандарт предписывает использо-
вать только внутри вычислителей с плавающей точкой (реализованных как
аппаратно, так и программно). Параметры временного вещественного выбра-
ны так, чтобы при действиях в этом формате величина ошибок округления,
возникающих при нормализации результатов операций, не превышала раз-
решающей способности формата длинного вещественного.
382 Приложения
Таблица П1.7. Форматы чисел ПТ в стандарте ANSI/IEEE 754-1985
Русское
наименование
формата
Короткое
вещественное (КВ)
Длинное
вещественное (ДВ)
-
Временное
вещественное (ВВ)
Английское
наименование
Short Real (SR) Long Real (LR) Temporary Real (TR)
Всего битов
(байтов)
32 (4) 64 (8) 80 (10)
Поле порядка
(битов)
8 11 15
Смещение
порядка
2
7
– 1 = 127 2
10
– 1 = 1023 2
14
– 1 = 16383
Диапазон
десятичных
порядков
–37 ÷ +38 –307 ÷ +308 –4931 ÷ +4932
Поле мантиссы
(битов)
23 52 64
Точных
значащих
десятичных
цифр
6 15 19
Неявный бит Опущен Опущен Изображается
После того как выражение вычислено, перед присваиванием его переменной
(в зависимости от ее типа) результат вычисления преобразуется в float либо
в double. При этом преобразовании всегда происходит потеря точности из-за
округления.
В соответствии со стандартом ANSI/IEEE 754-1985 предусмотрено четыре
типа (правила) округления:
􀂈 к ближайшему значению (по школьным правилам округления);
􀂈 по направлению к +∞ (с избытком);
􀂈 по направлению к -∞ (с недостатком);
􀂈 по направлению к 0 (усечение, т. е. просто отбрасывание лишних разрядов —
выполняется легко и быстро).
Программист уровня Ассемблера имеет возможность выбрать (включить)
нужный режим округления путем изменения двухбитового поля в одном из
Приложение 1. Представление данных 383
управляющих регистров сопроцессора. Выбор подходящего режима округле-
ния позволяет в некоторых случаях минимизировать ошибки, возникающие
при программировании численных методов в вычислительной математике.
Обратите внимание на количество десятичных разрядов, с которым пред-
ставляет результаты программа "Калькулятор" ОС MS Windows. Оно равно
32 (а не 15, как можно было бы заключить из данных таблицы). Этот пример
демонстрирует возможность программной организации вычислений с повы-
шенной разрядностью и для форматов плавающей точки.
ВА Ж Н Е ЙШ Е Е З А МЕ Ч А Н И Е
После того как программа оттранслирована (и, возможно, загружена в память),
нет никакой возможности достоверно определить, глядя в определенные адреса
памяти, что расположено по этим адресам: машинная команда, целое число, зна-
ковое или беззнаковое, число ПТ, текстовая строка или что-то еще. Выбрав соот-
ветствующие опции трансляции, можно включить в исполняемый файл отладоч-
ную информацию (целесообразно делать на этапе отладки). Однако после того
как программа отлажена, такую информацию обычно удаляют из исполняемого
файла. Почему же процессор догадывается, как следует правильно выполнять
программу? А потому что компилятор (на этапе трансляции, когда у него были
описания для каждого элемента данных) индивидуально в каждой команде уста-
новил правильное соответствие между кодом операции и местоположением опе-
рандов — только эта информация и содержится в командах.
В заключение рассмотрим пример представления числа в формате с плаваю-
щей точкой.
Представим величину 13,375 в формате короткого вещественного (float).
(13,375 = 13 + 3/8 = 8 +4 +1 + ¼ +1/8 = 23 + 22 + 20 + 2–2 + 2–3)(10) =
= (01101.0110 = 1.101011 * 10011)(2)
Исходное число представлено суммой степеней двойки, а затем переведено
в двоичную систему и нормализовано.
Значение поля знака (один бит) равно 0 (т. е. знак плюс).
Значение поля порядка (восемь битов) равно сумме истинного порядка +
смещение:
011 + 1111111 = 10000010
Мантисса равна 1.101011
Старший (скрытый) бит в мантиссе не изображается, поле мантиссы (23 би-
та) равно:
1010110 00000000 00000000
Таким образом, код величины 13.375 в формате float имеет вид (длина
4 байта):
0 10000010 10101100000000000000000(2) = 0x41560000(16)
384 Приложения
Поля знака, порядка и мантиссы в предыдущей строке разделены пробелами,
байты выделены подчеркиванием.
П1.12. О понятии старшинства
арифметических типов данных
В разных частях этой книги используется словосочетание "привести к стар-
шему типу" применительно к арифметическим типам. В понятие старшинст-
ва вкладывается следующий смысл: если диапазон значений, которые может
принимать переменная одного типа, целиком содержится в диапазоне значе-
ний, которые может принимать переменная второго типа, то второй тип счи-
тается старшим по отношению к первому. Иными словами, это означает, что
любое значение переменной младшего типа может быть представлено с по-
мощью переменной старшего типа.
Отметим некоторые особенности этого соотношения:
􀂈 любой знаковый тип не может быть младше любого беззнакового типа,
т. к. в беззнаковом типе невозможно представить отрицательные значения;
􀂈 знаковые и беззнаковые типы одной длины не могут находиться в отно-
шении "младший → старший";
􀂈 любой плавающий тип всегда старше любого целого типа. Однако значе-
ния целого типа могут представляться плавающим типом как совершенно
точно, так и с небольшой ошибкой округления. Последнее происходит,
если длина значащей части целого типа (без учета знакового бита) больше
длины мантиссы плавающего типа (с учетом неявного бита).
Если старшинство определено таким образом, то все преобразования ариф-
метических типов можно разбить на три группы:
􀂈 преобразование типа возможно выполнить без ошибки при любом значе-
нии переменной исходного типа;
􀂈 при выполнении преобразования типа результирующее значение с пла-
вающей точкой формируется с (незначительной) ошибкой округления;
􀂈 преобразование типа может дать грубую ошибку для части значений пе-
ременной исходного типа, поэтому оно не всегда допустимо и требует от
программиста дополнительной проверки на возможность преобразования.
На рис. П1.7 изображены отношения старшинства между различными ариф-
метическими типами.
Буквой u обозначены беззнаковые целые типы, буквой s — целые типы со
знаком. Число после буквы обозначает количество значащих двоичных цифр
в числе (без учета знакового бита).
Приложение 1. Представление данных 385
Рис. П1.7
Таким образом:
u8 — unsigned char,
u16 — unsigned short,
u32 — unsigned long,
u64 — unsigned long long,
s7 — signed char,
s15 — signed short,
s31 — signed long,
s63 — signed long long.
Буквы F, D, T обозначают соответственно плавающие типы float (4 байта),
double (8 байтов) и внутреннее представление чисел ПТ Temporary Real
(10 байтов). Числа в этих обозначениях показывают количество эффективных
значащих битов в мантиссе.
Отношения "младший → старший" показаны на рисунке стрелками, причем
сплошные стрелки отмечают преобразования типов, которые выполняются
без ошибки (группа 1), а пунктирные стрелки соответствуют преобразовани-
ям группы 2, при которых возможно возникновение ошибок округления.
П1.13. Битовые поля и операции над ними
Как уже упоминалось, арифметико-логическое устройство многих процессо-
ров способно выполнять действия с операндами различной длины. В боль-
шинстве процессоров эти длины делают равными степени двойки: один, либо
386 Приложения
два, либо четыре, либо восемь байтов. Однако в практике программирования
нередки ситуации, когда длина информационного элемента не равна (не
кратна) одному байту. Приведем несколько примеров.
Пример 1.
Рассмотрим представление элемента растрового изображения (пиксела).
В одном из распространенных форматов кодирования пиксела (HighColor)
для представления интенсивностей трех цветовых компонент: красной (Red),
зеленой (Green) и синей (Blue) используются пятибитовые значения, пред-
ставляющие эти интенсивности в диапазоне от 0 до 25 – 1 = 31. Можно было
бы для хранения каждой из компонент занять один байт, и для модификации
отдельных цветовых компонент использовать команды процессора, опери-
рующие с байтом. Однако для экономии памяти, в которой хранится изобра-
жение, три цветовые компоненты R, G, B упаковываются в двухбайтовую пе-
ременную вот таким образом:
15 14 10 9 8 7 6 5 4 0 Номер бита
0 b b b b b g g g g g r r r r r Содержимое
При этом объем памяти для хранения изображения уменьшается в полтора
раза по сравнению с вариантом "один цвет в одном байте".
Такой вид данных, когда отдельные информационные элементы имеют размер,
не кратный одному байту и/или упакованы так, что границы этих элементов не
совпадают в памяти с границами байтов, принято называть битовыми полями
(Bit Fields). Для манипуляций с битовыми полями необходимо выполнять не-
которые специфические операции, о которых поговорим чуть позже при рас-
смотрении примера модификации пиксела изображения HighColor.
Пример 2.
Рассмотрим команду процессора.
В различных процессорах двоичные последовательности, кодирующие коман-
ды, могут иметь различную длину и внутреннюю структуру, но во всех сис-
темах в процессорных командах может быть закодировано:
􀂈 операция, которую следует выполнить;
􀂈 длина операндов;
􀂈 месторасположение операндов (в памяти или в регистрах процессора);
􀂈 регистры;
􀂈 многие другие свойства и особенности команды.
Приложение 1. Представление данных 387
Для кодирования каждого из этих свойств в коде команды используется ров-
но столько битов, сколько требуется для того, чтобы длина команды была
минимальной. Например, в процессоре, содержащем шестнадцать регистров
общего назначения, для указания регистра достаточно четырех битов.
Последовательность процессорных команд может быть результатом работы
транслятора, т. е. теми выходными данными, которые генерирует транслятор.
Для того чтобы сформировать процессорную команду, транслятору требуется
определить значения отдельных полей команды, а затем скомпоновать эти
поля в один (возможно, многобайтовый) элемент.
Пример 3.
Рассмотрим содержимое управляющего регистра периферийного устройства.
Для управления периферийным устройством в состав его регистров часто
входит такой регистр, в котором отдельные комбинации битов позволяют
программисту независимо задавать различные режимы работы устройства.
Например, в состав любого персонального компьютера входит трехканаль-
ный интервальный программируемый таймер, его регистр управления имеет
длину в один байт, в котором содержатся следующие битовые поля:
􀂈 бит 0 — режим счета (двоичный либо двоично-десятичный);
􀂈 биты 1…3 — режим работы (три бита используются для указания одного
из шести режимов);
􀂈 биты 4…5 — выбор операции (два бита кодируют одну из четырех опе-
раций);
􀂈 биты 6…7 — выбор канала таймера (одного из трех).
Для управления работой таймера иногда может потребоваться изменить
только некоторые поля регистра управления, оставив прочие биты неизмен-
ными. Конечно, можно при каждом управляющем воздействии записывать
целиком весь байт, но в этом случае придется хранить в дополнительной пе-
ременной копию его содержимого.
Пример 4.
Теперь рассмотрим, какова может быть последовательность действий, позво-
ляющая изменить некоторые части (битовые поля) в операнде, гарантирован-
но оставив прочие биты операнда неизменными. Сделаем это на примере ре-
дактирования пиксела изображения HighColor, формат которого только что
был рассмотрен.
Предположим, что требуется изменить значение одной из цветовых компо-
нент (например, увеличить яркость зеленой составляющей пиксела G на за-
388 Приложения
данную величину d), для этого нужно выполнить последовательность дей-
ствий:
1. Вырезать из двухбайтового пиксела участок, соответствующий зеленому
цвету (биты с 5 по 9):
0bbbbbgggggrrrrr — исходный пиксел,
000000ggggg00000 — после вырезания.
2. Переместить вырезанное значение в разрядной сетке так, чтобы оно ока-
залось в младших позициях разрядной сетки, и его величина находилась
бы в разрешенном диапазоне значений от 0 до 31:
00000000000ggggg — после сдвига.
3. Теперь можно выполнить модификацию значения цвета, т. е. сложение
(G + d), при этом сложении возможно переполнение и выход результата за
пределы отведенной для цветовой компоненты пятибитовой разрядной
сетки. Если это произойдет, то целесообразно в качестве результата взять
максимальное разрешенное для цветовой компоненты значение, т. е. 31:
00000000000ggggg — после сложения.
4. Переместить модифицированное значение цветовой компоненты, чтобы
она заняла отведенное ей место в двухбайтовой разрядной сетке:
000000ggggg00000 — после перемещения.
5. Подготовить (обнулить) место для компоненты в двухбайтовом пикселе.
6. Вставить модифицированное значение цвета в двухбайтовый пиксел так,
чтобы остальные его биты остались неизмененными:
0bbbbbgggggrrrrr — после вставки получили модифицированное значение
пиксела изображения, в котором цветовая компонента G изменена, а ком-
поненты R и B оставлены неизменными.
Для того чтобы стало возможным выполнять действия, выделенные курсивом
в пунктах 1, 2, 4, 5, в состав системы команд процессора вводят команды,
которые позволяют выполнять следующие действия с операндом:
а) очистка заданных программистом битов в операнде, что позволит в п. 1
очистить те биты, которые соответствуют цветовым компонентам R и B,
а в п. 5 — биты, соответствующие модифицированной компоненте G;
б) установка заданных программистом битов операнда в 1;
в) инвертирование указанных битов в операнде;
г) сдвиг битов операнда в разрядной сетке на заданное количество позиций.
Приложение 1. Представление данных 389
Для выполнения пп. 1 и 3 в составе системы команд процессора имеются
двухоперандные команды, действие которых состоит в том, что каждый бит
операнда-приемника (результата операции) формируется из двух соответст-
вующих битов двух операндов-источников в соответствии с одной из трех
логических функций:
􀂈 AND (И);
􀂈 OR (ИЛИ);
􀂈 XOR (ИСКЛЮЧАЮЩЕЕ ИЛИ).
Для двух однобитовых аргументов возможны четыре комбинации: 00, 01, 10, 11.
Результат операции AND двух однобитовых аргументов равен единице только
если оба аргумента равны единице (один и второй). В остальных трех случа-
ях операция AND дает результат 0.
Побитовая операция AND предоставляет возможность очистить (установить
в 0) любую комбинацию битов в операнде. Для этого программист должен
сам сконструировать второй операнд (называемый обычно маской). Маска
должна содержать 1 в тех позициях, которые в первом операнде должны ос-
таться неизменными, и 0 — в тех позициях, которые должны быть очищены.
В рассмотренном только что примере действие а) можно выполнить с помо-
щью побитовой операции AND.
0bbbbbgggggrrrrr — исходный пиксел, выполняем побитовую операцию AND;
0000001111100000 — маска;
000000ggggg00000 — это результат побитовой операции AND.
Результат операции OR двух однобитовых аргументов равен:
􀂈 0 — только в случае, когда оба аргумента равны 0;
􀂈 1 — если хотя бы один из аргументов равен 1.
Побитовая операция OR позволяет установить произвольный набор битов
в операнде в 1. Для этого надо использовать второй операнд (маску), содер-
жащий 1 в тех позициях, которые хочется в первом операнде установить,
и 0 — в позициях, которые в первом операнде должны остаться неизменными.
Действие 5 в рассмотренном примере с модификацией цветовой компоненты
в пикселе можно выполнить в два шага: на первом очистить место под ком-
поненту G с помощью побитового AND, а затем вставить модифицированную
компоненту с помощью побитового OR:
0bbbbbgggggrrrrr — исходный пиксел.
AND
0111110000011111 — маска
390 Приложения
---------------------------
0bbbbb00000rrrrr — это результат побитовой операции AND, освободили
место для компоненты G;
OR
000000ggggg00000 — модифицированный пиксел, полученный на шаге (4)
---------------------------
0bbbbbgggggrrrrr — и вот он, искомый результат.
Результат операции XOR равен 1, если значения двух битов-аргументов различ-
ны. Несложно убедиться в том, что с помощью XOR можно проинвертировать
те биты операнда, которым соответствуют единицы во втором аргументе-
маске.
В наборе команд процессора обычно имеется также однооперандная команда
NOT, действие которой состоит в инвертировании (замене на противополож-
ное значение) всех битов операнда.
П1.13.1. Подробнее об операциях сдвига
Для перемещения положения битов в разрядной сетке, в состав системы ко-
манд процессора вводят команды сдвига. При сдвиге операнда крайние биты
выдвигаются за границу разрядной сетки и одновременно с другого конца
разрядной сетки освобождаются позиции. Существуют несколько разновид-
ностей операций сдвига, которые различаются судьбой выдвигаемых битов
и освобождающихся позиций.
Логический сдвиг — самая простая разновидность (выдвигаемые за границу
разрядной сетки биты теряются безвозвратно, а позиции, освобождающиеся
с другого конца разрядной сетки, заполняются нулями).
Действие сдвига целочисленного операнда можно использовать для быстрого
умножения (при сдвиге влево) или для быстрого деления (при сдвиге вправо)
целочисленного операнда на степень основания системы счисления, т. е.
на 2n, где n — количество позиций, на которое осуществляется сдвиг операн-
да. Смысл замены настоящего умножения сдвигом заключается в том, что
в большинстве процессоров сдвиг операнда выполняется гораздо быстрее (за
меньшее количество тактов), нежели целочисленное умножение.
При сдвиге влево (т. е. при умножении на степень двойки) может использо-
ваться операция логического сдвига влево, независимо от того, является ли
операнд знаковым (представленным в дополнительном коде) или беззнаковым.
При использовании сдвига для быстрого деления (сдвиг вправо) операции
сдвига для знаковых и для беззнаковых целых различаются. При сдвиге
вправо целого со знаком, представленного дополнительным кодом, отрица-
Приложение 1. Представление данных 391
тельное число при делении на 2 формально должно остаться отрицательным,
т. е. знаковый (старший) бит должен сохранить свое значение. Такая разно-
видность сдвига вправо, при которой знаковый бит сохраняет свое значение,
носит название арифметического сдвига. В системах команд почти всех про-
цессоров реализована такая команда.
ЗАМЕ ЧАНИЕ
Можно говорить об операции арифметического сдвига влево, при которой
старший (знаковый) бит после сдвига также сохраняет свое значение. Однако
этого не делают, поскольку в отрицательном числе, представленном в допол-
нительном коде, старший знаковый бит равен единице, и при этом еще один
или несколько битов, смежных со старшим, также могут быть равны единице
(для чисел, не очень больших по модулю). При логическом сдвиге влево на
один разряд, модуль отрицательного числа удваивается. Если при очередном
сдвиге в знаковый разряд попадает значение 0, то формально результат поме-
няет знак. Это всего лишь означает, что этот очередной сдвиг (удвоение числа)
дал значение, слишком большое для представления в данной разрядной сетке,
т. е. произошло переполнение.
Если же сдвигаемый операнд беззнаковый, то освобождающиеся при сдвиге
слева позиции следует заполнять нулями, т. е. для деления сдвигом беззнако-
вого операнда следует использовать логический сдвиг вправо.
В языке Си имеются операторы сдвига операнда вправо и влево. Компилятор,
в зависимости от типа целочисленного операнда (со знаком или без знака),
использует подходящую команду сдвига — арифметический либо логиче-
ский сдвиг.
В системах команд процессоров существует еще одна разновидность сдвига —
циклический сдвиг. При выполнении этого действия биты, выдвигаемые с од-
ного конца разрядной сетки, заполняют позиции, освобождающиеся на другом
конце разрядной сетки, т. е. при циклическом сдвиге никакой потери битов
не происходит. При программировании на языке Си использование процес-
сорных команд циклического сдвига обычно невозможно.
Приложение 2
Язык Си и низкоуровневое
программирование
Что означает термин "низкоуровневое"? В данном и последующих контек-
стах этот термин почти всегда будет пониматься как "аппаратно-зависимое".
Классическая манера обучения программированию на языке Си (да и на дру-
гих языках высокого уровня) предполагает, что написанные фрагменты кода
будут одинаково работать на различных вычислительных системах (в том
смысле, что одинаковыми будут полученные результаты). Именно этот факт
имеют в виду, когда используют словосочетание язык высокого уровня. При
программировании вычислительных алгоритмов и обработки символьных
данных большей частью, так оно и получается.
Где встречается низкоуровневое программирование?
При разработке реальных (а не учебных) программ, в особенности для задач
управления объектами, разработчику весьма трудно удержаться в рамках
конструкций высокоуровневого языка и переносимого кода. Отдельные
фрагменты разрабатываемой программы оказываются аппаратно-зависимыми,
т. е. должны быть изменены при переносе такой программы на другую ВС.
Обычное решение этой проблемы состоит в том, что все аппаратно-
зависимые компоненты разрабатываются отдельно и заранее, часто входят
в состав используемого на данной ВС системного ПО (программного обеспе-
чения).
Однако в ряде случаев то, что требуется в конкретной задаче, либо реализо-
вано в системном ПО, слишком универсально и, как следствие, недостаточно
эффективно либо вовсе отсутствует.
При разработке управляющих программ для микроконтроллеров (управ-
ляющих микроЭВМ) нередки случаи, когда ничего похожего на операци-
онную систему не используется, а программист сам пишет весь код от на-
чала и до конца. Тогда ему приходится самому разрабатывать и отлаживать
Приложение 2. Язык Си и низкоуровневое программирование 393
и все аппаратно-зависимые компоненты программы. Для этих целей обычно
использовался язык Ассемблера.
Но в последние десять лет место Ассемблера все чаще стали занимать языки
высокого уровня (и в частности, язык Си). Широкому распространению язы-
ка Си способствует тот факт, что разработаны качественные компиляторы Си
для многих и многих типов управляющих микросистем.
Сейчас было рассказано о причинах, заставляющих программистов иногда
использовать возможности аппаратного уровня для повышения эффективно-
сти разрабатываемой программы. В последующих разделах будут обсуждать-
ся ситуации, в которых приходится использовать низкоуровневые возможно-
сти и соответствующие приемы. Для чтения дальнейшего текста необходимо
понимать значение ряда терминов, относящихся к аппаратному уровню орга-
низации процессоров. Однако подавляющее большинство начинающих изучать
программирование на языке Си имеют весьма смутное понятие об устройстве
аппаратного уровня цифровых процессоров. Да и многие профессиональные
программисты также представляют себе это устройство не в полной мере. По-
этому автор счел необходимым объяснить значения используемых терминов
именно здесь, в основном тексте. Читателю настоятельно рекомендуется хотя
бы бегло просмотреть эти объяснения вне зависимости от его уровня подго-
товки.
Глоссарий.
1. Адрес ячейки в памяти — индивидуальный признак ячейки памяти, це-
лое число, которое используется при организации доступа к информаци-
онному элементу, расположенному в памяти. Если элемент занимает в па-
мяти более одной ячейки, то его адресом считается наименьший из
адресов, занимаемых этим информационным элементом.
2. Адресное пространство — одно из основных логических понятий архи-
тектуры цифровых процессоров. Предполагается, что множество элемен-
тарных ячеек памяти (видимых) включено в адресное пространство, каж-
дая ячейка имеет индивидуальный идентификатор, представляющий
собой целое число и называемое адресом этой ячейки в данном адресном
пространстве.
3. Арифметико-логическое устройство (АЛУ) — узел процессора, кото-
рый выполняет с операндами действия, меняющие их значение: сложение,
сдвиг и т. п. Обычно предполагается, что АЛУ не содержит в своем соста-
ве элементов памяти, т. е. является комбинационным логическим узлом.
4. Биты признаков — биты, содержащиеся в регистре состояния процессо-
ра (то же самое, что флаги). АЛУ при выполнении процессорной команды
394 Приложения
может изменять значения отдельных битов признаков в зависимости от
свойств получившегося результата. Стандартный набор включает четыре
бита признаков:
• признак нулевого результата (Z , zf — Zero);
• признак отрицательного результата (N — Negative, sf — sign flag);
• признак переноса или беззнакового переполнения (C — carry, cf —
carry flag);
• признак знакового переполнения (V или of — OVerflow).
В зависимости от значений битов признаков, команды с условным испол-
нением либо выполняют действие, либо ведут себя как пустая команда.
5. Блок адресной арифметики — узел процессора, выполняющий вычис-
ление адреса операнда, алгоритм этого вычисления зависит от исполь-
зуемого в этой команде способа адресации.
6. Дешифратор — узел процессора, выполняющий дешифрацию (декоди-
рование) кода процессорных команд и формирующий управляющие сиг-
налы для АЛУ и для блока адресной арифметики.
7. Косвенно-регистровая адресация — способ адресации, при котором
адрес операнда в памяти указывается содержимым одного из регистров
процессора. Модифицируя содержимое этого регистра другими коман-
дами, можно добиться того, что одна и та же команда (повторяемая
в цикле) будет выполнять действия с различными операндами в памяти.
8. Кэш-память — память малого объема с быстродействием, равным или
близким к быстродействию процессора.
9. Логический адрес — целое число, определяющее положение информа-
ционного элемента в адресном пространстве. Логические адреса форми-
руются в ходе выполнения процессорных команд. Для обращения к ячей-
кам реальной (физической) памяти логические адреса преобразуются
в физические в ходе трансляции адресов.
10. Машинное слово — максимальный размер операнда, с которым способ-
ны выполнять действия большинство процессорных команд. Чаще всего
этот размер совпадает с размером регистров процессора.
11. Минимальная адресуемая единица (МАЕ) — размер элементарной
ячейки адресуемой памяти, имеющей индивидуальный адрес. Для боль-
шинства процессоров МАЕ равно 8 битам (одному байту).
12. Многокомпонентная адресация — способ адресации, при котором блок
адресной арифметики (по окончании декодирования команды) вычисляет
Приложение 2. Язык Си и низкоуровневое программирование 395
адрес операнда в основной памяти, с помощью действий над несколькими
компонентами. Компоненты могут быть расположены либо в регистрах
(как при регистровой адресации), либо в коде команды (как при прямой
адресации). Чаще всего адрес вычисляется как сумма этих компонент.
Использование многокомпонентной адресации усложняет схемотехнику
декодирования и адресной арифметики, но позволяет уменьшить количест-
во команд, которые предназначены для модификации адресов операндов.
13. Непосредственная адресация — способ адресации, при котором опе-
ранд помещается прямо в код процессорной команды. Способ удобен,
если значение операнда фиксировано и известно уже на этапе трансляции
(например, количество повторений в операторе цикла).
14. Основная память или оперативное запоминающее устройство
(ОЗУ) — блок, который наряду с процессором имеется в любом универ-
сальном цифровом вычислителе с хранимой программой. Основная па-
мять имеет адресную организацию.
15. Обработчик (подпрограмма обработки) прерывания — подпрограмма,
которая автоматически вызывается при возникновении сигнала запроса на
входе запроса прерывания процессора. При входе в обработчик происходит
автоматическое запоминание содержимого некоторых регистров процессо-
ра (обязательно счетчика команд, т. е. адреса возврата, и регистра состоя-
ний, который содержит биты признаков и некоторые управляющие биты).
При возврате из обработчика в эти регистры автоматически восстанавли-
ваются значения, бывшие там перед входом в обработчик.
16. Прямая адресация — способ адресации, при котором адрес операнда вхо-
дит в состав кода команды. Способ удобен, если адрес известен уже на эта-
пе трансляции, а в ходе выполнения программы его не требуется изменять
(например, при обращении к регистрам периферийных устройств, каждый
из них расположен по фиксированному и известному адресу).
17. Регистр — узел процессора, предназначенный для хранения двоичного
слова. Регистр характеризуется количеством двоичных разрядов. Длина
регистров в цифровом процессоре связана с другими характеристиками
процессора: длиной машинного слова (АЛУ и регистры данных), разме-
ром адресного пространства (разрядность адресных регистров и схемы
формирования физического адреса).
18. Регистр состояния — регистр, который содержит флаги, сигнализи-
рующие о состоянии устройства. Регистр состояния процессора обычно
содержит биты признаков, биты управления прерываниями процессора,
а также (может быть) и другие управляющие биты. Регистр состояния
396 Приложения
периферийного устройства может содержать биты или битовые поля, ко-
торые показывают состояние этого ПУ (например, готовность к обмену
с другим устройством).
19. Регистровая модель устройства — перечень регистров, которые дос-
тупны программисту для анализа (при доступе по чтению) и/или для из-
менения (при доступе по записи). При низкоуровневом программирова-
нии необходимо иметь полное представление о регистровой модели
устройства. Регистровая модель процессора минимально включает в свой
состав счетчик команд, указатель стека, регистр состояния, регистры
операндов (как минимум, один), адресные регистры (как минимум, один).
Во многих (но не во всех) процессорах регистры операндов могут быть
универсальными, т. е. их разрешается использовать и для адресов. В этом
случае для них может быть использовано название "регистры общего на-
значения". Регистровая модель периферийного устройства в минималь-
ном варианте содержит регистр данных и регистр состояния.
20. Способ адресации — схема (алгоритм), используемая в процессорной
команде с обращением к памяти для определения адреса операнда в ос-
новной памяти. Различные процессоры могут использовать от двух/трех
до нескольких десятков различных способов адресации.
21. Стек — участок памяти, к которому организуется стековый доступ. Это
может быть сделано как чисто программно (используя косвенно-
регистровую адресацию с автоматической модификацией адресного ре-
гистра), так и аппаратно, когда для формирования адресов используется
специальный регистр — указатель стека, а для их автоматической моди-
фикации — специальная схемотехника, изменяющая содержимое указа-
теля стека при каждом обращении.
22. Стековый доступ к памяти — способ организации записи или считыва-
ния последовательности информационных элементов, при котором об-
ращение происходит подряд по порядку следования адресов. При этом
обычно все информационные элементы имеют одинаковую длину (эле-
мента стека). Если запись осуществляется по порядку убывания адресов,
то считывание происходит в обратную сторону — по возрастанию адре-
сов. При такой организации реализуется правило: последним записан –
первым прочитан. Как правило, стековый доступ к памяти поддерживает-
ся в процессоре аппаратно. Для формирования адресов, по которым вы-
полняются обращения, используется специальный регистр — указатель
стека, причем после каждого обращения содержимое этого регистра ав-
томатически (аппаратно) изменяется на длину элемента стека. Длина
элемента стека в процессорах обычно равна длине машинного слова. По-
Приложение 2. Язык Си и низкоуровневое программирование 397
рядок обращения к стеку в разных процессорах может отличаться: а) на-
правлением роста стека, т. е. направлением перебора адресов при запи-
си/чтении; б) порядком действий "запись в стек" — автомодификация
указателя стека. Наиболее распространен вариант, когда: а) стек растет
в сторону уменьшения адресов, т. е. запись по убыванию адресов, а чте-
ние — по возрастанию; б) сначала декремент указателя стека, а затем
запись, т. е. указатель стека всегда содержит адрес последнего занятого
элемента. При считывании порядок обязательно обратный: сначала счи-
тывание, а затем инкремент указателя стека.
23. Счетчик (указатель) команд — регистр процессора, который содержит
(почти в любой момент времени) адрес памяти, с которого расположена
следующая, еще не начавшая выполнение команда. После окончания вы-
борки команды схемотехника процессора автоматически модифицирует
содержимое указателя команд так, чтобы он указывал на следующую
команду.
24. Трансляция адресов — процедура отображения логических (виртуаль-
ных) адресов, формируемых в ходе выполнения команд конкретной про-
граммы в физические адреса. Трансляция адреса выполняется блоком
формирования адресов, входящим в состав процессора. В простых про-
цессорах трансляция адреса может быть вырожденной в простое тожде-
ство (физический адрес совпадает с логическим).
25. Указатель стека — специализированный регистр процессора, исполь-
зуемый для организации стекового доступа к участку основной памяти,
используемому в качестве стека.
26. Управляющие биты в регистре состояния — позволяют выполнять пе-
реключения режимов. Для процессора — в первую очередь разрешать
либо запрещать реагировать на запросы аппаратных прерываний.
27. Физический адрес — номер ячейки памяти в физическом адресном про-
странстве.
28. Физическое адресное пространство — система нумерации ячеек в ре-
альных модулях памяти, которые могут быть установлены в вычисли-
тельной системе. В конкретной реализации ВС объем реально установ-
ленной памяти не может превышать размера физического адресного
пространства.
29. Флаги — отдельные биты в регистре состояния, сигнализирующие о со-
стоянии устройства. В регистре состояния процессора флаги — это то же,
что и биты признаков, они сигнализируют о свойствах результата одной
из недавно выполненных процессором команд.
398 Приложения
П2.1. Низкоуровневая (регистровая) модель
вычислительного ядра
Цифровой универсальный процессор содержит в своем составе некоторое
количество регистров, каждый из которых способен хранить двоичное слово.
Разрядности этих регистров чаще всего одинаковы, именно их имеют в виду,
когда говорят о разрядности процессора. Когда употребляют термин "регист-
ровая модель процессора", то имеют в виду все те регистры, которые про-
граммно доступны при использовании процессорных команд (т. е. для про-
граммиста на Ассемблере).
Минимальный состав регистровой модели включает в себя:
􀂈 счетчик команд;
􀂈 регистр состояний;
􀂈 указатель стека;
􀂈 регистр адресный (указатель);
􀂈 регистр данных (аккумулятор).
В более сложных процессорах регистров адресных и регистров данных мо-
жет быть более одного. Так, например, в процессорах семейства Intel x86 ре-
гистровая модель содержит счетчик команд, регистр состояний, указатель
стека и еще семь регистров общего назначения РОН (в каждом из РОН может
храниться операнд или адрес элемента в памяти — указатель). Все перечис-
ленные регистры имеют длину 4 байта (32 бита).
В любом процессоре, поддерживающем механизм аппаратных прерываний,
программисту необходимо разрешать/запрещать процессору реагировать на
запрос аппаратного прерывания. Обычно для этого служит один или несколько
битов (флагов, масок) в регистре состояния процессора. Помещение масок
прерываний в регистр состояния имеет глубокий смысл: при входе в подпро-
грамму обработки прерывания в большинстве процессоров автоматически
сохраняется не только адрес возврата (содержимое счетчика команд), но и со-
держимое регистра состояния (включающее биты признаков и значения ма-
сок прерываний). Последние отражают состояние процессора (какие преры-
вания были разрешены процессору перед входом в прерывание).
После завершения подпрограммы обработки прерывания сохраненные значе-
ния автоматически возвращаются в регистр состояния, восстанавливая тот
режим, который был перед входом в обработчик.
В более сложных процессорах возможно (и нередко необходимо) выполнять
еще ряд управляющих (настроечных) операций. Если таких операций немного,
Приложение 2. Язык Си и низкоуровневое программирование 399
то управление ими может быть организовано через дополнительные битовые
поля в регистре состояний. При большом количестве настроек управление
может осуществляться через один или несколько системных управляющих
регистров, запись в которые определенных кодовых комбинаций позволяет
выполнять требуемые настройки режимов процессора. Например, в процес-
сорах семейства x86 имеется более десятка системных регистров, для досту-
па к которым есть специальные команды.
Регистр состояния в некоторых архитектурах полностью доступен для чтения
и записи, как любой другой регистр, но в других процессорах доступ к реги-
стру состояния может быть в той или иной степени ограничен. Например,
в системе команд могут быть специальные команды, позволяющие изменять
содержимое некоторых полей (битов) в регистре состояния, в то время как
другие его поля будут недоступны для непосредственной записи/чтения.
В процессорах x86 счетчик команд является программно недоступным в том
смысле, что его нельзя использовать в ассемблерной команде в качестве опе-
ранда. Однако любая команда перехода (нарушающая естественный порядок
следования команд по адресам подряд) фактически выполняет засылку
в счетчик команд нового содержимого — адреса перехода. Чтение содержимо-
го счетчика команд в процессорах х86 напрямую невозможно, но может быть
выполнено последовательностью из нескольких команд.
П2.1.1. Оптимизация фрагмента кода по скорости
Обращение к регистрам в персональном компьютере обычно занимает на по-
рядок меньше времени, нежели обращение к элементам в адресуемой памяти.
Один из путей оптимизации программы может состоять в том, что часто (ин-
тенсивно) используемые переменные лучше располагать в регистрах.
ЗАМЕ ЧАНИЕ
В однокристальных микроконтроллерах для управляющих (встраиваемых) при-
менений, внутрикристальная память с адресной организацией выполняется по
той же технологии, что и процессор, и имеет то же быстродействие. Поэтому
перенос переменных в регистры может и не дать выигрыша.
Если программируем на языке высокого уровня, то использование тех или
иных регистров для различных целей находится в ведении компилятора (и он
может это делать с большей либо с меньшей эффективностью).
Иногда программисту хочется принудительно поместить переменную в ре-
гистр.
В стандарте языка Си имеется ключевое слово register, применив которое
в объявлении переменной (обычно локальной), программист может предла-
400 Приложения
гать компилятору использовать один из регистров для хранения этой пере-
менной.
В некоторых компиляторах возможность указания использовать определен-
ный регистр отсутствует (например, среда MS Visual Studio). В этом случае
компилятор сам решает, какой из регистров подойдет для переменной. При
этом у компилятора может и не оказаться такой возможности (нет свободных
регистров).
В некоторых средах разработки компилятор понимает предопределенные
имена т. н. псевдопеременных, соответствующих регистрам процессора. На-
пример, в среде Borland C 3.1 регистры 16-разрядной архитектуры 8086 име-
ют имена: _AX, _BX, _CX, _DX, _SI, _DI, _BP, _SP.
В строке Си-программы разрешается запись вида:
var=_AX;
или
_DX= var;
Такая запись позволяет выполнять операции с регистрами без формального
использования ассемблерных вставок.
Среда разработки Borland C 3.1 и ее средства трансляции по сей день исполь-
зуются для программирования процессоров с 16-разрядной архитектурой
8086 в управляющих встраиваемых системах.
Обратите внимание на то, что если компилятор связал имя переменной и ре-
гистр, то он будет избегать использования этого регистра при компиляции
соседних операторов. Поэтому целесообразно обращаться к регистрам только
для локальных переменных с коротким временем жизни и с ограниченной
областью видимости. Вне областей видимости и существования регистр сво-
боден для использования компилятором.
В других реализациях программист может сам выбрать для хранения локаль-
ной переменной один из регистров и указать его компилятору. Такую воз-
можность предоставляет компилятор GCC фирмы RedHat.
Бывают ситуации, в которых, наоборот, необходима гарантия того, что ком-
пилятор не будет использовать регистр для хранения значения какого-либо
программного объекта. Это необходимо делать, в частности, при чтении со-
держимого регистров периферийных устройств, поскольку содержимое этих
регистров может быть изменено аппаратно в любой момент.
В таком случае следует использовать ключевое слово volatile при объявле-
нии переменной — в результате компилятор будет при каждом обращении
к этому элементу выполнять чтение непосредственно самого элемента, ука-
занного в исходном тексте программы.
Приложение 2. Язык Си и низкоуровневое программирование 401
П2.1.2. Определение положения программы
в пространстве адресов
Зачем может понадобиться доступ к счетчику команд по чтению?
Иногда возникает потребность выяснить из программы, в каких адресах она
расположена. Это легко сделать, если счетчик команд доступен по чтению,
тогда можно просто скопировать его содержимое в переменную.
В некоторых архитектурах (например, в x86) счетчик команд программно
недоступен. Но его содержимое, тем не менее, можно получить, выполнив
команду вызова подпрограммы, а затем — прочитав адрес возврата из того
места, где он был сохранен (обычно это стек). Доступ к элементам стека
можно организовать через указатель. Для инициализации этого указателя на-
до прочитать содержимое регистра — указателя стека, а вот для этого уже
придется использовать ассемблерные команды.
Чтобы контролировать состояние стека, можно периодически (или в тех мес-
тах программы, где возникают опасения) сравнивать содержимое указателя
стека с известными граничными значениями. Для этого необходимо иметь
возможность прочитать содержимое указателя стека в переменную, а это
можно сделать, только используя ассемблерные команды.
Чтобы можно было выполнять действия с содержимым управляющих (сис-
темных) регистров, надо иметь возможность инициировать выполнение про-
цессорных команд чтения/записи этих регистров. А это обычно можно сделать,
только используя средства уровня процессорных команд (Ассемблера).
П2.1.3. Использование средств уровня языка
Ассемблера в программах на Си
Почти все современные среды программирования (компиляторы) позволяют
делать ассемблерные вставки в исходный код программы на Си. На практике
это чаще всего означает, что компилятор выполняет трансляцию с языка Си
в язык Ассемблера, а затем вызывает для дальнейшей трансляции Ассемблер
(так, например, делает наиболее популярный транслятор для программ ре-
ального режима процессоров x86 из среды Borland C3.1).
В среде Visual Studio ассемблерная вставка выглядит следующим образом:
__asm команда_Ассемблера;
или
__asm { команда_Ассемблера
команда_Ассемблера
402 Приложения
... ...
команда_Ассемблера
}
В качестве примера использования ассемблерных команд при программиро-
вании для процессоров семейства x86 Pentium+, рассмотрим возможность
измерения малых интервалов посредством обращения к счетчику меток вре-
мени TimeStampCounter. Этот счетчик длиной в 64 бита имеется во всех про-
цессорах Pentium и считает тактовую частоту процессора. Для обращения
к этому счетчику в системе команд имеется команда RDTSC (ReaD Time Stamp
Counter). Эта команда копирует содержимое TimeStampCounter в пару реги-
стров EDX:EAX. После выполнения этой команды надо организовать форми-
рование либо 64-разрядного беззнакового целого (тип long long int), либо
плавающего значения (тип double или float). Это можно сделать следую-
щим фрагментом:
long long int llTime1, llTime2, llDeltaT;
... ...
__asm rdtsc; // Фрагмент, захватывающий время
__asm mov dword ptr [llTime1],eax;
__asm mov dword ptr [llTime1+4],edx;
Ни одно из трех действий, которые выполняют приведенные ассемблерные
команды, невозможно запрограммировать одними только средствами языка
Си. В результате трех первых команд значение счетчика меток оказывается
скопированным в переменную llTime.
Приведенный фрагмент следует выполнить непосредственно перед началом
интервала времени, подлежащего измерению. Далее можно аналогично за-
хватить отсчет времени в конце измеряемого интервала.
//здесь блок кода, время выполнения которого
требуется измерить
__asm rdtsc;
__asm mov dword ptr [llTime2],eax;
__asm mov dword ptr [llTime2+4],edx;
llDeltaT = llTime2-llTime1; //вычислим разность
Разность двух захваченных значений даст длительность измеряемого интер-
вала в периодах тактового генератора процессора на данном компьютере.
При таком измерении возникает систематическая положительная ошибка,
равная времени выполнения трех команд захвата времени.
Если фрагмент кода, содержащий ассемблерные команды, предполагается
использовать неоднократно, его можно инкапсулировать в макрос. Далее
Приложение 2. Язык Си и низкоуровневое программирование 403
приводимый фрагмент кода использует макросы и вычисляет время в форма-
те с плавающей точкой. Этот формат удобен для последующего масштабиро-
вания результатов измерения времени и представления его в наиболее удоб-
ных единицах измерения.
... ...
unsigned int iEAX1,iEDX1,iEAX2,iEDX2;
double dT1,dT2, //для разности тиков
dT0,dTd, //для мертвого времени
dKT; //масштаб пересчета тактов в микросекунды
#define GetTSC1 __asm rdtsc\
__asm mov dword ptr [iEAX1],eax\
__asm mov dword ptr [iEDX1],edx
#define GetTSC2 __asm rdtsc\
__asm mov dword ptr [iEAX2],eax\
__asm mov dword ptr [iEDX2],edx
#define DeltaT dT1=(iEDX2-iEDX1)*4294967296.0+iEAX2-iEAX1-dTd
... ...
//установление мертвого времени
GetTSC1;
GetTSC2;
DeltaT;
dT0=dT1; //однократное измерение и получение начального значения
n=11;
while ((n--)>1) { //повторение измерений
GetTSC1;
GetTSC2;
DeltaT; //... и нахождение минимума
if (dT0>dT1)
dT0=dT1; //по нескольким измерениям
}
dTd=dT0;
wprintf(L" Мертвое время установлено %5.0lf тактов\n", dT0);
404 Приложения
//Измерение тактовой частоты процессора
...
GetTSC1; //захват времени
Sleep(1000); //задержка на 1000 мс
GetTSC2; //захват второго времени
DeltaT; //вычисление разности времен
dKT=100000/dT1; //множитель для перевода системных тактов в
микросекунды
wprintf(L" Тактовая частота данного процессора %10.6lf
МегаГерц\n\n",dT1/1000000); //напечатаем разность
СУЩЕ СТ ВЕ ННО Е З А МЕ Ч А Н И Е!
В некоторых универсальных процессорах реализован программно-аппаратный
механизм энергосбережения, который анализирует текущую загрузку процессо-
ра и при уменьшении загрузки динамически понижает тактовую частоту ядра (ту
самую, что поступает на вход счетчика меток времени — TimeStampCounter).
Так, например, сделано в ряде мобильных (предназначенных для ноутбуков)
процессоров фирмы AMD. В них скорость счета TimeStampCounter оказывается
непостоянной, и использовать TimeStampCounter для точных измерений вре-
мени может быть затруднительно.
Для определения состояния стека можно использовать такую ассемблерную
вставку:
unsigned int uiSP;
... ...
__asm mov dword ptr [uiSP],esp;
... ... //содержимое ESP в переменной uiSP, можно проверять
П2.1.4. Работа с регистрами периферийных
устройств
Каждое периферийное устройство (ПУ) имеет в своем составе один или не-
сколько регистров, которые можно прочитать или записать командами про-
граммы. Сложные периферийные устройства могут содержать несколько де-
сятков регистров. Таким образом, общее количество регистров ПУ в системе
может быть значительным.
В некоторых процессорах доступ к регистрам ПУ осуществляется аналогично
доступу к ячейкам памяти. Каждому регистру присвоен адрес в адресном
пространстве памяти. В этом случае для обращения к регистрам ПУ можно
использовать те же команды, что и для доступа к ячейкам памяти. Такая ор-
ганизация носит название — ввод/вывод, отображаемый на память (Memory-
Mapped Input/Output). Обычно разработчики вычислительной системы выде-
Приложение 2. Язык Си и низкоуровневое программирование 405
ляют для адресации регистров ПУ какой-либо фиксированный диапазон ад-
ресов, а затем выделяют конкретные адреса каждому регистру ПУ.
В других процессорах регистры ПУ могут иметь свою систему адресации
(адресное пространство), никак не связанную с адресацией ячеек памяти. Для
обращения к регистрам ПУ в системе команд имеются специальные команды
ввода/вывода. Такая организация обмена с ПУ носит название — изолиро-
ванный ввод/вывод.
Для обозначения программно-доступных регистров периферийных устройств
в компьютерной литературе употребляют термин "порты ввода/вывода".
В процессорах семейства х86 реализован изолированный ввод/вывод. В со-
ставе системы команд имеются команды, позволяющие программисту ука-
зать адрес порта в адресном пространстве ввода/вывода и прочитать из порта
(или записать в него) двоичное слово. Однако разработчики периферийных
устройств при их проектировании используют возможность сделать видимы-
ми отдельные объекты ПУ через адресное пространство памяти.
Как можно из Си-программы получить доступ к портам ввода-вывода?
Если в ВС использован (как основной) ввод/вывод, отображаемый на память,
то можно объявить указатель, проинициализировать его значением соответ-
ствующего адреса (в последующем примере этот адрес равен 0xFFFF0000,
после чего можно обращаться к регистру ПУ через этот указатель:
unsigned int * pPort = (unsigned int *)0xFFFF0000;
Однако здесь имеются два маленьких "но".
Первое "но" состоит в том, что регистр порта может модифицироваться ап-
паратно в результате внешних по отношению к процессору событий (таких,
как нажатие на клавишу), и об этом следует сообщить компилятору, исполь-
зовав ключевое слово volatile:
volatile unsigned int * pPort = (unsigned int *)0xFFFF0000;
В этом случае компилятор при каждом обращении к переменной *pPort бу-
дет обращаться по указанному адресу (и никогда не будет использовать для
хранения считанного значения регистры процессора).
Второе "но" — объявленный указатель хорошо бы защитить от случайной
модификации ключевым словом const:
volatile unsigned int * const pPort1 =
(volatile unsigned int * const) 0xFFFF0000;
......
var=*pPort1; //теперь можно читать порт
406 Приложения
Можно обойтись и без объявления указателя (экономим память), просто на-
писав следующее:
var=*((volatile int*)0xFFFF0000); //читаем порт по его адресу
Но запись справа от знака равенства весьма длинна. Заменим ее коротким
обозначением с помощью макроопределения:
#define PORT1 *((volatile int*)0xFFFF0000);
Теперь можно будет писать гораздо короче:
var=PORT1; //для чтения из порта в переменную … и все !
PORT1=0x123; //запись в порт
Что делать, если обращение к регистрам ПУ организовано через изолиро-
ванный ввод/вывод (как в системах на базе процессоров Intel x86)? Придется ис-
пользовать команды доступа к адресному пространству ввода/вывода in и out.
Си-компилятор, увы, этих команд (и также некоторых других) не знает. Вы-
ход — в использовании встроенного (inline) Ассемблера. Для обращения
к портам в отдельном адресном пространстве ввода/вывода можно написать и
использовать в тексте Си-программы несколько макросов, которые позволяют
выполнять действия с содержимым регистров портов. Примеры использования
встроенного Ассемблера и макросов уже были рассмотрены в разд. П2.1.3.
Модель периферийного устройства для программиста — это набор регист-
ров в периферийном устройстве, которые программист может прочи-
тать/записать программно.
Простейшая модель ПУ для программиста может содержать весьма мало ре-
гистров:
􀂈 регистр состояния (статуса) — минимально содержит один бит — флаг
состояния ПУ;
􀂈 регистр (буфер) данных — запись/чтение этого регистра обеспечивает об-
мен данными с ПУ.
П2.1.5. Синхронизация программы
с внешним событием
Ситуации, когда требуется синхронизация выполнения программы с внеш-
ним событием, возникают, прежде всего, при обмене данными с периферий-
ными устройствами, в частности — с устройствами ввода/вывода. Например:
􀂈 прежде чем записать байт в регистр данных передатчика COM-порта, про-
грамма должна убедиться, что процесс передачи предыдущего байта за-
вершился, и регистр данных передатчика свободен;
Приложение 2. Язык Си и низкоуровневое программирование 407
􀂈 при выводе данных на принтер программа печати должна убедиться, что
предыдущая порция данных напечатана (печать происходит довольно
долго), и принтер способен принять новую порцию.
Возможны обратные ситуации, когда, наоборот, при наступлении события
нельзя продолжать выполнение текущей программы. Например:
􀂈 произошло деление на нуль, и следующую операцию, которая должна ис-
пользовать результат деления, выполнить невозможно;
􀂈 пользователь нажал <Ctrl>+<Break>, и выполнять программу дальше не
следует.
Общим в приведенных ситуациях является то, что в определенные моменты
программа должна прореагировать на некоторое событие (реакция — пере-
дача управления по условию наступления внешнего события).
Рассмотрим, каким образом программа может узнать о наступлении события.
Простейший способ — программный опрос готовности (polling) представлен
на рис. П2.1.
Рис. П2.1
Опрос готовности состоит чаще всего в анализе состояния определенных би-
тов в регистре статуса (состояния). При достижении состояния готовности
к обмену ПУ устанавливает этот(эти) бит(ы) в определенное состояние. Об-
мен с ПУ состоит в чтении/записи в регистр данных.
Так, если передатчик последовательного порта COM1 передал предыдущий
байт, то автоматически устанавливается флаг готовности: бит 04 в порте
LineStatus (0x3FD). Фрагмент Си-программы (для компилятора Borland C 3.1),
408 Приложения
передающий байт в регистр данных передатчика DataPort, может выглядеть
следующим образом:
while (inportb(LineStatus)&0x20==0) {}; //ждем готовности передатчика
outportb(DataPort,OutByte++); //передаем следующий байт
Здесь:
inportb() и outportb() — стандартные библиотечные функции обращения
к портам ввода/вывода.
Несмотря на простоту приведенного фрагмента, он имеет существенный недос-
таток — во время опроса состояния передатчика процессор не может выполнять
другой (полезной) работы. А ведь опрос (по процессорным меркам) продолжает-
ся очень долго: даже при скорости передачи 115 200 кБит/с за время передачи
байта процессор Pentium 4 успеет выполнить около 500 тыс. команд.
Поэтому в случаях, подобных описанному, для синхронизации программы
с внешним событием (готовность ПУ) используют механизм аппаратных
прерываний.
П2.2. Программирование обработчиков
прерываний
Термин прерывание в русскоязычной компьютерной литературе многозначен
и употребляется для обозначения трех различных вещей:
􀂈 hardware interrupt — аппаратное прерывание;
􀂈 exсeption — исключение, т. е. прерывание по исключительной (экстраор-
динарной) внутренней ситуации;
􀂈 software interrupt — программное прерывание.
Термин обработка прерывания может использоваться для обозначений двух
различных вещей:
􀂈 действия, которое автоматически выполняет процессор при возникнове-
нии запроса (они реализованы аппаратно);
􀂈 действия, которое выполняет подпрограмма-обработчик прерывания
(handler).
Мы будем использовать термин обработка прерывания только во втором
смысле, а для первой группы действий будем употреблять термин вход в пре-
рывание.
ВА Ж Н О Е З А МЕ Ч А Н И Е
Аппаратное прерывание аналогично вызову функции (подпрограммы), только
этот вызов происходит не по команде вызова подпрограммы, а как следствие
Приложение 2. Язык Си и низкоуровневое программирование 409
внешнего (по отношению к процессору) события, которое вызывает приход в про-
цессор внешнего электрического сигнала (запроса прерывания). Существенная
особенность рассматриваемой ситуации состоит в том, что момент наступле-
ния события может быть никак не связан с текущим состоянием программы.
Будем далее называть функцию (подпрограмму), реагирующую на такое со-
бытие, обработчиком прерывания (interrupt handler или exception handler).
При программировании и/или использовании обработчиков прерываний про-
граммисту придется учитывать ряд обстоятельств, которые сейчас и рассмотрим.
П2.2.1. Запрет/разрешение прерываний процессору
В программе могут существовать участки кода, которые должны выполнять-
ся неразрывно (атомарные операции). Для обеспечения такой неразрывности,
любой процессор имеет средства, позволяющие программисту запрещать/
разрешать процессору реакцию на сигналы запросов прерываний. Обычно
для этого служит один из битов регистра состояния процессора, который од-
ним из двух своих значений разрешает, а другим запрещает реакцию процес-
сора на сигнал запроса прерывания. Этот бит называют флагом или маской
прерывания. Термин флаг используют, если единичное состояние этого бита
разрешает прерывание, а термин маска используется, если единичное со-
стояние бита запрещает прерывание.
Чтобы разрешить/запретить прерывание, программист должен иметь воз-
можность изменять флаг прерывания. Для этого используется либо прямая
модификация регистра состояний (если архитектура процессора это позволя-
ет), либо пара специальных процессорных команд (разрешить прерывание
и запретить прерывание). Собственно в языке Си средства для разрешения
и запрета прерываний отсутствуют. Однако в стандартную библиотеку функ-
ций такие средства могут быть включены (а может быть, и нет).
Код таких функций (или макросов) может быть написан на Ассемблере. На-
пример, в системе команд процессоров x86 имеются команды:
􀂈 sti — для разрешения прерывания;
􀂈 cli — для запрета прерывания.
Эти две команды изменяют состояние бита разрешения прерываний в реги-
стре состояний. Для разрешения/запрета прерываний можно определить два
макроса:
#define DIS_INT __asm cli;
#define EN_INT __asm sti;
При использовании таких средств следует иметь в виду, что в тот момент,
когда выполняется макрос DIS_INT, прерывание уже может быть запрещено.
410 Приложения
Поэтому по окончании критической секции кода следует не просто разре-
шить прерывание, но восстановить то состояние процессора, которое было на
момент выполнения DIS_INT. Для этого при запрещении прерывания необхо-
димо запомнить текущее состояние флага прерывания в регистре состояний:
... ...
int iFl; //локальная переменная в функции или блоке
#define ENTER_CRITICAL __asm {push ax\
pushf\
pop ax\
and ax,0x0200\
mov word ptr[iFl],ax\
pop ax\
cli\
};
//для восстановления состояния процессора можно определить еще
один макрос:
#define EXIT_CRITICAL __asm {push ax\
pushf\
pop ax\
or ax, word ptr[iFl]\
push ax\
popf\
pop ax\
};
П2.2.2. Приоритеты и управление ими
В более-менее сложной ВС одновременно могут быть активны несколько ис-
точников запросов аппаратных прерываний (т. е. может одновременно про-
исходить взаимодействие с несколькими периферийными устройствами).
Если прерывание было запрещено в течение некоторого времени, а затем вы-
полнилась команда разрешить прерывание, то к этому времени возможно
наличие нескольких одновременно действующих запросов. В такой ситуации
должно существовать правило, в соответствии с которым выбирается один из
запросов для первоочередной обработки (приоритеты).
Разработчики вычислительной системы принимают решение об относительной
важности (приоритетности) различных источников запросов. В некоторых ВС
у программиста имеется возможность изменять приоритеты запросов.
Приложение 2. Язык Си и низкоуровневое программирование 411
Запрет вложенных прерываний
и возможность их разрешения
Правило выбора запроса в соответствии с его приоритетом действует лишь
в процессе входа в прерывание. Поэтому для исключения вложенного преры-
вания при входе в прерывание в процессоре аппаратно выполняется команда
запретить прерывание, исключая тем самым реакцию на другие запросы
и возникновение вложенного прерывания. Однако программисту не запреще-
но в обработчике прерывания выполнить команду разрешить прерывание.
После этого вложенное прерывание оказывается возможным.
Маскирование запросов от отдельных источников
В вычислительной системе очень часто имеется возможность программно
запретить (замаскировать) или разрешить прохождение запросов от отдель-
ных ПУ. Это дает возможность программисту активировать только нужные
ему запросы. Кроме того, маскируя на время отдельные запросы, можно
управлять порядком их обработки (т. е. приоритетами).
Маскирование запросов обычно осуществляется изменением бита маски
в одном из регистров периферийного устройства. Чаще всего, единичное зна-
чение этого бита запрещает (маскирует) запрос прерывания.
Понятие контекста программы и необходимость его
сохранения/восстановления при обработке прерываний
Совокупность cодержимого регистров процессора характеризует текущее
состояние программы. Следуя принятой терминологии, будем эту совокуп-
ность называть контекстом программы.
Поскольку код обработчика прерывания (возможно) использует регистры
процессора, в них к моменту входа в обработчик могут содержаться проме-
жуточные результаты, сформированные прерванной программой. Поэтому
обработчик прерывания первым делом должен сохранить (в стеке) контекст
прерванной программы. В большинстве процессоров это сохранение следует
выполнять программно. В некоторых процессорах операция сохранения кон-
текста при входе в обработчик прерывания выполняется аппаратно (напри-
мер, Motorola 6811, 6812).
По окончании кода обработчика перед возвратом в прерванную программу
контекст следует восстановить (скопировать в регистры значения, ранее со-
храненные в стеке).
Сохранение и восстановление контекста в стеке может быть запрограммиро-
вано только с использованием средств языка Ассемблера. Обычно эта функция
412 Приложения
возлагается на компилятор, но он должен быть осведомлен о том, что данная
подпрограмма (функция) — это обработчик прерывания. Для этого в некото-
рых диалектах языка Си имеется ключевое слово interrupt, которое сооб-
щает компилятору, что данная функция является обработчиком прерывания,
при входе в нее следует сохранить полный контекст, а перед выходом вос-
становить его. Обычно при входе в прерывание в стеке аппаратно сохраняется
не только адрес возврата, но и содержимое регистра состояния процессора.
Кроме того, компилятор организует выход из обработчика прерывания спе-
циальной командой (возврат из прерывания), по этой команде из стека до-
полнительно будет восстановлено содержимое регистра состояния процессора.
При организации многозадачного режима работы с вытесняющей многоза-
дачностью Диспетчер Задач получает управление по запросу аппаратного
прерывания, выполняет операцию планирования (принимает решение, следу-
ет ли выполнить переключение задачи) и при положительном решении дол-
жен выполнить процедуру переключения контекста. Обычно эта часть кода
многозадачной операционной системы оказывается платформно-зависимой и
пишется на языке Ассемблера.
П2.3. Программирование
без операционной системы
Перед тем как начнет работать код, сгенерированный компилятором из ва-
шей Си-программы, необходимо произвести в вычислительной системе ряд
начальных настроек. Объем этой работы зависит от сложности аппаратной
части и может варьироваться в весьма в широких пределах.
Однако некоторые действия для конкретной ВС могут быть обязательными.
Вот некоторые из них:
􀂈 задание местоположения стека (или стеков, если в системе их требуется
несколько). Пример системы, в которой с самого начала может потребо-
ваться несколько стеков — это ВС на базе процессоров с архитектурой
ARM. Процессоры ARM требуют индивидуального стека для каждого из
шести режимов, в которых может находиться процессор;
􀂈 настройка режимов работы процессора. Для этого может понадобиться
доступ к системным регистрам. Если системные регистры видны через ад-
ресное пространство памяти (как регистры периферийных устройств), то
это можно сделать средствами Си. Но иногда для доступа к системным
регистрам в процессоре используются специальные команды, запрограм-
мировать которые можно только средствами языка Ассемблера;
Приложение 2. Язык Си и низкоуровневое программирование 413
􀂈 настройка подсистемы прерывания:
• переключение режимов работы контроллера прерываний;
• занесение векторов используемых прерываний;
• запрет/разрешение отдельных запросов;
• разрешение прерывания процессору;
􀂈 конфигурирование памяти. В некоторых процессорах имеется возмож-
ность программно управлять диапазонами адресов, через которые про-
граммист видит различные программно-доступные элементы;
􀂈 настройка подсистемы тактирования и управления потребляемой процес-
сором мощностью. Это позволяет обменивать производительность про-
цессора на потребляемую им мощность. Перед началом работы програм-
мы могут потребоваться вполне определенные настройки подсистемы
тактирования;
􀂈 инициализация глобальных переменных и, может быть, некоторых других
областей памяти;
􀂈 инициализация отдельных периферийных устройств, необходимых для
работы ВС, в частности — системного таймера.
Перечисленные действия (а может быть и еще какие-то — это зависит от
процессора) должны быть выполнены до входа в функцию main, т. е. до того,
как начнет выполняться код, соответствующий операторам Си-программы.
Часть настроечных действий невозможно выполнить средствами Си. Поэто-
му пользуются приемом, позволяющим обеспечить выполнение настроечных
действий — это включение в проект так называемого start-up-файла, который
обычно написан на языке Ассемблера. Этот файл содержит стандартный на-
бор настроечных действий, которые всегда должны быть выполнены до на-
чала основной программы, написанной на Си. Компоновка производится та-
ким образом, что этот файл получает управление первым, выполняет
настроечные действия, а затем вызывает функцию main.
Для выполнения низкоуровневой оптимизации программист может при от-
ладке произвести действия по профилированию программы — определить,
сколько времени выполняются отдельные ее части и выявить критичные ко
времени фрагменты кода. Затем можно проанализировать их и, если есть та-
кая возможность, переписать эти фрагменты, используя либо средства встро-
енного Ассемблера, либо выделив оптимизированные фрагменты в отдель-
ный файл на языке Ассемблера. В некоторых случаях это позволит увеличить
скорость работы программы весьма существенно (на десятки процентов, а то
и в разы).
Ïðåäìåòíûé óêàçàòåëü
C, L
const 109
Lvalue 30
N
namespace 97
директива using 101
неименованные 106
стандартной библиотеки
(std) 106
S, V
sizeof 69
static 91
volatile 110
Б
Блок кода 24
Д
Декорирование имен 88
Динамическое выделение памяти
Динамические массивы 218, 225
Инициализация динамических
массивов 234
Операторы С++ new и delete 222
Различие операторов delete
и delete[] 233
Сборщик мусора 225
Функции языка Си 219
З
Заголовочные файлы 152
Защита от повторных
включений 166
Предкомпиляция 159
Стандартизованные 164
Стандартной библиотеки 162
И
Идентификаторы 29
Инструкции 113
break 126, 133, 134
continue 126, 132, 133, 134
do...while 127
for 129
goto 134
if, if…else 115
return 134
switch 118
while 123
К
Ключевые слова 29
Комментарии 26
416 Ïðåäìåòíûé óêàçàòåëü
Л
Литералы 51
escape-последовательности 60
С плавающей точкой 54
Символьные 55
Строковые 61
Целые 52
М
Массивы 196
Неявная инициализация 200
Объявление 196
Оператор [] 198
Оператор sizeof 206
Указателей 216
Явная инициализация 200
Модульность 13
О
Объединение 345
Анонимное 351
Инициализация 350
Оператор sizeof 349
Сравнение
со структурами 346
Объявление 82
Операторы 31, 47
Ассоциативность 32
Декремент 36
Инкремент 36
Логические 43
Отношения 43
Побитовые 39
Приоритет 31
Сдвига 40
совмещенные операторы
присваивания 39
Тернарный 45
Определение 83
П
Переменные 65
Время жизни 90
Замещение области видимости 95
Знаковость переменной 71
Инициализация 108
Область видимости 94
Оператор разрешения области
видимости 96
Способы использования 86
Способы размещения 89
Тип bool 81
Тип wchar_t 81
Тип переменной 66
Типы компоновки 87
Перечисление (enum) 62
Порядок синтаксического разбора
выражения 37
Препроцессор 137
assert 144
Директива #define 138
Директива #error 171
Директива #include 155
Директива #pragma 170
Директива #undef 145
Директивы #if, #elif 149
Директивы #ifdef, #ifndef, #else,
#endif 147
Оператор defined 149
Предопределенные макросы 143
Приведение типов 73
Неявное 74
Явное 78
Псевдонимы типов (typedef) 85
Р
Раздельная компиляция 15
С
Связь массивов и указателей 207
Двухмерные массивы 210
Многомерные массивы 214
Одномерные массивы 207
Ссылки 235
Инициализация 236
Константные 239
На указатель 238
Ïðåäìåòíûé óêàçàòåëü 417
Объявление 236
Сравнение с указателями 236
Структуры 313
typedef 318
Анонимные 319
В качестве возвращаемого
функцией значения 332
В качестве параметра функции 329
Вложенные 323
Доступ к полям 317
Инициализация 320
Объявление 314
Оператор sizeof 326
Поля битов 334
Поля пользовательского типа 322
Селектор . 317
Селектор -> 324
Создание экземпляров 316
Тип поля 333
Указатели на структуры 324
Упаковка полей 326
У
Указатели 173
typedef и указатель на массив 308
typedef и указатель
на функцию 308, 311
Арифметика указателей 180
Инициализация 177
Ключевые слова const и volatile 187
На данные 174
Нулевой указатель 184
Объявление 175
Оператор & 177
Оператор * 179
Оператор const_cast 192
Оператор reinterpret_cast 178, 193
Оператор static_cast 183
Указатель на указатель 186
Указатель на функцию 301
Указатель типа void* 182
Ф
Фундаментальные типы 67
Функции 18, 241
__cdecl 255
__fastcall 257
__stdcall 256
inline 252
main 21
printf(), scanf() 277
Возвращаемое значение 287
Вызов 242, 248
Выражения в качестве параметров 264
Значения параметров
по умолчанию 267
Ключевое слово const 292
Назначение 242
Неиспользуемые параметры 269
Объявление 242, 244
Определение 242, 246
Параметры функции main 270
Перегрузка имен функций 295
Передача массивов в функцию 265
Передача параметров по адресу 260
Передача параметров
по значению 259
Переменное число параметров 272
Проблемы при возвращении
адреса 290
Рекурсивные 298
Соглашения о вызове 254
Указатель на функцию 301
Э
Этапы получения загрузочного
модуля 13